((push.const . |.list?|)
 (push.gloc.of list?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 7171)
 (push.const . |.null?|)
 (push.gloc.of null?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 8195)
 (push.const . |.pair?|)
 (push.gloc.of pair?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 9219)
 (push.const . |.car|)
 (push.gloc.of car)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 10243)
 (push.const . |.cdr|)
 (push.gloc.of cdr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 11267)
 (push.const . |.caar|)
 (push.gloc.of caar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 12291)
 (push.const . |.cadr|)
 (push.gloc.of cadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 13315)
 (push.const . |.cdar|)
 (push.gloc.of cdar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 14339)
 (push.const . |.cddr|)
 (push.gloc.of cddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 15363)
 (push.const . |.caaar|)
 (push.gloc.of caaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 16387)
 (push.const . |.caadr|)
 (push.gloc.of caadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 17411)
 (push.const . |.cadar|)
 (push.gloc.of cadar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 18435)
 (push.const . |.caddr|)
 (push.gloc.of caddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 19459)
 (push.const . |.cdaar|)
 (push.gloc.of cdaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 20483)
 (push.const . |.cdadr|)
 (push.gloc.of cdadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 21507)
 (push.const . |.cddar|)
 (push.gloc.of cddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 22531)
 (push.const . |.cdddr|)
 (push.gloc.of cdddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 23555)
 (push.const . |.cdddar|)
 (push.gloc.of cdddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 24579)
 (push.const . |.caddar|)
 (push.gloc.of caddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 25603)
 (push.const . |.cddadr|)
 (push.gloc.of cddadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 26627)
 (push.const . |.cadadr|)
 (push.gloc.of cadadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 27651)
 (push.const . |.caaadr|)
 (push.gloc.of caaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 28675)
 (push.const . |.cddddr|)
 (push.gloc.of cddddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 29699)
 (push.const . |.cadddr|)
 (push.gloc.of cadddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 30723)
 (push.const . |.cdaadr|)
 (push.gloc.of cdaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 31747)
 (push.const . |.cdaddr|)
 (push.gloc.of cdaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 32771)
 (push.const . |.caaddr|)
 (push.gloc.of caaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 33795)
 (push.const . |.list|)
 (push.gloc.of list)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 34819)
 (push.const . |.cons*|)
 (push.gloc.of cons*)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 35843)
 (push.const . |.memq|)
 (push.gloc.of memq)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 36867)
 (push.const . |.append|)
 (push.gloc.of append)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 37891)
 (push.const . |.apply|)
 (push.gloc.of apply)
 (ret.subr.gloc.of set-top-level-value! "./boot/first-load.scm" . 38915))

;
((close
   (0 1 . max)
   (iloc.0 . 0)
   (if.null?
     (push.const . max)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 8204))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 9242)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 9228)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 12316))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 13347)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 13333)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 14370)
           (>.iloc (0 . 0) "./boot/r6rs-aux.scm" . 14367)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 14387))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 15404)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 15394))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 16411)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 14357))
       (push.const . max)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 18515)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 18479)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 18453))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10270)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10296)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 10286)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10314)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 10252))
   (push.const . max)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 20554)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 20518)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 20492))
 (set.gloc.of max)
 (ret.const.unspec))
((close
   (0 1 . min)
   (iloc.0 . 0)
   (if.null?
     (push.const . min)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 25612))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 26650)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 26636)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 29724))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 30755)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 30741)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 31778)
           (<.iloc (0 . 0) "./boot/r6rs-aux.scm" . 31775)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 31795))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 32812)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 32802))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 33819)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 31765))
       (push.const . min)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 35923)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 35887)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 35861))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27678)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27704)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 27694)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27722)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 27660))
   (push.const . min)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 37962)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 37926)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 37900))
 (set.gloc.of min)
 (ret.const.unspec))
((close
   (2 0 . gcd2)
   (=n.iloc (0 . 1) 0 "./boot/r6rs-aux.scm" . 41993)
   (if.true
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 43026)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 43039))
       (ret.iloc 0 . 0))
     (push)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 43017))
   (touch.gloc.of gcd2)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of remainder 2 "./boot/r6rs-aux.scm" . 44049)
   (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 44041))
 (set.gloc.of gcd2)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 53261)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54292)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54302)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 54286))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 55315)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 55310))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 0)
   (touch.gloc.of |loop`7|)
   (call
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57377)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57387)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 57371))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57399)
   (push.cons)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 57359))
 (set.gloc.of |loop`7|)
 (close
   (0 1 . gcd)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 49173)
       (if.true.ret)
       (push.const . gcd)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 50223)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 50197))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 48133))
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 52229))
 (set.gloc.of gcd)
 (ret.const.unspec))
((close
   (2 0 . lcm2)
   (call
     (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 64529)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 0)
     (ret.subr.gloc.of = "./boot/r6rs-aux.scm" . 64537))
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of exact? 1 "./boot/r6rs-aux.scm" . 65558)
       (if.false.ret)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of exact? "./boot/r6rs-aux.scm" . 65569))
     (if.true.ret.const . 0)
     (ret.const . 0.0))
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of gcd2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 66593))
   (push)
   (push.subr.gloc.of quotient 2 "./boot/r6rs-aux.scm" . 66581)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 66578)
   (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 66573))
 (set.gloc.of |lcm2`2|)
 (close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 73741)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74772)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74782)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 74766))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 75795)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 75790))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 1)
   (touch.gloc.of |loop`9|)
   (call
     (touch.gloc.of |lcm2`2|)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77857)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77867)
     (apply.gloc.of |lcm2`2| "./boot/r6rs-aux.scm" . 77851))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77879)
   (push.cons)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 77839))
 (set.gloc.of |loop`9|)
 (close
   (0 1 . lcm)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 69653)
       (if.true.ret)
       (push.const . lcm)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 70703)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 70677))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 68613))
   (touch.gloc.of |loop`9|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`9| "./boot/r6rs-aux.scm" . 72709))
 (set.gloc.of lcm)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 92183)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.subr.gloc.of ceiling 1 "./boot/r6rs-aux.scm" . 94240)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 1) "./boot/r6rs-aux.scm" . 95264)
   (if.true (ret.iloc 0 . 0))
   (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 97321)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1)
   (call
     (touch.gloc.of |loop`7|)
     (push.const . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98359)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98354)
     (push.const . 1)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98375)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98370)
     (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 98348))
   (push)
   (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98343)
   (ret.subr.gloc.of + "./boot/r6rs-aux.scm" . 98338))
 (set.gloc.of |loop`7|)
 (close
   (2 0 . rationalize)
   (push.iloc.0 . 0)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 81929)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 81973)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 82026)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 81939))
   (push.iloc.0 . 1)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 82953)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 82997)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 83050)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 82963))
   (push.iloc.0 . 1)
   (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 83980)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 85008)
     (if.true.ret.const . +nan.0)
     (ret.const . 0.0))
   (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 86028)
   (if.true.ret.const . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of negative? 1 "./boot/r6rs-aux.scm" . 87052)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 1 "./boot/r6rs-aux.scm" . 88092)
       (push.iloc.0 . 1)
       (apply.gloc.of rationalize "./boot/r6rs-aux.scm" . 88079))
     (push)
     (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 88076))
   (push.iloc.0 . 1)
   (push.subr.gloc.of abs 1 "./boot/r6rs-aux.scm" . 90133)
   (extend . 1)
   (touch.gloc.of |loop`7|)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 91169)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of + 2 "./boot/r6rs-aux.scm" . 91183)
   (apply.gloc.of |loop`7| "./boot/r6rs-aux.scm" . 91150))
 (set.gloc.of rationalize)
 (ret.const.unspec))
((close
   (1 0 . list->string)
   (push.gloc.of string)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 101393))
 (set.gloc.of list->string)
 (ret.const.unspec))
((close
   (1 0 . list->vector)
   (push.gloc.of vector)
   (push.iloc.0 . 0)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 104465))
 (set.gloc.of list->vector)
 (ret.const.unspec))
((close
   (1 0 . string->list)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 109579)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 111633)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-ref 2 "./boot/r6rs-aux.scm" . 111647)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 111627))
   (push.iloc.1 . 0)
   (push.subr.gloc.of string-length 1 "./boot/r6rs-aux.scm" . 108566)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 108563)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 108549))
 (set.gloc.of string->list)
 (ret.const.unspec))
((close
   (2 0 . map-n)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 128034)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 128022))
   (push)
   (call
     (touch.gloc.of |map-n`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 129058)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 129046))
   (ret.cons "./boot/r6rs-aux.scm" . 128016))
 (set.gloc.of |map-n`2|)
 (close
   (2 0 . map-1)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 120860)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 120854))
   (push)
   (call
     (touch.gloc.of |map-1`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 121890)
     (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 121878))
   (ret.cons "./boot/r6rs-aux.scm" . 120848))
 (set.gloc.of |map-1`2|)
 (close
   (2 1 . map)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 132109)
     (if.true
       (touch.gloc.of |map-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |map-1`2| "./boot/r6rs-aux.scm" . 133133))
     (push.const . map)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 134183))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 134234)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 134157))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 135184))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |map-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |map-n`2| "./boot/r6rs-aux.scm" . 136225))
   (push.const . map)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 138318)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 138256))
 (set.gloc.of map)
 (ret.const.unspec))
((close
   (2 0 . for-each-n)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 151597)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 151585))
   (touch.gloc.of |for-each-n`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 152626)
   (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 152609))
 (set.gloc.of |for-each-n`2|)
 (close
   (2 0 . for-each-1)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 146470)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 146464))
   (touch.gloc.of |for-each-1`2|)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 147505)
   (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 147488))
 (set.gloc.of |for-each-1`2|)
 (close
   (2 1 . for-each)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 154637)
     (if.true
       (touch.gloc.of |for-each-1`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |for-each-1`2| "./boot/r6rs-aux.scm" . 155661))
     (push.const . for-each)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 156716))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 156767)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 156685))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 157712))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |for-each-n`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |for-each-n`2| "./boot/r6rs-aux.scm" . 158753))
   (push.const . for-each)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 160851)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 160784))
 (set.gloc.of for-each)
 (ret.const.unspec))
((close
   (2 1 . vector-map)
   (call
     (push.gloc.of map)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 165910)
     (call
       (push.gloc.of vector->list)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/r6rs-aux.scm" . 166925))
     (push)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 165894))
   (push)
   (apply.gloc.of list->vector "./boot/r6rs-aux.scm" . 164869))
 (set.gloc.of vector-map)
 (ret.const.unspec))
((close
   (2 1 . vector-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 171034)
   (call
     (push.gloc.of vector->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 172044))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 171013))
 (set.gloc.of vector-for-each)
 (ret.const.unspec))
((close
   (2 1 . string-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/r6rs-aux.scm" . 176154))
   (push)
   (call
     (push.gloc.of string->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 177164))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 176133))
 (set.gloc.of string-for-each)
 (ret.const.unspec))
((close
   (2 0 . call-with-values)
   (touch.gloc.of apply-values)
   (push.iloc.0 . 1)
   (call (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 181276))
   (push)
   (apply.gloc.of apply-values "./boot/r6rs-aux.scm" . 181253))
 (set.gloc.of call-with-values)
 (ret.const.unspec))
((close
   (2 0 . mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 185357)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 185354)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 185349))
 (set.gloc.of mod)
 (ret.const.unspec))
((close
   (2 0 . div-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 189454)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 190486)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 190481)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 190471))
 (set.gloc.of div-and-mod)
 (ret.const.unspec))
((close
   (2 0 . mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 194573)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 194570)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 194565))
 (set.gloc.of mod0)
 (ret.const.unspec))
((close
   (2 0 . div0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 198671)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 199703)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 199698)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 199687))
 (set.gloc.of div0-and-mod0)
 (ret.const.unspec))

;
((close
   (1 0 . top-level-unbound?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-bound? 1 "./boot/common.scm" . 7178)
   (ret.subr.gloc.of not "./boot/common.scm" . 7173))
 (set.gloc.of top-level-unbound?)
 (ret.const.unspec))
((close
   (3 0 . acons)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (ret.cons "./boot/common.scm" . 11269))
 (set.gloc.of acons)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 16413)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 16423)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 16407))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . count-pair)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 15365))
 (set.gloc.of count-pair)
 (ret.const.unspec))
((close
   (1 0 . circular-tree?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (2 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/common.scm" . 22546)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/common.scm" . 23570))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 25625)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/common.scm" . 27685)
           (push.iloc.0 . 0)
           (apply.iloc (2 . 0) "./boot/common.scm" . 27679))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/common.scm" . 28709)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/common.scm" . 28703))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/common.scm" . 29721)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 30745)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 32813))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/common.scm" . 32832)
         (apply.gloc.of any1 "./boot/common.scm" . 32795))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/common.scm" . 33817)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 34841)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 36909))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/common.scm" . 36928)
         (apply.gloc.of any1 "./boot/common.scm" . 36891))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc (0 . 0) "./boot/common.scm" . 21516))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of circular-tree?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 45073)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 45083)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 45067))
   (call (iloc.0 . 0) (if.not.null?.ret.const . #f) (ret.iloc 0 . 1))
   (if.true.ret)
   (ret.const . -1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . safe-length)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 43013))
 (set.gloc.of safe-length)
 (ret.const.unspec))
((close
   (2 0 . split-at)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-head 2 "./boot/common.scm" . 50191)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-tail 2 "./boot/common.scm" . 50209)
   (ret.subr.gloc.of values "./boot/common.scm" . 50183))
 (set.gloc.of split-at)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/common.scm" . 57384)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 58400)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 58410)
   (subr.gloc.of memq 2 "./boot/common.scm" . 58394)
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 59424)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 59418))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . unique-id-list?)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 54282)
   (if.false.ret)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/common.scm" . 55311))
   (push)
   (ret.subr.gloc.of not "./boot/common.scm" . 54277))
 (set.gloc.of unique-id-list?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 66587)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 66597)
   (subr.gloc.of memq 2 "./boot/common.scm" . 66581)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/common.scm" . 67605))
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 68635)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 68629))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . find-duplicates)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 63498)
   (if.false.ret)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`5| "./boot/common.scm" . 64522))
 (set.gloc.of find-duplicates)
 (ret.const.unspec))
((close
   (2 0 . every1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/common.scm" . 74768))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 76826)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 76837)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 76820))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 73754)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 73771)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 73737))
 (set.gloc.of every1)
 (ret.const.unspec))
((close
   (3 0 . every2)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 2)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (4 0 . loop)
     (call (push.iloc.0 . 0) (push.iloc.0 . 2) (apply.iloc (2 . 0) "./boot/common.scm" . 83984))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 3)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 87066)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 87078)
     (push.car.iloc (0 . 3) "./boot/common.scm" . 87090)
     (push.cdr.iloc (0 . 3) "./boot/common.scm" . 87102)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 87060))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 82971)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 82990)
   (push.car.iloc (1 . 2) "./boot/common.scm" . 83009)
   (push.cdr.iloc (1 . 2) "./boot/common.scm" . 83028)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 82953))
 (set.gloc.of every2)
 (ret.const.unspec))
((close
   (2 0 . any1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 92180)
     (apply.iloc (0 . 0) "./boot/common.scm" . 92174))
   (if.true.ret)
   (touch.gloc.of any1)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 92202)
   (apply.gloc.of any1 "./boot/common.scm" . 92191))
 (set.gloc.of any1)
 (ret.const.unspec))
((close
   (3 0 . any2)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 2)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 98324)
     (push.car.iloc (0 . 2) "./boot/common.scm" . 98335)
     (apply.iloc (0 . 0) "./boot/common.scm" . 98318))
   (if.true.ret)
   (touch.gloc.of any2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 99353)
   (push.cdr.iloc (0 . 2) "./boot/common.scm" . 99364)
   (apply.gloc.of any2 "./boot/common.scm" . 99342))
 (set.gloc.of any2)
 (ret.const.unspec))
((close
   (2 0 . filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105492)
       (apply.iloc (2 . 0) "./boot/common.scm" . 105486))
     (if.true
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105509)
       (call
         (push.cdr.iloc (0 . 0) "./boot/common.scm" . 105525)
         (apply.iloc+ (1 . 0) "./boot/common.scm" . 105519))
       (ret.cons "./boot/common.scm" . 105503))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 106521)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 106515))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 103429))
 (set.gloc.of filter)
 (ret.const.unspec))
((close
   (2 0 . partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111650)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111665)
       (ret.subr.gloc.of values "./boot/common.scm" . 111642))
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112660)
       (apply.iloc (2 . 0) "./boot/common.scm" . 112654))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/common.scm" . 112677)
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112693)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 112671))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 113689)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/common.scm" . 113710)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 113683))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 110597))
 (set.gloc.of partition)
 (ret.const.unspec))
((close
   (2 0 . split->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/common.scm" . 120851)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop1)
     (extend.enclose+
       (1 0 . loop2)
       (push.iloc.0 . 0)
       (subr.gloc.of eof-object? 1 "./boot/common.scm" . 124950)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 125983)
         (extend . 1)
         (push.iloc.0 . 0)
         (push.const . "")
         (subr.gloc.of string=? 2 "./boot/common.scm" . 127004)
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of reverse "./boot/common.scm" . 128028))
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (push.cons)
         (ret.subr.gloc.of reverse "./boot/common.scm" . 129052))
       (call (push.iloc.0 . 0) (apply.iloc (5 . 1) "./boot/common.scm" . 130070))
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 131107)
         (iloc 2 . 0)
         (push.cons)
         (apply.iloc+ (3 . 0) "./boot/common.scm" . 131094))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of put-char 2 "./boot/common.scm" . 133142)
       (push.iloc 4 . 0)
       (push.subr.gloc.of get-char 1 "./boot/common.scm" . 134173)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 134166))
     (push.iloc 3 . 0)
     (push.subr.gloc.of get-char 1 "./boot/common.scm" . 123932)
     (apply.iloc+ (0 . 0) "./boot/common.scm" . 123917))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 122891))
 (set.gloc.of |split->list`2|)
 (close
   (2 0 . string-split)
   (push.iloc.0 . 1)
   (subr.gloc.of char? 1 "./boot/common.scm" . 136204)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of char=? "./boot/common.scm" . 137257))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 137228))
   (push.iloc.0 . 1)
   (subr.gloc.of string? 1 "./boot/common.scm" . 138252)
   (if.true
     (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/common.scm" . 139287))
     (push)
     (extend . 1)
     (touch.gloc.of |split->list`2|)
     (push.iloc.1 . 0)
     (push.close
       (1 0)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of char=? "./boot/common.scm" . 140349))
       (push.iloc.1 . 0)
       (apply.gloc.of any1 "./boot/common.scm" . 140331))
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 140302))
   (push.iloc.0 . 1)
   (subr.gloc.of procedure? 1 "./boot/common.scm" . 141324)
   (if.true
     (touch.gloc.of |split->list`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |split->list`2| "./boot/common.scm" . 142348))
   (ret.const.unspec))
 (set.gloc.of string-split)
 (ret.const.unspec))
((close
   (2 1 . wrong-type-argument-message)
   (iloc.0 . 2)
   (if.null?
     (push.const . "expected ~a, but got ~a")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of format "./boot/common.scm" . 147465))
   (push.const . "expected ~a, but got ~a, as argument ~a")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.car.iloc (0 . 2) "./boot/common.scm" . 148550)
   (ret.subr.gloc.of format "./boot/common.scm" . 148489))
 (set.gloc.of wrong-type-argument-message)
 (ret.const.unspec))

;
((close
   (1 1 . make-parameter)
   (call
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of parameter-proc-0)
       (subr.gloc.of gensym 0)
       (push)
       (apply.gloc.of parameter-proc-0 "./boot/parameter.scm" . 8218))
     (touch.gloc.of parameter-proc-1)
     (subr.gloc.of gensym 0)
     (push)
     (push.car.iloc (0 . 1) "./boot/parameter.scm" . 9269)
     (apply.gloc.of parameter-proc-1 "./boot/parameter.scm" . 9242))
   (push)
   (extend . 1)
   (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/parameter.scm" . 10254))
   (ret.iloc 0 . 0))
 (set.gloc.of make-parameter)
 (ret.const.unspec))
((close
   (1 0 . parameter-proc-0)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 16395))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (0 . 0) "./boot/parameter.scm" . 17474)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 17419)))
 (set.gloc.of parameter-proc-0)
 (ret.const.unspec))
((close
   (2 0 . parameter-proc-1)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 23563))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (call
       (push.car.iloc (0 . 0) "./boot/parameter.scm" . 24648)
       (apply.iloc (1 . 1) "./boot/parameter.scm" . 24642))
     (push)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 24587)))
 (set.gloc.of parameter-proc-1)
 (ret.const.unspec))

;
((call (push.const . "") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 5152))
 (set.gloc.of current-library-prefix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 6175))
 (set.gloc.of current-library-infix)
 (ret.const.unspec))
((call (push.const . "'") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 7200))
 (set.gloc.of current-library-suffix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 8226))
 (set.gloc.of current-primitive-prefix)
 (ret.const.unspec))
((call (push.const . "`") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 9250))
 (set.gloc.of current-rename-delimiter)
 (ret.const.unspec))
((call (push.const . 5) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 10269))
 (set.gloc.of expansion-backtrace)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 11295))
 (set.gloc.of expansion-trace-stack)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 12319))
 (set.gloc.of expansion-trace-level)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 13351))
 (set.gloc.of current-immutable-identifiers)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 14368))
 (set.gloc.of current-expansion-mode)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 15399))
 (set.gloc.of current-expansion-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 16418))
 (set.gloc.of current-macro-expression)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 17449))
 (set.gloc.of current-transformer-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 18465))
 (set.gloc.of unexpect-top-level-form)
 (ret.const.unspec))
((close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call (push.gloc.of |.fn1.1`1|) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 19494))
 (set.gloc.of current-after-expansion-hook)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 20513))
 (set.gloc.of current-temporary-count)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 21534))
 (set.gloc.of current-rename-count)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 22562))
 (set.gloc.of current-closure-comments)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 23588))
 (set.gloc.of current-top-level-exterior)
 (ret.const.unspec))
((close
   (4 0)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/initial.scm" . 27658)
     (if.false.ret)
     (push.iloc.0 . 1)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 28682))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (const . syntax)
     (if.eq?
       (touch.gloc.of make-macro)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of make-macro "./boot/macro/initial.scm" . 33821))
     (push.iloc.0 . 0)
     (const . variable)
     (if.eq?
       (push.iloc.0 . 2)
       (subr.gloc.of procedure? 1 "./boot/macro/initial.scm" . 35876)
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 36900))
       (call
         (touch.gloc.of variable-transformer-token?)
         (push.iloc.0 . 2)
         (apply.gloc.of variable-transformer-token? "./boot/macro/initial.scm" . 37924))
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/initial.scm" . 38969)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 38948))
       (push.const
         .
         "internal error in .set-top-level-macro!: bad transformer type:~s keyword:~s datum:~s")
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 40996))
     (ret.const.unspec))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 26627))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.set-top-level-macro!|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 26627))
((close
   (1 0 . core-primitive-name)
   (push.const . "~a~a")
   (call
     (touch.gloc.of current-primitive-prefix)
     (apply.gloc.of current-primitive-prefix "./boot/macro/initial.scm" . 45092))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 3 "./boot/macro/initial.scm" . 45077)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 45061))
 (set.gloc.of core-primitive-name)
 (ret.const.unspec))
((close
   (2 0 . generate-global-id)
   (push.const . "~a~a~a~a")
   (call
     (touch.gloc.of current-library-prefix)
     (apply.gloc.of current-library-prefix "./boot/macro/initial.scm" . 49192))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-library-suffix)
     (apply.gloc.of current-library-suffix "./boot/macro/initial.scm" . 49228))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 49173)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 49157))
 (set.gloc.of generate-global-id)
 (ret.const.unspec))
((close
   (0 0 . generate-temporary-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 53266))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 54304)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 54279))
   (push.const . ".L~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/initial.scm" . 55319)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 55303))
 (set.gloc.of generate-temporary-symbol)
 (ret.const.unspec))
((close
   (1 0 . generate-local-macro-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 59410))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 60448)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 60423))
   (push.const . ".local-macro-~a.~a~a~a")
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 61505))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 61532))
   (push)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 61463)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 61447))
 (set.gloc.of generate-local-macro-symbol)
 (ret.const.unspec))
((close
   (0 0 . fresh-rename-count)
   (call
     (touch.gloc.of current-rename-count)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65566))
     (push)
     (push.const . 1)
     (push.subr.gloc.of + 2 "./boot/macro/initial.scm" . 65563)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65541))
   (touch.gloc.of current-rename-count)
   (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 66565))
 (set.gloc.of fresh-rename-count)
 (ret.const.unspec))
((close
   (2 0 . rename-id)
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 70697))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 70677)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 70661))
 (set.gloc.of rename-id)
 (ret.const.unspec))
((close
   (1 0 . renamed-id?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of symbol-contains)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 75806))
   (push)
   (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 75786))
 (set.gloc.of renamed-id?)
 (ret.const.unspec))
((close
   (1 0 . original-id)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 79904))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 79884))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 80953)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of substring 3 "./boot/macro/initial.scm" . 80942)
     (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 80926))
   (ret.iloc 1 . 0))
 (set.gloc.of original-id)
 (ret.const.unspec))
((close
   (1 0 . strip-rename-suffix)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 87082)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 87061))
     (push)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 88106)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 88085))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/initial.scm" . 89121)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/initial.scm" . 89139)
       (ret.eq? "./boot/macro/initial.scm" . 89132))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/initial.scm" . 90138))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of original-id)
     (push.iloc.0 . 0)
     (apply.gloc.of original-id "./boot/macro/initial.scm" . 91162))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/initial.scm" . 92172)
   (if.true
     (call
       (push.gloc.of strip-rename-suffix)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/initial.scm" . 92225)
       (apply.gloc.of map "./boot/macro/initial.scm" . 92200))
     (push)
     (apply.gloc.of list->vector "./boot/macro/initial.scm" . 92186))
   (ret.iloc 0 . 0))
 (set.gloc.of strip-rename-suffix)
 (ret.const.unspec))
((close
   (1 0 . retrieve-rename-suffix)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 97312))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 97292))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 99357)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/macro/initial.scm" . 100392)
     (ret.subr.gloc.of substring "./boot/macro/initial.scm" . 100371))
   (ret.const . ""))
 (set.gloc.of retrieve-rename-suffix)
 (ret.const.unspec))
((close
   (2 0 . set-closure-comment!)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 105482))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 106527))
   (push)
   (push.iloc.0 . 0)
   (push.const . heap)
   (iloc.0 . 1)
   (push.cons)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 106506))
 (set.gloc.of set-closure-comment!)
 (ret.const.unspec))
((close
   (2 1 . annotate-closure)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 110602))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 111653))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 111633)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.1 . 2)
     (if.null?
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 114735))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 114714))
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 115759))
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (1 . 2) "./boot/macro/initial.scm" . 115797)
     (cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 115808)
     (push.cons)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 115738))
   (ret.const.unspec))
 (set.gloc.of annotate-closure)
 (ret.const.unspec))
((close
   (1 0 . annotated?)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 119818)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 120842)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of annotated?)
 (ret.const.unspec))
((close
   (1 0 . get-annotation)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 126986)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 128010))
 (set.gloc.of get-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-annotation)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 133130)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 134154))
   (ret.iloc 0 . 0))
 (set.gloc.of put-annotation)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 154644)
   (if.true.ret)
   (call
     (touch.gloc.of |loop`15|)
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 155674)
     (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 155668))
   (if.true.ret)
   (touch.gloc.of |loop`15|)
   (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 156698)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 156692))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . put-note!)
   (iloc.0 . 1)
   (if.false.ret)
   (extend.enclose
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/initial.scm" . 144405)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 145433)
     (if.true.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (subr.gloc.of core-hashtable-set! 3 "./boot/macro/initial.scm" . 147483)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/macro/initial.scm" . 148507))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/initial.scm" . 143374))
 (set.gloc.of |put-note!`2|)
 (close
   (1 0 . get-note)
   (touch.gloc.of |loop`15|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`15| "./boot/macro/initial.scm" . 152585))
 (set.gloc.of |get-note`2|)
 (close
   (2 0 . annotate)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #f)
     (call
       (call
         (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 162840)
         (if.false.ret)
         (touch.gloc.of |get-note`2|)
         (push.iloc.0 . 1)
         (apply.gloc.of |get-note`2| "./boot/macro/initial.scm" . 162866))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of |put-note!`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |put-note!`2| "./boot/macro/initial.scm" . 163874))
       (ret.const.unspec))
     (call
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164888))
       (if.false.ret)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164935))
       (push)
       (push.iloc.0 . 1)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 164915))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 165943))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 165922))
     (ret.const.unspec))
   (ret.iloc 0 . 0))
 (set.gloc.of annotate)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 174095)
     (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 174104))
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 175130)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 175146)
       (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 175156)
       (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 175140))
     (ret.cons "./boot/macro/initial.scm" . 175124))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . abbreviated-take)
   (touch.gloc.of annotate)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/initial.scm" . 172038))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 172038))
 (set.gloc.of abbreviated-take)
 (ret.const.unspec))
((close
   (3 0 . abbreviated-take-form)
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 183315)
           (if.true.ret)
           (push.iloc.0 . 2)
           (push.const . 0)
           (ret.subr.gloc.of <= "./boot/macro/initial.scm" . 183325))
         (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 183336))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 184352)
           (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 184362)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184346))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 184381)
           (push.iloc 2 . 1)
           (push.n+.iloc (0 . 2) -1 "./boot/macro/initial.scm" . 184396)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184375))
         (ret.cons "./boot/macro/initial.scm" . 184340))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.iloc+ (0 . 0) "./boot/macro/initial.scm" . 181254))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 179203))
 (set.gloc.of abbreviated-take-form)
 (ret.const.unspec))

;
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 9234)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 9259)
       (apply.gloc.of formals->list "./boot/macro/expand.scm" . 9244))
     (ret.cons "./boot/macro/expand.scm" . 9228))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/macro/expand.scm" . 11276))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . collect-lambda-formals)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/macro/expand.scm" . 15377))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/expand.scm" . 16395))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 17437)
     (push.const . "malformed formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 17419))
   (call
     (call
       (touch.gloc.of unique-id-list?)
       (push.iloc.0 . 0)
       (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 18443))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 19485)
     (push.const . "duplicate formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 19467))
   (ret.iloc 0 . 0))
 (set.gloc.of collect-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . rename-lambda-formals)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 26653)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 26647)
     (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 26642)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 27689)
       (push.iloc.0 . 1)
       (apply.gloc.of rename-lambda-formals "./boot/macro/expand.scm" . 27666))
     (ret.cons "./boot/macro/expand.scm" . 26636))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 29713)
   (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 29708))
 (set.gloc.of rename-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . check-let*-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 33801)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 34843)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 34825))
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.0 . 0)
         (apply.gloc.of safe-length "./boot/macro/expand.scm" . 36893))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/expand.scm" . 36890)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 36927)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 36918))
     (if.true.ret)
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 37927)
     (push.const . "expected each binding consist of symbol and expression")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 37909))
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/expand.scm" . 35845))
 (set.gloc.of check-let*-bindings)
 (ret.const.unspec))
((close
   (2 0 . check-let-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 43017)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 44059)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 44041))
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.close
         (1 0)
         (call
           (call
             (touch.gloc.of safe-length)
             (push.iloc.0 . 0)
             (apply.gloc.of safe-length "./boot/macro/expand.scm" . 47133))
           (push)
           (push.const . 2)
           (subr.gloc.of = 2 "./boot/macro/expand.scm" . 47130)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 47167)
           (if.not.symbol?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 47182))
         (if.true.ret)
         (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 48167)
         (push.const . "expected each binding consist of symbol and expression")
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 48149))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 46090))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 45065))
   (if.true.ret)
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 50203)
   (push.const . "duplicate bindings")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 50185))
 (set.gloc.of check-let-bindings)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 57353))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 69642))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 56327))
 (set.gloc.of |collect-ids`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 59416)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 60446)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 60440))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 59410))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 62489)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 63518))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 72738)
     (push.const . quote)
     (push.subr.gloc.of eq? 2 "./boot/macro/expand.scm" . 72733)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 72728))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 73747))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . check-internal-def-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 76816))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 77855)
     (if.false.ret)
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 77831))
 (set.gloc.of check-internal-def-contract-violation)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 85001))
 (set.gloc.of |filter-unique-ids`2|)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of |filter-unique-ids`2|)
   (call
     (touch.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`15| "./boot/macro/expand.scm" . 97290))
   (push)
   (apply.gloc.of |filter-unique-ids`2| "./boot/macro/expand.scm" . 83975))
 (set.gloc.of |collect-ids`2|)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 87064)
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 88094)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 88088))
     (push)
     (apply.gloc.of |loop`7| "./boot/macro/expand.scm" . 87058))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 90137)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 91166))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 100387)
     (push.const lambda quote)
     (push.subr.gloc.of memq 2 "./boot/macro/expand.scm" . 100381)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 100376))
   (if.true
     (push.gloc.of |loop`15|)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 101395))
   (ret.const))
 (set.gloc.of |loop`15|)
 (close
   (2 0 . check-rec-contract-violation)
   (call
     (touch.gloc.of |collect-ids`2|)
     (push.iloc.0 . 1)
     (apply.gloc.of |collect-ids`2| "./boot/macro/expand.scm" . 104464))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of memq "./boot/macro/expand.scm" . 105498))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 105479))
 (set.gloc.of check-rec-contract-violation)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of check-rec-contract-violation)
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 111667)
     (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 111632))
   (if.true.ret)
   (touch.gloc.of |loop`5|)
   (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 112662)
   (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 112673)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 112656))
 (set.gloc.of |loop`5|)
 (close
   (2 0 . check-rec*-contract-violation)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |loop`5| "./boot/macro/expand.scm" . 109573))
 (set.gloc.of check-rec*-contract-violation)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/expand.scm" . 124935))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . rewrite-letrec*-bindings)
   (push.close
     (0 0)
     (touch.gloc.of partition)
     (push.close
       (1 0)
       (cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 118835)
       (if.not.pair?.ret.const . #t)
       (call
         (touch.gloc.of denote-quote?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 119866)
         (apply.gloc.of denote-quote? "./boot/macro/expand.scm" . 119847))
       (if.true.ret)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 120891)
         (apply.gloc.of denote-lambda? "./boot/macro/expand.scm" . 120871))
       (if.true
         (call
           (touch.gloc.of set-closure-comment!)
           (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 121924)
           (call
             (touch.gloc.of original-id)
             (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 121952)
             (apply.gloc.of original-id "./boot/macro/expand.scm" . 121939))
           (push)
           (apply.gloc.of set-closure-comment! "./boot/macro/expand.scm" . 121902))
         (ret.const . #t))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (apply.gloc.of partition "./boot/macro/expand.scm" . 116741))
   (push.gloc.of |.fn2.1`2|)
   (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 115715))
 (set.gloc.of rewrite-letrec*-bindings)
 (ret.const.unspec))
((close
   (2 0 . flatten-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 132117)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 133141)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 133134)
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 134177)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 134158))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 139279))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 140309)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 141339)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 141333))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 140303))
       (iloc.0 . 1)
       (if.null? (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of append "./boot/macro/expand.scm" . 145430))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 137222))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 130053))
 (set.gloc.of flatten-begin)
 (ret.const.unspec))
((close
   (2 0 . flatten-top-level-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 153621)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 154645)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 154638)
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 155681)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 155662))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 160783))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 161813)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 162843)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 162837))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 161807))
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 164885)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 165915)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 165909))
       (ret.cons "./boot/macro/expand.scm" . 164879))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 158726))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 151557))
 (set.gloc.of flatten-top-level-begin)
 (ret.const.unspec))
((close
   (3 0 . compile-macro)
   (extend.unbound . 2)
   (push.close+
     (2 0 . compile-transformer)
     (push.const . |.transformer-thunk|)
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (call
             (touch.gloc.of make-out-of-context)
             (push.const . #f)
             (apply.gloc.of make-out-of-context "./boot/macro/expand.scm" . 175159))
           (push)
           (extend . 2)
           (call
             (push.close
               (1 0)
               (car.iloc (0 . 0) "./boot/macro/expand.scm" . 177196)
               (if.not.symbol?.ret.const . #f)
               (call
                 (touch.gloc.of renamed-id?)
                 (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 178224)
                 (apply.gloc.of renamed-id? "./boot/macro/expand.scm" . 178211))
               (if.false.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 179262)
               (push.const . #f)
               (subr.gloc.of core-hashtable-ref 3 "./boot/macro/expand.scm" . 179239)
               (if.true.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 180287)
               (push.iloc.1 . 1)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/expand.scm" . 180263))
             (push.iloc.1 . 1)
             (apply.gloc.of for-each "./boot/macro/expand.scm" . 176146))
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable->alist "./boot/macro/expand.scm" . 182290))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 183366))
       (push)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 183341))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 183313)
     (extend . 1)
     (call
       (touch.gloc.of interpret-coreform)
       (push.iloc.0 . 0)
       (apply.gloc.of interpret-coreform "./boot/macro/expand.scm" . 184345))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 185366)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 185384))
     (call
       (touch.gloc.of variable-transformer-token?)
       (push.iloc.0 . 0)
       (apply.gloc.of variable-transformer-token? "./boot/macro/expand.scm" . 186390))
     (if.true
       (call
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/expand.scm" . 187443)
         (push.iloc 2 . 1)
         (apply.gloc.of make-macro-variable "./boot/macro/expand.scm" . 187422))
       (push)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 187414))
     (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 189480)
     (push.const . "invalid transformer expression")
     (push.iloc 4 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 189462))
   (push.close
     (1 0 . syntax-rules?)
     (touch.gloc.of denote-syntax-rules?)
     (push.iloc 2 . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-syntax-rules? "./boot/macro/expand.scm" . 193545))
   (enclose . 2)
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (if.not.null?.ret.const . #f)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 172037))
   (if.true
     (push.const . syntax-rules)
     (push.const . "expected literals and rules")
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 172037)
     (if.false.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 172037))
   (if.true
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (push.cadr.iloc (1 . 1) "./boot/macro/expand.scm" . 172037)
     (extend . 2)
     (call
       (call
         (push.iloc.0 . 1)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 172037)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 1)
         (apply.gloc.of every1 "./boot/macro/expand.scm" . 172037))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "invalid literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 1)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 172037))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "duplicate literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
     (call
       (push.const . _)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 172037)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "_ in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
     (call
       (push.const . ...)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 172037)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "... in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 172037)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 172037)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 172037)
           (ret.null? "./boot/macro/expand.scm" . 172037))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/expand.scm" . 172037)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 172037))
         (if.true.ret.const . #t)
         (iloc.0 . 0)
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected identifer for first subform of pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 172037)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 172037)
           (ret.null? "./boot/macro/expand.scm" . 172037))
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected list for pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
         (push.const . syntax-rules)
         (push.const . "expected (pattern template) for each rule")
         (push.iloc 4 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 172037))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/expand.scm" . 172037))
     (touch.gloc.of compile-syntax-rules)
     (push.iloc 2 . 1)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 2 . 2)
     (apply.gloc.of compile-syntax-rules "./boot/macro/expand.scm" . 172037))
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 172037))
 (set.gloc.of compile-macro)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 233527))
   (ret.cons "./boot/macro/expand.scm" . 233515))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . expand-let-syntax-bindings)
   (call
     (push.gloc.of car)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 225297))
   (push)
   (extend . 1)
   (touch.gloc.of extend-env)
   (call
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 229430))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 230438))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 231467))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 228379))
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 226322))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 228360))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 233490))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 234514))
     (push)
     (ret.subr.gloc.of append "./boot/macro/expand.scm" . 233482))
   (push)
   (push.iloc.1 . 2)
   (apply.gloc.of extend-env "./boot/macro/expand.scm" . 225285))
 (set.gloc.of expand-let-syntax-bindings)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 248914))
   (ret.cons "./boot/macro/expand.scm" . 248894))
 (set.gloc.of |.fn2.1`2|)
 (close
   (3 0 . expand-letrec-syntax-bindings)
   (extend.enclose
     (1 0 . undefined-macro)
     (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 242715)
     (push.const . "attempt to reference uninitialized syntactic keyword")
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 242697))
   (call
     (push.gloc.of car)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 244753))
   (push)
   (call
     (push.gloc.of cadr)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 245778))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of make-macro)
       (push.iloc 2 . 0)
       (push.const)
       (apply.gloc.of make-macro "./boot/macro/expand.scm" . 246833))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 246813))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of |.fn2.1`2|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 248861))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 249885))
     (push)
     (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 248853)
     (push.iloc 3 . 2)
     (apply.gloc.of extend-env "./boot/macro/expand.scm" . 247828))
   (push)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 257077))
       (push)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 257098)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 257067))
     (push.iloc 2 . 0)
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 6 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 252985))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 253993))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 255022))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 251934))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 251915))
     (push)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 257037))
   (ret.iloc 0 . 0))
 (set.gloc.of expand-letrec-syntax-bindings)
 (ret.const.unspec))
((close
   (3 0 . expand-macro-use)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 263173))
   (call
     (touch.gloc.of current-macro-expression)
     (push.iloc.0 . 0)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 264197))
   (push.const . #f)
   (push.const . #f)
   (push.cddr.iloc (0 . 2) "./boot/macro/expand.scm" . 265305)
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 266247))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-transformer-environment)
       (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 266247))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 266247))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 2)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 266247))
   (push.close
     (0 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 266263)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 266251)
     (if.true (push.iloc 2 . 0) (cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 267276) (apply))
     (touch.gloc.of transcribe-syntax-rules)
     (push.iloc 2 . 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 268329)
     (apply.gloc.of transcribe-syntax-rules "./boot/macro/expand.scm" . 268299))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc.1 . 0)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 266247))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 1)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 266247))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 266247))
 (set.gloc.of expand-macro-use)
 (ret.const.unspec))
((close
   (2 0 . rewrite-form)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 288791)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 288784))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 290832)
   (if.true
     (touch.gloc.of annotate)
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 291866))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 291856))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/expand.scm" . 292880)
   (if.true
     (call
       (touch.gloc.of |rewrite-form-each`2|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/expand.scm" . 293937)
       (push.iloc.0 . 1)
       (apply.gloc.of |rewrite-form-each`2| "./boot/macro/expand.scm" . 293918))
     (push)
     (apply.gloc.of list->vector "./boot/macro/expand.scm" . 293904))
   (ret.iloc 0 . 0))
 (set.gloc.of |rewrite-form`2|)
 (close
   (2 0 . rewrite-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 299017)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 299017)
     (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 299017))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 299017)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 299017)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 299017))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 299017))
     (push)
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 299017))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 299017))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/expand.scm" . 299017))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 299017))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of list)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 299017))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/expand.scm" . 299017))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of cons)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/expand.scm" . 299017))
       (push)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 299017))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 299017))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 299017)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 299017))
 (set.gloc.of |rewrite-let-syntax`2|)
 (close
   (2 0 . rewrite-form-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 278570)
       (push.iloc 2 . 1)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 278556))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 279586)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 279580))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/expand.scm" . 280613)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 280632)
       (ret.eq? "./boot/macro/expand.scm" . 280624))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 282648))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 275465))
 (set.gloc.of |rewrite-form-each`2|)
 (close
   (2 0 . rewrite-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
     (subr.gloc.of |.list?| 1 "./boot/macro/expand.scm" . 314377)
     (if.false.ret)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 314377))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 314377))
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 314377))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 314377))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 314377))
         (ret.cons "./boot/macro/expand.scm" . 314377))
       (call
         (push.gloc.of car)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 314377))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 314377))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (touch.gloc.of |rewrite-form`2|)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 314377))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/expand.scm" . 314377))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of |rewrite-form`2|)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |rewrite-form`2| "./boot/macro/expand.scm" . 314377))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 314377))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 314377)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 314377))
 (set.gloc.of |rewrite-letrec-syntax`2|)
 (close
   (2 0 . expand-initial-forms)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 326695)
     (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 326686))
   (if.true
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 327720)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 327704))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (gloc.of denote-let-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-let-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-let-syntax`2| "./boot/macro/expand.scm" . 329749))
     (push.iloc.0 . 0)
     (gloc.of denote-letrec-syntax)
     (if.eq?
       (touch.gloc.of |rewrite-letrec-syntax`2|)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of |rewrite-letrec-syntax`2| "./boot/macro/expand.scm" . 331797))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 332821))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 333874))
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 334884))
         (push)
         (ret.subr.gloc.of values "./boot/macro/expand.scm" . 334871))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 327692))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 336917))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of values "./boot/macro/expand.scm" . 338956))
 (set.gloc.of expand-initial-forms)
 (ret.const.unspec))
((close
   (3 0 . expand-body)
   (extend.unbound . 6)
   (push.const)
   (push.const)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 350239)
       (push.iloc 2 . 2)
       (apply.gloc.of extend-env "./boot/macro/expand.scm" . 350227))
     (set.iloc 2 . 2)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 351246))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/expand.scm" . 353313))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 1)
         (call
           (touch.gloc.of generate-local-macro-symbol)
           (push.iloc.0 . 0)
           (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 354361))
         (push.cons)
         (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 354342)
         (push.iloc 2 . 2)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 354330))
       (set.iloc 2 . 2)
       (ret.const.unspec))
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 355369)
       (push.iloc 3 . 2)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 355359))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 355337))
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 360469)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/expand.scm" . 361495)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 362538)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 362522))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 363540))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/expand.scm" . 367636))
   (push.close
     (3 0 . rewrite-body)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of annotate)
       (call
         (touch.gloc.of expand-each)
         (push.iloc.0 . 0)
         (push.iloc 2 . 2)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 373786))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of annotate "./boot/macro/expand.scm" . 373776))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 375845))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 375828))
       (if.true.ret)
       (call
         (touch.gloc.of find-duplicates)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 376879))
         (push)
         (apply.gloc.of find-duplicates "./boot/macro/expand.scm" . 376862))
       (push)
       (extend . 1)
       (push.const . define)
       (push.const . "duplicate definitions")
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 379953)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 379970))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 380986)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 380977)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 381004))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 377878))
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 382009)
         (push.iloc.1 . 2)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 382003)
         (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 381998))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 381979))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 383035)
         (push.iloc 3 . 2)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 383022))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 383003))
     (push)
     (extend . 2)
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/expand.scm" . 384025))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 386116)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 386124)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 386135))
         (push.iloc 2 . 2)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 386088))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 387104))
       (push.const . define)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 389170)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 391261)
             (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 391271)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 391231))
           (if.false.ret)
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 392255))
         (push.iloc 3 . 1)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 390194))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 388128))
     (call
       (touch.gloc.of check-internal-def-contract-violation)
       (call
         (push.gloc.of car)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 394304))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of check-internal-def-contract-violation "./boot/macro/expand.scm" . 394265))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 396318))
       (push.const . define)
       (push.const
         .
         "identifier ~u already used to determine the meaning of undeferred portions of definition")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 398384)
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 399415)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 399445))
         (ret.const . #f))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 384018))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 403520))
       (push)
       (push.iloc 5 . 2)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/expand.scm" . 403494))
     (push)
     (call
       (touch.gloc.of expand-each)
       (push.iloc 3 . 0)
       (push.iloc 5 . 2)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 403546))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/expand.scm" . 402457)
     (push.subr.gloc.of |.list| 1 "./boot/macro/expand.scm" . 402457)
     (push.iloc 5 . 1)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 402457))
   (enclose . 6)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 406547))
   (push)
   (extend . 1)
   (extend.enclose
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (car.iloc (0 . 0) "./boot/macro/expand.scm" . 409628)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 409649)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 409640))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 410664)
       (push.iloc 3 . 2)
       (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 410658)
       (set.iloc 3 . 2)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 4 . 2)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 411692)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 411676))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 413727))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 413721))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 415769)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/expand.scm" . 415769)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/expand.scm" . 415769)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/expand.scm" . 415769)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 415769)
           (ret.subr.gloc.of |.list?| "./boot/macro/expand.scm" . 415769))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 415769)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 415769))
         (if.true
           (push.cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 415769)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/expand.scm" . 415769)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/expand.scm" . 415769)
           (extend . 3)
           (call
             (push.close
               (0 0)
               (touch.gloc.of compile-macro)
               (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 415769)
               (push.iloc.1 . 1)
               (push.iloc 8 . 2)
               (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 415769))
             (push.close
               (1 1)
               (call
                 (iloc.0 . 1)
                 (if.not.pair?.ret.const . #f)
                 (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 415769)
                 (push.iloc 7 . 1)
                 (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 415769)
                 (set.iloc 7 . 1)
                 (ret.const.unspec))
               (call
                 (touch.gloc.of macro-variable?)
                 (push.iloc.0 . 0)
                 (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 415769))
               (if.true
                 (push.iloc.1 . 2)
                 (push.iloc.0 . 0)
                 (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 415769))
               (push.iloc.1 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.0 . 0)
                 (push.iloc 8 . 2)
                 (apply.gloc.of make-macro "./boot/macro/expand.scm" . 415769))
               (push)
               (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 415769))
             (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 415769))
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (call
             (touch.gloc.of acons)
             (push.iloc.0 . 2)
             (push.const . #f)
             (push.iloc 3 . 2)
             (apply.gloc.of acons "./boot/macro/expand.scm" . 415769))
           (push)
           (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 415769))
         (iloc.0 . 0)
         (if.true
           (push.iloc 2 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 415769)
           (push.const . "expected symbol for first clause")
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 415769)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 415769))
         (push.iloc 2 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 415769)
         (push.const . "expected symbol and transformer expression")
         (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 415769)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 415769))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 431171)
             (apply.gloc.of desugar-define "./boot/macro/expand.scm" . 431155))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 431150)
           (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 431184)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 431140))
         (push)
         (extend . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 432166)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 432193)
           (push.iloc 4 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 432182))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 2)
           (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 433188)
           (if.true
             (call
               (touch.gloc.of current-macro-expression)
               (push.iloc 7 . 0)
               (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 435241))
             (push.const . define)
             (push.const
               .
               "identifier ~u already used to determine the meaning of undeferred portions of definition")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 437307)
             (push.car.iloc (3 . 0) "./boot/macro/expand.scm" . 438331)
             (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 436265))
           (ret.const.unspec))
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (6 . 3) "./boot/macro/expand.scm" . 439325))
         (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 440355)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of acons "./boot/macro/expand.scm" . 440382))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 440349))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/expand.scm" . 441373))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/expand.scm" . 443421))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 444488)
           (push.iloc 6 . 2)
           (apply.gloc.of expand-initial-forms "./boot/macro/expand.scm" . 444466))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 6 . 2)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 446523)
             (push.iloc 6 . 2)
             (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 446508))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 448554)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 448548))
           (call (push.iloc.0 . 0) (apply.iloc (6 . 4) "./boot/macro/expand.scm" . 449572))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 450620)
             (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 450602)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 450596))
           (push.iloc.0 . 0)
           (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 452676)
           (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 452658)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 452688)
           (push.iloc 3 . 2)
           (apply.iloc (6 . 5) "./boot/macro/expand.scm" . 452644))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 411664))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 454700)
       (push.iloc.1 . 2)
       (apply.iloc (4 . 5) "./boot/macro/expand.scm" . 454681))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 456739)
     (push.iloc.0 . 2)
     (apply.iloc (3 . 5) "./boot/macro/expand.scm" . 456720))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 407576))
   (push)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 407559))
 (set.gloc.of expand-body)
 (ret.const.unspec))
((close
   (2 0 . expand-each)
   (call
     (touch.gloc.of current-macro-expression)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 460817))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (call
     (push.close
       (1 0)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc.1 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 462872))
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 463896))
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 461841))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 461831))
 (set.gloc.of expand-each)
 (ret.const.unspec))
((close
   (2 0 . expand-form)
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 471064))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.symbol? (ret.iloc 0 . 0))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 473109))
     (if.true
       (push.close
         (0 0)
         (call
           (touch.gloc.of expansion-trace-level)
           (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 475178))
         (push)
         (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 475202))
         (push)
         (subr.gloc.of < 2 "./boot/macro/expand.scm" . 475175)
         (if.true
           (push.const . #f)
           (push.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 476243))
           (push)
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 476270))
           (push.cons)
           (push.const . 1)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 477266))
           (push)
           (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 477261)
           (extend . 4)
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 478249))
             (set.iloc 1 . 0)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 478249))
             (set.iloc 1 . 1)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 2)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 478249))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 3)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 478249))
           (push.close
             (0 0)
             (touch.gloc.of expand-macro-use)
             (push.iloc 4 . 0)
             (push.iloc 4 . 1)
             (push.iloc 3 . 0)
             (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 478249))
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 0)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 478249))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 1)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 478249))
           (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 478249))
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 479271))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 480297))
         (push)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 480279))
       (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 471052))
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/expand.scm" . 481301))
     (if.true
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound identifier ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 483377)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 484401))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/expand.scm" . 482325))
     (call
       (touch.gloc.of out-of-context?)
       (push.iloc.0 . 0)
       (apply.gloc.of out-of-context? "./boot/macro/expand.scm" . 485397))
     (if.true
       (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 486425)
       (if.true
         (push.const . #f)
         (push.const . "identifer ~u out of context")
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 488491)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 489515))
         (push)
         (call
           (touch.gloc.of annotate)
           (push.const . syntax)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 490563)
           (push.subr.gloc.of list 2 "./boot/macro/expand.scm" . 490549)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 490575)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 490539))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 487449))
       (push.const . #f)
       (push.const . "identifer ~u out of context")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 492587)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 493611))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 491545))
     (call
       (touch.gloc.of special?)
       (push.iloc.0 . 0)
       (apply.gloc.of special? "./boot/macro/expand.scm" . 494613))
     (if.true
       (push.const . #f)
       (push.const . "misplaced syntactic keyword ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 495658)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 495705))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 495637))
     (call
       (touch.gloc.of pattern-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of pattern-variable? "./boot/macro/expand.scm" . 496661))
     (if.true
       (push.const . #f)
       (push.const . "misplaced pattern variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 497706)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 497752))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 497685))
     (ret.iloc 1 . 0))
   (iloc.0 . 0)
   (if.null?
     (push.const . #f)
     (push.const . "invalid expression")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 500748))
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.0 . 0)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 502796))
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 503836)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.0 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 504879)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 504863))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 505884))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-macro-use)
           (push.iloc 2 . 0)
           (push.iloc 2 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 506937))
         (push.close
           (2 0)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 507941))
           (push)
           (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 507965))
           (push)
           (subr.gloc.of < 2 "./boot/macro/expand.scm" . 507938)
           (if.true
             (push.const . #f)
             (push.const . #f)
             (push.iloc 2 . 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 509011))
             (push.cons)
             (push.const . 1)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 510029))
             (push)
             (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 510024)
             (extend . 4)
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 511012))
               (set.iloc 1 . 0)
               (call
                 (touch.gloc.of expansion-trace-level)
                 (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 511012))
               (set.iloc 1 . 1)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 2)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 511012))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 3)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 511012))
             (push.close
               (0 0)
               (touch.gloc.of expand-form)
               (push.iloc 2 . 0)
               (call
                 (touch.gloc.of extend-env)
                 (push.iloc 2 . 1)
                 (push.iloc 4 . 1)
                 (apply.gloc.of extend-env "./boot/macro/expand.scm" . 511030))
               (push)
               (apply.gloc.of expand-form "./boot/macro/expand.scm" . 511012))
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 0)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 511012))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 1)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 511012))
             (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 511012))
           (touch.gloc.of expand-form)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of extend-env)
             (push.iloc.0 . 1)
             (push.iloc 2 . 1)
             (apply.gloc.of extend-env "./boot/macro/expand.scm" . 512052))
           (push)
           (apply.gloc.of expand-form "./boot/macro/expand.scm" . 512034))
         (apply.gloc.of |.call-with-values| "./boot/macro/expand.scm" . 504851))
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/expand.scm" . 513052))
       (if.true
         (call
           (push.iloc.1 . 0)
           (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 514080)
           (if.true.ret)
           (push.const . #f)
           (push.const . "expression is not a proper list")
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 514093))
         (call
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 515108))
           (if.true.ret)
           (push.gloc.of denote-begin)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-import)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-macro)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-let-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-letrec-syntax)
           (iloc.0 . 0)
           (ret.eq? "./boot/macro/expand.scm" . 522276))
         (if.true
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 523297)
           (apply))
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 525346))
           (set.iloc 1 . 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.const . #t)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 525346))
         (push.close
           (0 0)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 525347)
           (apply))
         (push.close
           (0 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.iloc.1 . 0)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 525346))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 525346))
       (call
         (push.iloc.1 . 0)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 527392)
         (if.true.ret)
         (push.const . #f)
         (push.const . "expression is not a proper list")
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 527405))
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 528416))
       (if.true
         (touch.gloc.of expand-each)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 529440))
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
       (push.close
         (0 0)
         (touch.gloc.of expand-each)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 531490))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 531490))
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 533527)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 533540))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 534551))
     (if.true
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 535575))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537625))
       (set.iloc 1 . 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #t)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537625))
     (push.close
       (0 0)
       (touch.gloc.of expand-each)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 537625))
     (push.close
       (0 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 0)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537625))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 537625))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/expand.scm" . 538640)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/expand.scm" . 538656)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/expand.scm" . 538671)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/expand.scm" . 538684)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of bytevector? "./boot/macro/expand.scm" . 538699))
   (if.true (ret.iloc 0 . 0))
   (push.const . #f)
   (push.const . "invalid expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 540684))
 (set.gloc.of expand-form)
 (ret.const.unspec))
((close
   (1 1 . macro-expand)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (extend . 8)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-macro-expression)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 2)
     (call
       (touch.gloc.of current-expansion-mode)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 3)
     (call
       (touch.gloc.of current-top-level-exterior)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 4)
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 5)
     (call
       (touch.gloc.of expansion-trace-level)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 6)
     (call
       (touch.gloc.of expansion-trace-stack)
       (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 552967))
     (set.iloc 1 . 7)
     (call
       (touch.gloc.of current-temporary-count)
       (push.const . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-rename-count)
       (push.const . 0)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-macro-expression)
       (push.const . #f)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.const . #f)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #f)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.const . 0)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 552967))
     (touch.gloc.of expansion-trace-stack)
     (push.const)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 552967))
   (push.close
     (0 0)
     (call
       (call
         (touch.gloc.of denote-begin?)
         (push.const)
         (push.const . begin)
         (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 552983))
       (if.true
         (touch.gloc.of flatten-top-level-begin)
         (push.const . begin)
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/expand.scm" . 554007)
         (push.gloc.of private-primitives-environment)
         (apply.gloc.of flatten-top-level-begin "./boot/macro/expand.scm" . 554007))
       (ret.iloc 2 . 0))
     (push)
     (extend . 1)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 556052)
     (if.null? (ret.const.unspec))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.gloc.of private-primitives-environment)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 558125))
     (push)
     (push.gloc.of annotate)
     (push.gloc.of annotate-closure)
     (call (apply.gloc.of current-after-expansion-hook "./boot/macro/expand.scm" . 558094))
     (apply))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (push.iloc.1 . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-rename-count)
       (push.iloc.1 . 1)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.1 . 2)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc.1 . 3)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 4)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 5)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 552967))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.iloc.1 . 6)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 552967))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 7)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 552967))
   (apply.gloc.of |.dynamic-wind| "./boot/macro/expand.scm" . 551956))
 (set.gloc.of macro-expand)
 (ret.const.unspec))

;
((close
   (2 0 . expand-lambda)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 7183))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/base.scm" . 7180)
   (if.true
     (call
       (touch.gloc.of collect-lambda-formals)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 8240)
       (push.iloc.0 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/base.scm" . 8216))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 9245))
     (push)
     (extend . 1)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/base.scm" . 10303))
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/base.scm" . 10285))
       (push)
       (apply.gloc.of map "./boot/macro/base.scm" . 10270))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 3 . 0)
       (push.cddr.iloc (3 . 0) "./boot/macro/base.scm" . 11309)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of extend-env "./boot/macro/base.scm" . 11321))
       (push)
       (apply.gloc.of expand-body "./boot/macro/base.scm" . 11291))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.const . lambda)
       (push.const . "empty body")
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 13332))
     (touch.gloc.of annotate)
     (push.const . lambda)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cadr.iloc (4 . 0) "./boot/macro/base.scm" . 14399)
       (push.iloc.1 . 0)
       (apply.gloc.of rename-lambda-formals "./boot/macro/base.scm" . 14376))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/base.scm" . 14356)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 14356))
   (push.const . lambda)
   (push.const . "expected formals and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 16396))
 (set.gloc.of expand-lambda)
 (ret.const.unspec))
((close
   (2 0 . expand-quote)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 20492))
   (push)
   (push.const . 2)
   (subr.gloc.of = 2 "./boot/macro/base.scm" . 20489)
   (if.true
     (touch.gloc.of annotate)
     (push.const . quote)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 21553)
       (apply.gloc.of strip-rename-suffix "./boot/macro/base.scm" . 21532))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/base.scm" . 21513)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 21513))
   (push.const . quote)
   (push.const . "expected single datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 22537))
 (set.gloc.of expand-quote)
 (ret.const.unspec))
((close
   (2 0 . expand-begin)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 26634))
     (if.false.ret)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 27669)
     (if.pair?.ret.const . #t)
     (push.const . begin)
     (push.const . "misplaced empty begin")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 28686))
   (touch.gloc.of annotate)
   (push.const . begin)
   (call
     (touch.gloc.of flatten-begin)
     (call
       (touch.gloc.of expand-each)
       (push.cdr.iloc (0 . 0) "./boot/macro/base.scm" . 29749)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/base.scm" . 29736))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of flatten-begin "./boot/macro/base.scm" . 29721))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 29701))
 (set.gloc.of expand-begin)
 (ret.const.unspec))
((close
   (2 0 . expand-if)
   (touch.gloc.of annotate)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (ret.pair? "./boot/macro/base.scm" . 33797))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 1)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddddr| 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cadddr| 1 "./boot/macro/base.scm" . 33797)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 33797)
       (extend . 2)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 1)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/base.scm" . 33797))
     (push.const . if)
     (push.const . "expected 2 or 3 expressions")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 33797))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 32771))
 (set.gloc.of expand-if)
 (ret.const.unspec))
((close
   (2 0 . expand-set!)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 48133)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 48133))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 48133)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (extend . 2)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/base.scm" . 48133))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 3 . 1)
           (apply.gloc.of extend-env "./boot/macro/base.scm" . 48133))
         (push)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
       (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/base.scm" . 48133))
       (if.true.ret)
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.const . set!)
       (push.const . "misplaced syntactic keyword as variable")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (push.gloc.of immutable-primitives)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (call
         (touch.gloc.of renamed-id?)
         (push.iloc.0 . 0)
         (apply.gloc.of renamed-id? "./boot/macro/base.scm" . 48133))
       (if.true.ret.const . #f)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 4 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
         (apply.gloc.of denote-lambda? "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 48133))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 48133))
     (touch.gloc.of annotate)
     (push.const . set!)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 48133)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 48133))
   (push.const . set!)
   (push.const . "expected variable and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
 (set.gloc.of expand-set!)
 (ret.const.unspec))
((close
   (2 0 . expand-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 74757))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 74757)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 74757))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/base.scm" . 74757))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 74757))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
 (set.gloc.of expand-let-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (ret.subr.gloc.of |.list?| "./boot/macro/base.scm" . 87045))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 87045)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 87045))
     (touch.gloc.of expand-form)
     (push.const . |.BEGIN|)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/base.scm" . 87045))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 87045))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
 (set.gloc.of expand-letrec-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-define-syntax)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99338))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 100380)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 100362))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 99333)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 99333))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 99333)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (extend . 2)
     (call
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 4 . 0)
           (push.iloc 3 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-macro "./boot/macro/base.scm" . 99333))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 99333))
           (if.true
             (push.const . variable)
             (push.iloc 3 . 1)
             (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
             (push.iloc 4 . 1)
             (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
           (push.const . syntax)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |.set-top-level-macro!| "./boot/macro/base.scm" . 99333))
         (apply.gloc.of |.call-with-values| "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 99333))
     (call
       (touch.gloc.of env-delete!)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-delete! "./boot/macro/base.scm" . 99333))
     (ret.const begin))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
   (push.const . "expected symbol and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
 (set.gloc.of expand-define-syntax)
 (ret.const.unspec))
((close
   (1 0 . immutable?)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 119821)
   (if.true.ret)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (ret.subr.gloc.of memq "./boot/macro/base.scm" . 120845))
 (set.gloc.of |immutable?`2|)
 (close
   (2 0 . expand-define)
   (extend.enclose+
     (1 0 . let?)
     (touch.gloc.of denote-let?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-let? "./boot/macro/base.scm" . 131081))
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 133130))
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 134172)
     (push.const . "misplaced definition")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 134154))
   (call
     (touch.gloc.of desugar-define)
     (push.iloc.1 . 0)
     (apply.gloc.of desugar-define "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 135194)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 135194)
   (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (extend . 2)
   (call
     (call
       (touch.gloc.of |immutable?`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |immutable?`2| "./boot/macro/base.scm" . 135194))
     (if.false.ret)
     (push.car.iloc (3 . 0) "./boot/macro/base.scm" . 135194)
     (push.const . "attempt to modify immutable binding")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 135194))
   (call
     (push.const . #f)
     (push.const . #f)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 1)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc 2 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/macro/base.scm" . 135194)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (apply.iloc+ (3 . 0) "./boot/macro/base.scm" . 135194))
     (if.true
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/base.scm" . 135194)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/base.scm" . 135194)
   (call
     (touch.gloc.of env-delete!)
     (push.iloc 4 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-delete! "./boot/macro/base.scm" . 135194))
   (touch.gloc.of annotate)
   (push.const . define)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/macro/base.scm" . 135194)
   (push.iloc 4 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 135194))
 (set.gloc.of expand-define)
 (ret.const.unspec))

;
((close
   (2 0 . expand-let)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.pair? "./boot/macro/derived.scm" . 7173))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 7173)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 7173)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 3)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 1)
       (push.const . |.LETREC*|)
       (push.iloc.0 . 2)
       (push.const . |.LAMBDA|)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 7173)
       (push.iloc.0 . 2)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 7173)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 4 . 0)
       (push.cddr.iloc (4 . 0) "./boot/macro/derived.scm" . 7173)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of cons)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
         (push)
         (push.iloc 4 . 1)
         (apply.gloc.of extend-env "./boot/macro/derived.scm" . 7173))
       (push)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 5 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (call
       (push.close
         (2 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (call
           (touch.gloc.of denote-lambda?)
           (push.iloc 6 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
           (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 7173))
         (if.false.ret)
         (touch.gloc.of set-closure-comment!)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of original-id)
           (push.iloc.0 . 1)
           (apply.gloc.of original-id "./boot/macro/derived.scm" . 7173))
         (push)
         (apply.gloc.of set-closure-comment! "./boot/macro/derived.scm" . 7173))
       (push.iloc 2 . 1)
       (push.iloc 2 . 0)
       (apply.gloc.of for-each "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.1 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
 (set.gloc.of expand-let)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec*)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.pair? "./boot/macro/derived.scm" . 44037))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 44037))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 44037))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 44037))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 44037))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 44037)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 44037)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 44037))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 44037))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 2 . 0)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 44037))
     (push)
     (push.iloc.1 . 1)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 7 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
 (set.gloc.of expand-letrec*)
 (ret.const.unspec))
((close
   (2 0 . expand-let*)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 74764))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 74761)
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 75801)
     (extend . 1)
     (call
       (touch.gloc.of check-let*-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let*-bindings "./boot/macro/derived.scm" . 76811))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.cddr.iloc (3 . 0) "./boot/macro/derived.scm" . 81951)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 80911))
           (push.const . |.LET|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 82972)
           (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 80911)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 82990)
             (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 82984))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 80911))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 79885))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75785))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75785))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 86043)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 86025))
 (set.gloc.of expand-let*)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . |.&UNDEF|)
   (ret.subr.gloc.of list "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn3.1`3|)
 (close (1 0) (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0)
   (push.const . set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . expand-letrec)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.pair? "./boot/macro/derived.scm" . 90117))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.const)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
     (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 90117)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LETREC*|)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cdaadr| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 90117)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 90117))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 90117))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 90117))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 90117)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 90117)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
             (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 90117)
             (push.iloc.0 . 0)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 90117))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (push.iloc.1 . 0)
         (apply.gloc.of any1 "./boot/macro/derived.scm" . 90117))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
     (call
       (touch.gloc.of every1)
       (push.close
         (1 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (touch.gloc.of denote-lambda?)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 90117)
         (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 90117))
       (push.iloc.1 . 0)
       (apply.gloc.of every1 "./boot/macro/derived.scm" . 90117))
     (if.true
       (touch.gloc.of annotate)
       (push.const . letrec*)
       (call
         (touch.gloc.of rewrite-letrec*-bindings)
         (call
           (push.gloc.of list)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 90117))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
       (push.iloc 7 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 90117))
     (call
       (push.gloc.of |.fn4.1`4|)
       (push.iloc 5 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (extend . 1)
     (push.const . let)
     (call
       (push.gloc.of |.fn3.1`3|)
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 90117))
     (push)
     (push.iloc 2 . 1)
     (push.subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 90117)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 90117)
     (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 90117))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 90117)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 90117))
 (set.gloc.of expand-letrec)
 (ret.const.unspec))
((close
   (2 0 . expand-let-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 124933))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 124933)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "expected bindings and body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of append)
           (call
             (push.close
               (1 0)
               (call
                 (iloc.0 . 0)
                 (if.not.pair?.ret.const . #f)
                 (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (if.not.pair?.ret.const . #f)
                 (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (ret.null? "./boot/macro/derived.scm" . 124933))
               (if.true
                 (touch.gloc.of collect-lambda-formals)
                 (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
                 (push.iloc 2 . 0)
                 (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
               (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 124933)
               (push.const . "expected each binding consist of formals and expression")
               (push.iloc 2 . 0)
               (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
             (push.iloc.0 . 1)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (apply.gloc.of apply "./boot/macro/derived.scm" . 124933))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/derived.scm" . 124933))
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 124933)
       (push.const . "duplicate formals")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
     (touch.gloc.of annotate)
     (call
       (extend.enclose
         (2 0 . loop)
         (iloc.0 . 0)
         (if.null?
           (touch.gloc.of expand-form)
           (push.const . |.LET|)
           (push.const)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 124933)
           (push.iloc.0 . 1)
           (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
         (call
           (car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 124933)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 124933)
           (ret.null? "./boot/macro/derived.scm" . 124933))
         (if.true
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 124933)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
           (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 124933)
           (extend . 2)
           (call
             (touch.gloc.of collect-lambda-formals)
             (push.iloc.0 . 1)
             (push.iloc 4 . 0)
             (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of fresh-rename-count)
             (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (call
             (push.gloc.of cons)
             (push.iloc.1 . 0)
             (call
               (push.close
                 (1 0)
                 (touch.gloc.of rename-id)
                 (push.iloc.0 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of rename-id "./boot/macro/derived.scm" . 124933))
               (push.iloc.1 . 0)
               (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.gloc.of map "./boot/macro/derived.scm" . 124933))
           (push)
           (extend . 1)
           (push.const . |.call-with-values|)
           (push.const . lambda)
           (push.const)
           (call
             (touch.gloc.of expand-form)
             (push.iloc 3 . 0)
             (push.iloc 7 . 1)
             (apply.gloc.of expand-form "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (push.const . lambda)
           (call
             (touch.gloc.of rename-lambda-formals)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of rename-lambda-formals "./boot/macro/derived.scm" . 124933))
           (push)
           (call
             (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 124933)
             (call
               (touch.gloc.of extend-env)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of extend-env "./boot/macro/derived.scm" . 124933))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/derived.scm" . 124933))
           (push)
           (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 124933)
           (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 124933))
         (push.const . "internal error: let-values: ~m")
         (push.iloc 3 . 0)
         (apply.gloc.of scheme-error "./boot/macro/derived.scm" . 124933))
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 124933))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 124933))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 124933)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 124933))
 (set.gloc.of expand-let-values)
 (ret.const.unspec))
((close
   (2 0 . expand-do)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 166917)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 166917)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 166917))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 166917)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 166917)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
       (push.const . "malformed (variable init update)")
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 166917))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.pair? "./boot/macro/derived.scm" . 166917))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.car| "./boot/macro/derived.scm" . 166917))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 166917)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 166917)
           (ret.null? "./boot/macro/derived.scm" . 166917))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.caddr| "./boot/macro/derived.scm" . 166917))
         (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
         (push.const . "malformed (variable init update)")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
       (push.iloc.0 . 3)
       (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
     (push)
     (extend . 2)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (call
         (push.close
           (1 0)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 166917))
           (if.true
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
             (ret.subr.gloc.of list "./boot/macro/derived.scm" . 166917))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 166917)
           (push.const . "malformed (variable init update)")
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
         (push.iloc.1 . 3)
         (apply.gloc.of map "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.IF|)
       (push.iloc.1 . 2)
       (call
         (iloc.1 . 1)
         (if.null? (ret.const |.UNSPECIFIED|))
         (push.const . |.BEGIN|)
         (iloc.1 . 1)
         (ret.cons "./boot/macro/derived.scm" . 166917))
       (push)
       (push.const . |.BEGIN|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 166917)
       (subr.gloc.of |.append| 2 "./boot/macro/derived.scm" . 166917)
       (push.cons)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 166917)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 166917))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 166917))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 166917)
   (push.const . "expected (variable init update), test, and command")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 166917))
 (set.gloc.of expand-do)
 (ret.const.unspec))
((close
   (2 0 . expand-let*-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 199685))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 199685)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 199685)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.cons*| "./boot/macro/derived.scm" . 199685))
           (call
             (car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 199685)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 199685)
             (ret.null? "./boot/macro/derived.scm" . 199685))
           (if.true
             (push.const . |.CALL-WITH-VALUES|)
             (push.const . |.LAMBDA|)
             (push.const)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (push.const . |.LAMBDA|)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
             (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 199685)
             (call
               (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
               (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 199685))
             (push)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 199685)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 199685))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 199685)
           (push.const . "expected each binding consist of formals and expression")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
         (push.iloc.1 . 1)
         (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 199685))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 199685))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 199685))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 199685)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 199685))
 (set.gloc.of expand-let*-values)
 (ret.const.unspec))
((close
   (2 0 . expand-cond)
   (extend.unbound . 3)
   (push.close+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 228384))
   (push.close+
     (1 0 . =>?)
     (touch.gloc.of denote-=>?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-=>? "./boot/macro/derived.scm" . 229406))
   (push.close+
     (1 0 . lambda?)
     (touch.gloc.of denote-lambda?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 230434))
   (enclose . 3)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.1 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 232463))
   (push)
   (push.const . 1)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 232460)
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?.ret.const |.UNSPECIFIED|)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 238626)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (call
               (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.pair? "./boot/macro/derived.scm" . 239638))
           (if.true
             (cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (if.null?
               (push.const . |.BEGIN|)
               (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (ret.cons "./boot/macro/derived.scm" . 239638))
             (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . "misplaced else")
             (push.iloc 5 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 239638)
             (if.false.ret)
             (call
               (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 2) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 239638)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.const . |.LET|)
             (push.const)
             (push.iloc 2 . 0)
             (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 239638)
             (if.not.null?.ret.const . #f)
             (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 239638)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (extend . 2)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 239638))
             (push)
             (extend . 1)
             (push.const . |.LET|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 239638)
             (push.const . |.IF|)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (push.subr.gloc.of |.list| 4 "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.null? "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.OR|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 239638))
           (if.true
             (push.const . |.IF|)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.const . |.BEGIN|)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 239638)
             (push.cons)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 239638)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 239638))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/derived.scm" . 239638))
           (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 239638)
           (push.const . "malformed cond clause")
           (push.iloc 5 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 239638))
         (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 235550)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 235534))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 228357))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 228357))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 267294)
   (push.const . "expected cond clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 267276))
 (set.gloc.of expand-cond)
 (ret.const.unspec))
((close
   (2 0 . maplist)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call (push.iloc.0 . 1) (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 277531))
   (push)
   (call
     (touch.gloc.of |maplist`2|)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/macro/derived.scm" . 277556)
     (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 277542))
   (ret.cons "./boot/macro/derived.scm" . 277525))
 (set.gloc.of |maplist`2|)
 (close
   (2 0 . expand-case)
   (extend.enclose+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 272416))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (ret.pair? "./boot/macro/derived.scm" . 298040))
   (if.true
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
     (extend . 2)
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 298040))
     (push)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LET|)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
       (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 298040)
       (push.const . |.COND|)
       (call
         (touch.gloc.of |maplist`2|)
         (push.close
           (1 0)
           (push.gloc.of pair?)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.pair? "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 298040)
             (ret.subr.gloc.of |.list?| "./boot/macro/derived.scm" . 298040))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (call
               (push.iloc 3 . 0)
               (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
               (apply.iloc+ (6 . 0) "./boot/macro/derived.scm" . 298040))
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (if.null?
               (push.const . |.ELSE|)
               (push.iloc 3 . 0)
               (subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
             (push.const . "misplaced else")
             (push.iloc 7 . 0)
             (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.pair?.ret.const . #f)
             (push.iloc 3 . 0)
             (subr.gloc.of |.cdaar| 1 "./boot/macro/derived.scm" . 298040)
             (if.not.null?.ret.const . #f)
             (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of |.list?| 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caaar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (call
               (iloc.0 . 1)
               (if.symbol?.ret.const . #t)
               (push.iloc.0 . 1)
               (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
               (if.true.ret)
               (iloc.0 . 1)
               (ret.null? "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.EQ?|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.EQV?|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 298040)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 298040))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cdar| 1 "./boot/macro/derived.scm" . 298040)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.caar| 1 "./boot/macro/derived.scm" . 298040)
             (extend . 2)
             (iloc.0 . 1)
             (if.null?.ret.const #f)
             (call
               (touch.gloc.of every1)
               (push.close
                 (1 0)
                 (iloc.0 . 0)
                 (if.symbol?.ret.const . #t)
                 (push.iloc.0 . 0)
                 (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 298040)
                 (if.true.ret)
                 (iloc.1 . 1)
                 (ret.null? "./boot/macro/derived.scm" . 298040))
               (push.iloc.0 . 1)
               (apply.gloc.of every1 "./boot/macro/derived.scm" . 298040))
             (if.true
               (push.const . |.MEMQ|)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
               (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 298040))
             (push.const . |.MEMV|)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 298040)
             (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 298040))
           (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 298040)
           (push.const . "malformed case clause")
           (push.iloc 7 . 0)
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 298040)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
         (push.iloc.1 . 0)
         (apply.gloc.of |maplist`2| "./boot/macro/derived.scm" . 298040))
       (push.cons)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 298040)
       (push.iloc 3 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 298040))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 298040))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 298040)
   (push.const . "expected case clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 298040))
 (set.gloc.of expand-case)
 (ret.const.unspec))
((close
   (2 0 . expand-and)
   (touch.gloc.of annotate)
   (push.const . and)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 312356)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 312343))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 312325))
 (set.gloc.of expand-and)
 (ret.const.unspec))
((close
   (2 0 . expand-or)
   (touch.gloc.of annotate)
   (push.const . or)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 316451)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 316438))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 316421))
 (set.gloc.of expand-or)
 (ret.const.unspec))
((close
   (1 0 . desugar-define)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (touch.gloc.of annotate)
     (push.const . define)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (if.not.null?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 2)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 1)
     (push.const . lambda)
     (push.iloc.0 . 0)
     (push.const (|.UNSPECIFIED|))
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (ret.pair? "./boot/macro/derived.scm" . 337933))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 337933)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 337933))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 337933)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 337933)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 337933))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 337933)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc 2 . 0)
   (push.subr.gloc.of length 1 "./boot/macro/derived.scm" . 337933)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/derived.scm" . 337933)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected 1 or 2, but no clause given")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.iloc.0 . 0)
   (push.const 1 2)
   (subr.gloc.of |.memq| 2 "./boot/macro/derived.scm" . 337933)
   (if.true
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
     (push.const . "expected symbol for first clause")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
   (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 337933)
   (push.const . "expected 1 or 2, but ~a clauses given")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 337933)
   (push.iloc 3 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 337933))
 (set.gloc.of desugar-define)
 (ret.const.unspec))
((close
   (1 0 . desugar-define-macro)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 344069))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (ret.pair? "./boot/macro/derived.scm" . 344069))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 344069)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 344069))
     (touch.gloc.of annotate)
     (push.const . define-macro)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/macro/derived.scm" . 344069)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 344069)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 344069))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 344069)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
   (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 344069)
   (push.const . "expected symbol and expression")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 344069))
 (set.gloc.of desugar-define-macro)
 (ret.const.unspec))
((close
   (1 0 . rewrite-define-macro)
   (call
     (touch.gloc.of desugar-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of desugar-define-macro "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 357402)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 357402)
   (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 357402)
   (extend . 2)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 357402))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (push.const . |.DEFINE-SYNTAX|)
   (push.iloc.1 . 1)
   (push.const . |.LAMBDA|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 1 "./boot/macro/derived.scm" . 357402)
   (push.const . |.APPLY|)
   (push.iloc.1 . 0)
   (push.const . |.CDR|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 357402)
   (push.iloc 3 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 357402))
 (set.gloc.of rewrite-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-define-macro)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/derived.scm" . 364554))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 365596)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 365578))
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of rewrite-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of rewrite-define-macro "./boot/macro/derived.scm" . 366610))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 366597))
 (set.gloc.of expand-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-identifier-syntax)
   (extend.enclose+
     (1 0 . set!?)
     (touch.gloc.of denote-set!?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-set!? "./boot/macro/derived.scm" . 371744))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.pair? "./boot/macro/derived.scm" . 371717))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
     (ret.null? "./boot/macro/derived.scm" . 371717))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.LAMBDA|)
       (push.const x)
       (push.const . |.SYNTAX-CASE|)
       (push.const . x)
       (push.const)
       (push.const . id)
       (push.const |.IDENTIFIER?| (|.SYNTAX| id))
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.const _ x ...)
       (push.const . |.SYNTAX|)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
       (const x ...)
       (push.cons)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 5 "./boot/macro/derived.scm" . 371717)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
   (iloc.0 . 0)
   (if.false.ret)
   (cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cddadr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
   (subr.gloc.of |.cdr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of |.cdddr| 1 "./boot/macro/derived.scm" . 371717)
   (if.not.null?.ret.const . #f)
   (call
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 371717))
   (if.false.ret)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.cadadr| 1 "./boot/macro/derived.scm" . 371717)
   (push.iloc 2 . 0)
   (push.subr.gloc.of |.caadr| 1 "./boot/macro/derived.scm" . 371717)
   (extend . 2)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
     (push.const . |.LAMBDA|)
     (push.const x)
     (push.const . |.SYNTAX-CASE|)
     (push.const . x)
     (push.const set!)
     (push.const . set!)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.cadr| 1 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.caddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.const . |.SYNTAX|)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.car| 1 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (const x ...)
     (push.cons)
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (const x ...)
     (push.cons)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc.0 . 1)
     (push.const |.IDENTIFIER?| (|.SYNTAX| id))
     (push.const . |.SYNTAX|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 6 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 371717)
     (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 371717)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 371717))
   (push)
   (push.iloc 3 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 371717))
 (set.gloc.of expand-identifier-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-assert)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (ret.null? "./boot/macro/derived.scm" . 398341))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . |.OR|)
       (push.iloc.0 . 0)
       (push.const . assertion-violation)
       (push.const . quote)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/derived.scm" . 398341))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/derived.scm" . 398341)
       (push.const . "assertion failed in expression ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.subr.gloc.of |.list| 3 "./boot/macro/derived.scm" . 398341)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 398341))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 398341))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 398341)
   (push.const . "expected single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 398341))
 (set.gloc.of expand-assert)
 (ret.const.unspec))

;
((close
   (2 0 . expand-quasiquote)
   (extend.unbound . 12)
   (push.close+
     (1 0 . unquote?)
     (touch.gloc.of denote-unquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 8228))
   (push.close+
     (1 0 . quasiquote?)
     (touch.gloc.of denote-quasiquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 9255))
   (push.close+
     (1 0 . unquote-splicing?)
     (touch.gloc.of denote-unquote-splicing?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 10285))
   (push.close+
     (1 0 . quoted?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 15381)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/quasi.scm" . 16405)
     (if.not.null?.ret.const . #f)
     (touch.gloc.of denote-quote?)
     (push.iloc 2 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 17441)
     (apply.gloc.of denote-quote? "./boot/macro/quasi.scm" . 17422))
   (push.close+
     (1 0 . constant?)
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/quasi.scm" . 21517)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/quasi.scm" . 22541)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/quasi.scm" . 23565)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/quasi.scm" . 24589)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of bytevector? 1 "./boot/macro/quasi.scm" . 25613)
     (if.true.ret)
     (push.iloc.0 . 0)
     (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 26637))
   (push.close+
     (1 0 . constant-value)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 30736))
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 30748))
     (ret.iloc 0 . 0))
   (push.close+
     (1 0 . null-constant?)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 35854))
     (if.false.ret)
     (cadr.iloc (0 . 0) "./boot/macro/quasi.scm" . 36885)
     (ret.null? "./boot/macro/quasi.scm" . 36878))
   (push.close+
     (2 0 . emit-append)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 42000))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 43031)
       (push.const . 1)
       (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 43028)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/macro/quasi.scm" . 43048))
       (push.const . |.APPEND|)
       (iloc.0 . 0)
       (ret.cons "./boot/macro/quasi.scm" . 43024))
     (push.const . |.APPEND|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 44047)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 44047)
     (ret.cons "./boot/macro/quasi.scm" . 44047))
   (push.close+
     (2 0 . emit-cons*)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 49168)
     (push.const . 1)
     (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 49165)
     (if.true
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 50200)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 9) "./boot/macro/quasi.scm" . 50189))
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 52244))
     (if.true (push.const . |.LIST|) (iloc.0 . 0) (ret.cons "./boot/macro/quasi.scm" . 52243))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 54315)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 54310))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 55333)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 54291)
       (ret.cons "./boot/macro/quasi.scm" . 54291))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56367)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56391)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 56386))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 57382)
       (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 56339)
       (ret.cons "./boot/macro/quasi.scm" . 56339))
     (push.const . |.CONS*|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of |.list| 1 "./boot/macro/quasi.scm" . 58387)
     (subr.gloc.of |.append| 2 "./boot/macro/quasi.scm" . 58387)
     (ret.cons "./boot/macro/quasi.scm" . 58387))
   (push.close+
     (2 0 . emit-cons)
     (call
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63506))
       (if.false.ret)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63523))
     (if.true
       (push.const . |.QUOTE|)
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64545))
       (push)
       (call (push.iloc.0 . 1) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64567))
       (push.cons)
       (ret.subr.gloc.of list "./boot/macro/quasi.scm" . 64525))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 65556))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 65555))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 67627)
       (const . |.LIST|)
       (ret.eq? "./boot/macro/quasi.scm" . 67622))
     (if.true
       (push.const . |.LIST|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 68644)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 67603))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69679)
       (const . |.CONS|)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69703)
       (const . |.CONS*|)
       (ret.eq? "./boot/macro/quasi.scm" . 69698))
     (if.true
       (push.const . |.CONS*|)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 70693)
       (ret.subr.gloc.of |.cons*| "./boot/macro/quasi.scm" . 69651))
     (push.const . |.CONS|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 71699))
   (push.close
     (2 0 . expand-vector)
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/quasi.scm" . 76828)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 11) "./boot/macro/quasi.scm" . 76820))
     (push)
     (extend . 1)
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 6) "./boot/macro/quasi.scm" . 77842))
     (if.true.ret.const |.QUOTE| #())
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 4) "./boot/macro/quasi.scm" . 79890))
     (if.true
       (push.const . |.QUOTE|)
       (call
         (call (push.iloc.0 . 0) (apply.iloc+ (2 . 5) "./boot/macro/quasi.scm" . 80938))
         (push)
         (apply.gloc.of list->vector "./boot/macro/quasi.scm" . 80924))
       (push)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 79889))
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 81943)
     (const . |.LIST|)
     (if.eq?
       (push.const . |.VECTOR|)
       (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 82974)
       (ret.cons "./boot/macro/quasi.scm" . 81937))
     (push.const . |.LIST->VECTOR|)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 83985))
   (push.close
     (2 0 . expand)
     (iloc.0 . 0)
     (if.pair?
       (=n.iloc (0 . 1) 0 "./boot/macro/quasi.scm" . 90132)
       (if.true
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (ret.subr.gloc.of |.list?| "./boot/macro/quasi.scm" . 90128))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 8) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caar| 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cdar| 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 7) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (subr.gloc.of |.list?| 1 "./boot/macro/quasi.scm" . 90128)
           (if.false.ret)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (call
             (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.null?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of |.cadr| "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "nested quasiquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote-splicing appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 108575)
       (extend . 1)
       (call
         (call
           (touch.gloc.of denote-unquote?)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 109601))
         (if.true.ret)
         (touch.gloc.of denote-unquote-splicing?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 109627))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 110621)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 111664)
           (push.n+.iloc (1 . 1) -1 "./boot/macro/quasi.scm" . 111675)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 111656))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 110621))
       (call
         (touch.gloc.of denote-quasiquote?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 112669))
       (if.true
         (push.const . |.QUOTE|)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/quasi.scm" . 113693)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 114736)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/quasi.scm" . 114747)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 114728))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 113693))
       (call
         (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 116784)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 116776))
       (push)
       (call
         (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 117808)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 117800))
       (push)
       (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 116765))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/quasi.scm" . 118800)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 10) "./boot/macro/quasi.scm" . 119824))
     (iloc.0 . 0)
     (if.symbol?
       (push.const . |.QUOTE|)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of |.list| "./boot/macro/quasi.scm" . 120847))
     (iloc.0 . 0)
     (if.null?.ret.const |.QUOTE| ())
     (ret.iloc 0 . 0))
   (enclose . 12)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (call
       (push.cadr.iloc (1 . 0) "./boot/macro/quasi.scm" . 127012)
       (push.const . 0)
       (apply.iloc (0 . 11) "./boot/macro/quasi.scm" . 127004))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/quasi.scm" . 126994))
   (push)
   (push.iloc.1 . 1)
   (apply.gloc.of expand-form "./boot/macro/quasi.scm" . 126981))
 (set.gloc.of expand-quasiquote)
 (ret.const.unspec))

;
((close
   (1 0 . ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 8209)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 9231)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 9226))
 (set.gloc.of ellipsis-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-splicing-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 14353)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 15375)
   (const . ...)
   (if.not.eq?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 16401)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/synpat.scm" . 17423)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 17418))
 (set.gloc.of ellipsis-splicing-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-quote?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 22545)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 23567)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 23562))
 (set.gloc.of ellipsis-quote?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of |loop`5|)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 29716)
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 30746)
       (push.iloc.0 . 1)
       (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 30740))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 29710))
   (push.iloc.0 . 0)
   (const . ...)
   (if.eq? (ret.iloc 0 . 1))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 33810)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/synpat.scm" . 33829))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 34830)
   (if.true
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 35860)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 35854))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . collect-unique-ids)
   (touch.gloc.of |loop`5|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`5| "./boot/macro/synpat.scm" . 27653))
 (set.gloc.of collect-unique-ids)
 (ret.const.unspec))
((close
   (4 0 . collect-vars-ranks)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 3))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 43024)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of acons)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of acons "./boot/macro/synpat.scm" . 45072))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 0)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 46092))
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 47136)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 48173)
       (if.symbol?
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 49195)
         (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 49205)
         (push.iloc.0 . 3)
         (apply.gloc.of acons "./boot/macro/synpat.scm" . 49188))
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 50232)
       (push.iloc.0 . 1)
       (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 50248)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 50212))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 47116))
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of collect-vars-ranks)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 52256)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 53300)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 53280))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 52236))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 54284)
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 55328)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 55308))
   (ret.iloc 0 . 3))
 (set.gloc.of collect-vars-ranks)
 (ret.const.unspec))
((close
   (2 0 . check-duplicate-variable)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 65560)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 66590)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 66584))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 65554))
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq? (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (const . _)
     (if.eq? (ret.iloc 0 . 1))
     (iloc.0 . 0)
     (if.symbol?
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 70678)
       (if.true (ret.iloc 0 . 1))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 72730)
       (if.true
         (push.const . "syntax pattern")
         (push.const . "duplicate pattern variables")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 73754))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synpat.scm" . 74778))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 75794)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 76824)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 76818))
     (ret.iloc 0 . 1))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 63497))
 (set.gloc.of |check-duplicate-variable`2|)
 (close
   (2 0 . check-misplaced-ellipsis)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq?
       (push.const . "syntax pattern")
       (push.const . "improper use of ellipsis")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 83986))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 85010))
     (if.true
       (call
         (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 86048)
         (if.not.symbol?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 87069)
         (push.iloc 2 . 1)
         (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 87063)
         (if.false.ret)
         (push.const . "syntax pattern")
         (push.const . "ellipsis following literal")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 88087))
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 91170)
         (const . ...)
         (if.eq?
           (push.const . "syntax pattern")
           (push.const . "ambiguous use of ellipsis")
           (push.iloc 4 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 92189))
         (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 93219)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 93213))
       (push.cddr.iloc (1 . 0) "./boot/macro/synpat.scm" . 89122)
       (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 89106))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 95260)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95254))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 95277)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95271))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 96274)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 97304)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 97298))
     (ret.const . #f))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 81929))
 (set.gloc.of |check-misplaced-ellipsis`2|)
 (close
   (2 0 . check-pattern)
   (call
     (touch.gloc.of |check-misplaced-ellipsis`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of |check-misplaced-ellipsis`2| "./boot/macro/synpat.scm" . 100357))
   (touch.gloc.of |check-duplicate-variable`2|)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of |check-duplicate-variable`2| "./boot/macro/synpat.scm" . 101381))
 (set.gloc.of check-pattern)
 (ret.const.unspec))
((close
   (3 0 . match-ellipsis?)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 107550)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 107561)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 107534))
   (if.false.ret)
   (touch.gloc.of match-ellipsis?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 108575)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 108558))
 (set.gloc.of match-ellipsis?)
 (ret.const.unspec))
((close
   (4 0 . match-ellipsis-n?)
   (=n.iloc (0 . 2) 0 "./boot/macro/synpat.scm" . 112649)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 114718)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 114729)
     (push.iloc.0 . 3)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 114702))
   (if.false.ret)
   (touch.gloc.of match-ellipsis-n?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 115745)
   (push.iloc.0 . 1)
   (push.n+.iloc (0 . 2) -1 "./boot/macro/synpat.scm" . 115760)
   (push.iloc.0 . 3)
   (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 115726))
 (set.gloc.of match-ellipsis-n?)
 (ret.const.unspec))
((close
   (3 0 . match-pattern?)
   (push.iloc.0 . 1)
   (const . _)
   (if.eq?.ret.const . #t)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 121875)
     (if.true
       (call
         (iloc.0 . 0)
         (if.symbol?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of identifier? "./boot/macro/synpat.scm" . 123932))
       (if.false.ret)
       (touch.gloc.of free-id=?)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of free-id=? "./boot/macro/synpat.scm" . 124952))
     (ret.const . #t))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 126988))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 128028)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 128040))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 129053)
       (if.symbol?.ret.const . #t)
       (touch.gloc.of match-ellipsis?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 130068))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131100))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 131130)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131118))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 131097)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 132118)
     (if.true
       (touch.gloc.of match-pattern?)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 133163)
       (push.iloc.1 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 133142))
     (>n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 134171)
     (if.false.ret)
     (call
       (touch.gloc.of match-ellipsis-n?)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 135195))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 136235)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 136254)
     (push.iloc.1 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 136219))
   (iloc.0 . 1)
   (if.pair?
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of match-pattern?)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 139297)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 139308)
       (push.iloc.0 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 139281))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 140321)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 140332)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 140305))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 141324)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 142353)
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143393)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143413)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 143377))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of equal? "./boot/macro/synpat.scm" . 144401))
 (set.gloc.of match-pattern?)
 (ret.const.unspec))
((close
   (2 0 . union-vars)
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (touch.gloc.of union-vars)
   (call
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 150560)
     (push.iloc.0 . 1)
     (push.subr.gloc.of cdar 1 "./boot/macro/synpat.scm" . 150582)
     (push.subr.gloc.of reverse 1 "./boot/macro/synpat.scm" . 150573)
     (push.iloc.0 . 0)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 150549))
   (push)
   (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 151573)
   (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 150537))
 (set.gloc.of union-vars)
 (ret.const.unspec))
((close
   (3 0 . bind-var!)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 2))
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (push.subr.gloc.of assq 2 "./boot/macro/synpat.scm" . 157720)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 159795)
     (push.cons)
     (subr.gloc.of set-cdr! 2 "./boot/macro/synpat.scm" . 159769)
     (ret.iloc 1 . 2))
   (touch.gloc.of acons)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of list 1 "./boot/macro/synpat.scm" . 160797)
   (push.iloc.1 . 2)
   (apply.gloc.of acons "./boot/macro/synpat.scm" . 160786))
 (set.gloc.of bind-var!)
 (ret.const.unspec))
((close
   (3 0 . bind-null-ellipsis)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 167953)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 168987)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 168981)
       (if.true (ret.iloc 0 . 1))
       (touch.gloc.of bind-var!)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 171040)
       (push.const)
       (push.iloc.0 . 1)
       (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 171029))
     (push)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 167947))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.car.iloc (1 . 0) "./boot/macro/synpat.scm" . 164905)
     (apply.gloc.of collect-unique-ids "./boot/macro/synpat.scm" . 164885))
   (push)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 164869))
 (set.gloc.of bind-null-ellipsis)
 (ret.const.unspec))
((close
   (5 0 . bind-ellipsis)
   (iloc.0 . 0)
   (if.null?
     (iloc.0 . 4)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 177165))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 178189))
   (touch.gloc.of bind-ellipsis)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 179224)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 180262)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 180273)
     (push.iloc.0 . 2)
     (push.iloc.0 . 4)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 180248))
   (push)
   (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 179209))
 (set.gloc.of bind-ellipsis)
 (ret.const.unspec))
((close
   (6 0 . bind-ellipsis-n)
   (=n.iloc (0 . 3) 0 "./boot/macro/synpat.scm" . 184329)
   (if.true
     (touch.gloc.of union-vars)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 185353))
   (touch.gloc.of bind-ellipsis-n)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 186394)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.n+.iloc (0 . 3) -1 "./boot/macro/synpat.scm" . 186415)
   (push.iloc.0 . 4)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 187432)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 187443)
     (push.iloc.0 . 2)
     (push.iloc.0 . 5)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 187418))
   (push)
   (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 186377))
 (set.gloc.of bind-ellipsis-n)
 (ret.const.unspec))
((close
   (4 0 . bind-pattern)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 192528)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 194576))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 195596))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 196636)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 196648))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 197661)
       (if.symbol?
         (touch.gloc.of bind-var!)
         (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 198687)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 198676))
       (touch.gloc.of bind-ellipsis)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 199700))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200732))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 200762)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200750))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 200729)
     (extend . 1)
     (touch.gloc.of bind-pattern)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 201760)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 201779)
     (push.iloc.1 . 2)
     (call
       (call
         (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 202793)
         (if.false.ret)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 202810)
         (ret.subr.gloc.of symbol? "./boot/macro/synpat.scm" . 202801))
       (if.true
         (touch.gloc.of bind-var!)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 203823)
         (push.const)
         (push.iloc.1 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 203812))
       (touch.gloc.of bind-ellipsis-n)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 204836))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 201746))
   (iloc.0 . 1)
   (if.pair?
     (touch.gloc.of bind-pattern)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 206874)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 206885)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of bind-pattern)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 207912)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 207923)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 207898))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 206860))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 208908)
   (if.true
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209946)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209966)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 209932))
   (ret.iloc 0 . 3))
 (set.gloc.of bind-pattern)
 (ret.const.unspec))

;
((close
   (2 0 . collect-rename-ids)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 11287)
     (push.iloc 2 . 1)
     (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 11281)
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 12311)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 12305))
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13335)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13351)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 13345))
     (ret.cons "./boot/macro/syntmp.scm" . 13329))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.1 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 7184))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 8199))
 (set.gloc.of collect-rename-ids)
 (ret.const.unspec))
((close
   (1 0 . parse-ellipsis-splicing)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 18469)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 18464))
     (if.true
       (push.n+.iloc (0 . 0) 1 "./boot/macro/syntmp.scm" . 19476)
       (push.cdr.iloc (0 . 1) "./boot/macro/syntmp.scm" . 19486)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 19470))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-head 2 "./boot/macro/syntmp.scm" . 21526)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 21518))
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.subr.gloc.of cdddr 1 "./boot/macro/syntmp.scm" . 17438)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 17413))
 (set.gloc.of parse-ellipsis-splicing)
 (ret.const.unspec))
((close
   (2 0 . check-template)
   (extend.unbound . 2)
   (push.close
     (2 0 . control-patvar-exists?)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 30742))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 30738))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 31762))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 32816))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 33827)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 33816))
           (if.true.ret)
           (call
             (push.iloc.0 . 0)
             (push.const . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 34845))
           (if.false.ret)
           (push.iloc.0 . 1)
           (push.iloc.1 . 1)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 35869))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 28681))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 36882))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 37916)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 37926)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 37910))
         (if.true.ret)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 38945)
           (push.const . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 38939))
         (if.false.ret)
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 39969)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 39963))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 40978))
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of rank-of)
               (push.iloc.0 . 0)
               (push.iloc 5 . 1)
               (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 42029))
             (push)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 42025))
           (call
             (touch.gloc.of collect-unique-ids)
             (push.iloc.0 . 0)
             (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 42056))
           (push)
           (apply.gloc.of any1 "./boot/macro/syntmp.scm" . 42006))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 43036)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 43030))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 45084)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 45078))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 46108)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 46102))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 47122)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 48152)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 48146))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 28681))
   (push.close
     (2 0 . check-escaped)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 55324))
         (push)
         (push.iloc 2 . 1)
         (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 55319)
         (if.false.ret)
         (push.const . "syntax template")
         (push.const . "too few ellipsis following subtemplate")
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 56343))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 58392)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 58386))
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 59416)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 59410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 60434)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 61464)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 61458))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 53257))
   (enclose . 2)
   (call
     (call
       (touch.gloc.of safe-length)
       (push.iloc.1 . 0)
       (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 63505))
     (push)
     (push.const . 2)
     (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 63502)
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 63532)
     (const . ...)
     (ret.eq? "./boot/macro/syntmp.scm" . 63527))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 64536)
     (push.const . 0)
     (apply.iloc (0 . 1) "./boot/macro/syntmp.scm" . 64521))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (call
         (push.iloc.0 . 0)
         (const . ...)
         (if.not.eq?.ret.const . #f)
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 68631))
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 69658))
       (>.iloc (0 . 1) "./boot/macro/syntmp.scm" . 69655)
       (if.false.ret)
       (push.const . "syntax template")
       (push.const . "too few ellipsis following subtemplate")
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 70679))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 71698))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 72752))
       (push.close
         (3 0)
         (call
           (=n.iloc (1 . 1) 0 "./boot/macro/syntmp.scm" . 73753)
           (if.false.ret)
           (call
             (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 74805)
             (push.iloc.0 . 2)
             (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 74781))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 4 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 75805))
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 76831)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 76820))
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 77844))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 65545))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 78866))
     (if.true
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 79906)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 80942)
           (push.iloc 3 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 80933))
         (push)
         (extend . 1)
         (<n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 81954)
         (if.true
           (push.const . "syntax template")
           (push.const . "misplace ellipsis following literal")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 83057)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 82978))
         (n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 84010)
         (<.iloc (0 . 0) "./boot/macro/syntmp.scm" . 84002)
         (if.true
           (push.const . "syntax template")
           (push.const . "too few ellipsis following subtemplate")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 85108)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 85026))
         (push.cddr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 87080)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 87074))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 88096)
       (if.pair?
         (call
           (=n.iloc (0 . 1) 0 "./boot/macro/syntmp.scm" . 89118)
           (if.false.ret)
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 90170)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 90180)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 90146))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 91276)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 91170))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 92191)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 92201)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 92185))
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 93215)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 93209))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 94240)
       (if.null?
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis following empty list")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 95257))
       (push.const . "syntax template")
       (push.const . "misplaced ellipsis following literal")
       (push.iloc 3 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 97385)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 97305))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 98322))
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 99361)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 99346))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 100376)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 100370))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 102424)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 102418))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 103448)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 103442))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 104466)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 105496)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 105490))
     (ret.const.unspec))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 65545))
 (set.gloc.of check-template)
 (ret.const.unspec))
((close
   (2 0 . rank-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 109585)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 110608))
   (ret.const . -1))
 (set.gloc.of rank-of)
 (ret.const.unspec))
((close
   (2 0 . subform-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 114698)
   (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 114693))
 (set.gloc.of subform-of)
 (ret.const.unspec))
((close
   (4 0 . collect-ellipsis-vars)
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 118800))
   (push)
   (extend . 1)
   (touch.gloc.of filter)
   (push.gloc.of values)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 121889)
       (push.iloc.1 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syntmp.scm" . 121883)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 122930)
       (push.iloc 2 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 122924)
       (subr.gloc.of cdr 1 "./boot/macro/syntmp.scm" . 122919)
       (<.iloc (2 . 2) "./boot/macro/syntmp.scm" . 123940)
       (if.true (ret.iloc 0 . 0))
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124975)
       (cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124986)
       (ret.cons "./boot/macro/syntmp.scm" . 124969))
     (push.iloc.1 . 3)
     (apply.gloc.of map "./boot/macro/syntmp.scm" . 118789))
   (push)
   (apply.gloc.of filter "./boot/macro/syntmp.scm" . 118789))
 (set.gloc.of collect-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . consume-ellipsis-vars)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 139299)
         (push.iloc 3 . 0)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 139290))
       (<.iloc (3 . 1) "./boot/macro/syntmp.scm" . 139287)
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140317)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140333)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 140327))
         (ret.cons "./boot/macro/syntmp.scm" . 140311))
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 141342)
       (if.null?
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 142365)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 142359))
       (push.iloc.0 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 143390)
       (if.null?
         (const . #t)
         (set.iloc 2 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 145437)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 145431))
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 147499)
         (subr.gloc.of circular-list? 1 "./boot/macro/syntmp.scm" . 147483)
         (if.true.ret)
         (const . #t)
         (set.iloc 2 . 1)
         (ret.const.unspec))
       (touch.gloc.of acons)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 148510)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 148521)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 148539)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 148533))
       (push)
       (apply.gloc.of acons "./boot/macro/syntmp.scm" . 148503))
     (push.iloc 2 . 2)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137230))
   (push)
   (extend . 1)
   (iloc.1 . 1)
   (if.true (iloc.1 . 0) (if.true.ret.const . #f) (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.true.ret)
   (ret.const))
 (set.gloc.of consume-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . contain-rank-moved-var?)
   (extend.enclose+
     (2 0 . traverse-escaped)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 160791))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 160786))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 162844)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 162838))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 163868)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 163862))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 164882)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 165912)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 165906))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 158729))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (push.const . 0)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 171027))
       (push)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 171022))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 172046))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 173100))
       (push.close
         (3 0)
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 174111)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 174100))
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 175124))
       (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 168965))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 176142))
     (if.true
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 177176)
         (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 177186)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 177170))
       (if.true.ret)
       (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 178200)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 178194))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 179214))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 180256)
       (push.iloc.0 . 1)
       (apply.iloc+ (2 . 0) "./boot/macro/syntmp.scm" . 180238))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 182296)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 182290))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 183320)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 183314))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 184334)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 185364)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 185358))
     (ret.const . #f))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 168965))
 (set.gloc.of contain-rank-moved-var?)
 (ret.const.unspec))
((close
   (3 0 . rewrite-template-ranks-vars)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (2 0 . revealed)
     (push.const . 0)
     (call
       (touch.gloc.of rank-of)
       (push.iloc.0 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 202776))
     (push)
     (push.iloc.0 . 1)
     (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 202771)
     (if.true
       (push.const . "~a:~a")
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syntmp.scm" . 203842))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 3 "./boot/macro/syntmp.scm" . 203826)
       (push.subr.gloc.of string->symbol 1 "./boot/macro/syntmp.scm" . 203810)
       (extend . 1)
       (call
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syntmp.scm" . 204825)
         (if.true.ret)
         (extend.enclose+
           (2 0 . loop)
           (>n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 206882)
           (if.true
             (push.n+.iloc (0 . 0) -1 "./boot/macro/syntmp.scm" . 207912)
             (call
               (touch.gloc.of |make-infinite-list`6|)
               (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 207946)
               (apply.gloc.of |make-infinite-list`6| "./boot/macro/syntmp.scm" . 207926))
             (push)
             (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 207920)
             (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 207906))
           (push.iloc 5 . 0)
           (push.iloc 2 . 0)
           (push.iloc 3 . 1)
           (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syntmp.scm" . 209954)
           (push.iloc 5 . 1)
           (push.iloc 2 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syntmp.scm" . 210978))
         (push.iloc 2 . 1)
         (call
           (touch.gloc.of rank-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 205872))
         (push)
         (push.subr.gloc.of - 2 "./boot/macro/syntmp.scm" . 205863)
         (call
           (touch.gloc.of subform-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of subform-of "./boot/macro/syntmp.scm" . 205900))
         (push)
         (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 205849))
       (ret.iloc 0 . 0))
     (ret.iloc 0 . 0))
   (push.close
     (2 0 . traverse-escaped)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 219160))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 221220)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 221214))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 222244)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 222238))
         (ret.cons "./boot/macro/syntmp.scm" . 221208))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 223256)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 224300)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 224294))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 224280))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 217103))
   (enclose . 2)
   (call
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 230427))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 231451))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 232505))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 233520)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233509))
           (push)
           (push.const . ...)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233544))
           (push.cons)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 233501))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 228370))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 234523))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 235559)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 235569)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 235553))
         (push)
         (push.const . ...)
         (call
           (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 236594)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 236588))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/syntmp.scm" . 236577)
         (ret.cons "./boot/macro/syntmp.scm" . 235547))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 237595))
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 238625)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 239667)
           (push.iloc.0 . 1)
           (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 239649))
         (ret.cons "./boot/macro/syntmp.scm" . 238619))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 241703)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 241697))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 242727)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 242721))
         (ret.cons "./boot/macro/syntmp.scm" . 241691))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 243739)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 244783)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 244777))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 244763))
       (ret.iloc 0 . 0))
     (push.iloc 3 . 0)
     (push.const . 0)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 228370))
   (push)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 247843)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 247829)
   (push.iloc 2 . 2)
   (push.iloc.1 . 1)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 248866)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 248853)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 195595))
 (set.gloc.of |rewrite-template-ranks-vars`2|)
 (close
   (1 0 . make-infinite-list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 197658)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of set-cdr! 2 "./boot/macro/syntmp.scm" . 198680)
   (ret.iloc 0 . 0))
 (set.gloc.of |make-infinite-list`6|)
 (close
   (3 0 . adapt-to-rank-moved-vars)
   (call
     (touch.gloc.of contain-rank-moved-var?)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of contain-rank-moved-var? "./boot/macro/syntmp.scm" . 250889))
   (if.true
     (touch.gloc.of |rewrite-template-ranks-vars`2|)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of |rewrite-template-ranks-vars`2| "./boot/macro/syntmp.scm" . 251913))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 252937))
 (set.gloc.of adapt-to-rank-moved-vars)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 266268)
   (push.iloc.0 . 1)
   (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 266262)
   (if.true
     (touch.gloc.of |loop`13|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 267292)
     (push.iloc.0 . 1)
     (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 267286))
   (touch.gloc.of |loop`13|)
   (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269340)
   (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269356)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 269334))
 (set.gloc.of |loop`13|)
 (close
   (1 0 . remove-duplicates)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 262172)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 262183)
       (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 262166)
       (if.true.ret.const . #f)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 263201)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 263195))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 260109))
   (if.true.ret)
   (touch.gloc.of |loop`13|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`13| "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of |remove-duplicates`2|)
 (close
   (5 0 . transcribe-template)
   (push.close
     (0 0)
     (touch.gloc.of adapt-to-rank-moved-vars)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (call
       (touch.gloc.of |remove-duplicates`2|)
       (push.iloc.1 . 2)
       (apply.gloc.of |remove-duplicates`2| "./boot/macro/syntmp.scm" . 271440))
     (push)
     (apply.gloc.of adapt-to-rank-moved-vars "./boot/macro/syntmp.scm" . 271397))
   (push.close
     (3 0)
     (extend.unbound . 5)
     (push.close+
       (2 0 . expand-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 275474)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 277541)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 278569)
           (apply.iloc (4 . 4) "./boot/macro/syntmp.scm" . 278563))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 279587))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 281618)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 281618))
     (push.close+
       (2 0 . expand-ellipsis-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 286738)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 288805)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.iloc 4 . 4)
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 289837)
           (apply.gloc.of map "./boot/macro/syntmp.scm" . 289827))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 290851))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 292882)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 292882))
     (push.close
       (3 0 . expand-ellipsis-template)
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 1)
         (if.pair?
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.iloc (3 . 4) "./boot/macro/syntmp.scm" . 300064))
           (push)
           (iloc.0 . 0)
           (push.cons)
           (call
             (touch.gloc.of consume-ellipsis-vars)
             (push.iloc 4 . 1)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.gloc.of consume-ellipsis-vars "./boot/macro/syntmp.scm" . 301082))
           (push)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 300052))
         (iloc.0 . 1)
         (if.null?.ret.const)
         (push.iloc.0 . 1)
         (const . #t)
         (if.eq? (push.iloc.0 . 0) (ret.subr.gloc.of reverse "./boot/macro/syntmp.scm" . 303141))
         (push.const . "syntax template")
         (push.const . "subforms have different size of matched input")
         (push.const . template:)
         (push.iloc 5 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syntmp.scm" . 305172)
         (push.const . subforms:)
         (iloc 5 . 2)
         (push.cons)
         (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 305172))
       (push.const)
       (call
         (touch.gloc.of collect-ellipsis-vars)
         (push.iloc.1 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.gloc.of collect-ellipsis-vars "./boot/macro/syntmp.scm" . 298026))
       (push)
       (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 297995))
     (push.close+
       (3 0 . expand-escaped-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 311321))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 311318)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 312349)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 312342))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 313366))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 315431)
           (ret.null? "./boot/macro/syntmp.scm" . 315424))
         (if.true
           (push.const . |.&NIL|)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 317493)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 317468))
           (ret.cons "./boot/macro/syntmp.scm" . 316438))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 318517)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 318492))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 319541)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 319516))
         (ret.cons "./boot/macro/syntmp.scm" . 318486))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 320530)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 321593)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 321568))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 321554))
       (ret.iloc 0 . 0))
     (push.close
       (3 0 . expand-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 327705))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 327702)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 328733)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 328726))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 329750))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 330770))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 331824))
         (push.close
           (3 0)
           (call
             (push.gloc.of append)
             (call
               (push.iloc.0 . 0)
               (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 332873)
               (push.iloc.1 . 2)
               (apply.iloc (2 . 2) "./boot/macro/syntmp.scm" . 332842))
             (push)
             (apply.gloc.of apply "./boot/macro/syntmp.scm" . 332828))
           (push)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc (2 . 4) "./boot/macro/syntmp.scm" . 333852))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 332820))
         (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 325641))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 334866))
       (if.true
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 335906)
         (if.symbol?
           (call
             (touch.gloc.of rank-of)
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 336942)
             (push.iloc 2 . 1)
             (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 336933))
           (push)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 337962)
           (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 337954)
           (if.true
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 339007)
               (push.iloc.0 . 2)
               (apply.iloc+ (1 . 1) "./boot/macro/syntmp.scm" . 338986))
             (push)
             (call
               (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 340027)
               (push.iloc.0 . 1)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 340010))
             (push)
             (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 338978))
           (ret.const.unspec))
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 341024)
         (if.pair?
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 342075)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 342086)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 2) "./boot/macro/syntmp.scm" . 342049))
           (push)
           (call
             (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 343090)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 343073))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 342041))
         (ret.const.unspec))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 344082))
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 345137)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 345112))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 346153)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 346136))
         (ret.cons "./boot/macro/syntmp.scm" . 345106))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 348199)
           (ret.null? "./boot/macro/syntmp.scm" . 348192))
         (if.true
           (push.const . |.&NIL|)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 350253)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 350236))
           (ret.cons "./boot/macro/syntmp.scm" . 349206))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 351277)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 351260))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 352301)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 352284))
         (ret.cons "./boot/macro/syntmp.scm" . 351254))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 353298)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 354353)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 354336))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syntmp.scm" . 354322))
       (ret.iloc 0 . 0))
     (enclose . 5)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.1 . 0)
         (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 357395))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 357392)
       (if.false.ret)
       (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 357422)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 357417))
     (if.true
       (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 358436)
       (push.const . 0)
       (push.iloc.1 . 2)
       (apply.iloc+ (0 . 3) "./boot/macro/syntmp.scm" . 358411))
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (apply.iloc (0 . 4) "./boot/macro/syntmp.scm" . 359435))
   (apply.gloc.of |.call-with-values| "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of transcribe-template)
 (ret.const.unspec))

;
((close
   (2 0 . compiled->source)
   (push.const . syntax-rules)
   (push.iloc.0 . 0)
   (call
     (push.gloc.of |.fn4.1`4|)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 30753))
   (push)
   (ret.subr.gloc.of |.cons*| "./boot/macro/synrule.scm" . 29703))
 (set.gloc.of |compiled->source`2|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 30773)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 30782)
   (ret.subr.gloc.of |.list| "./boot/macro/synrule.scm" . 30758))
 (set.gloc.of |.fn4.1`4|)
 (close
   (2 0 . transcribe-compiled-templete)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 10265)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 11289)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synrule.scm" . 13332))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/synrule.scm" . 14359))
   (push)
   (extend . 4)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 21536)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
           (push.iloc 2 . 3)
           (apply.gloc.of rename-id "./boot/macro/synrule.scm" . 21556))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/synrule.scm" . 21546))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synrule.scm" . 21530))
     (push.iloc 2 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/synrule.scm" . 12313)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 17426))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (apply.gloc.of transcribe-template "./boot/macro/synrule.scm" . 23573))
   (push)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 25634)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 25660)
         (apply.gloc.of env-lookup "./boot/macro/synrule.scm" . 25644))
       (ret.cons "./boot/macro/synrule.scm" . 25628))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 24597))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 23565))
 (set.gloc.of |transcribe-compiled-templete`2|)
 (close
   (2 0 . transcribe-syntax-rules)
   (call
     (iloc.0 . 0)
     (if.pair?.ret.const . #t)
     (push.iloc.0 . 0)
     (push.const . "misplaced syntactic keyword")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 33801))
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 35858)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 35878)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 1)
       (if.true
         (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 39971)
         (push.const . "invalid syntax")
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of put-annotation)
           (call
             (touch.gloc.of |compiled->source`2|)
             (push.iloc 2 . 0)
             (push.cddr.iloc (3 . 1) "./boot/macro/synrule.scm" . 40044)
             (apply.gloc.of |compiled->source`2| "./boot/macro/synrule.scm" . 40020))
           (push)
           (push.iloc 2 . 1)
           (apply.gloc.of put-annotation "./boot/macro/synrule.scm" . 40004))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 39953))
       (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 40995)
       (push.const . "invalid syntax")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 40977))
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 42010)
     (extend . 1)
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 43037)
     (extend . 1)
     (call
       (call
         (touch.gloc.of match-pattern?)
         (push.iloc 5 . 0)
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (apply.gloc.of match-pattern? "./boot/macro/synrule.scm" . 44063))
       (if.false.ret)
       (touch.gloc.of bind-pattern)
       (push.iloc 5 . 0)
       (push.iloc.0 . 0)
       (push.iloc 4 . 0)
       (push.const)
       (apply.gloc.of bind-pattern "./boot/macro/synrule.scm" . 45087))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (touch.gloc.of |transcribe-compiled-templete`2|)
       (push.cdr.iloc (2 . 0) "./boot/macro/synrule.scm" . 47153)
       (push.iloc.0 . 0)
       (apply.gloc.of |transcribe-compiled-templete`2| "./boot/macro/synrule.scm" . 47123))
     (push.cdr.iloc (3 . 0) "./boot/macro/synrule.scm" . 48153)
     (apply.iloc+ (4 . 0) "./boot/macro/synrule.scm" . 48147))
   (push.cddr.iloc (2 . 1) "./boot/macro/synrule.scm" . 35898)
   (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 36871))
 (set.gloc.of transcribe-syntax-rules)
 (ret.const.unspec))
((close
   (3 0 . parse-syntax-rule)
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 52244)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 52268)
   (extend . 2)
   (call
     (touch.gloc.of check-pattern)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of check-pattern "./boot/macro/synrule.scm" . 53255))
   (call
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.const)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synrule.scm" . 54292))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of check-template)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of check-template "./boot/macro/synrule.scm" . 55305))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of collect-rename-ids)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-rename-ids "./boot/macro/synrule.scm" . 56360))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 56329))
 (set.gloc.of parse-syntax-rule)
 (ret.const.unspec))
((close
   (1 0 . make-remark)
   (call
     (touch.gloc.of get-annotation)
     (push.iloc.0 . 0)
     (apply.gloc.of get-annotation "./boot/macro/synrule.scm" . 63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.const . |.&SOURCE-PATH|)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/synrule.scm" . 65563)
     (iloc.0 . 0)
     (ret.cons "./boot/macro/synrule.scm" . 65557))
   (ret.const . #f))
 (set.gloc.of |make-remark`2|)
 (close
   (4 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of list "./boot/macro/synrule.scm" . 73754))
 (set.gloc.of |.fn3.1`3|)
 (close
   (4 0 . compile-syntax-rules)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of |make-remark`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |make-remark`2| "./boot/macro/synrule.scm" . 70673))
   (push)
   (call
     (push.close
       (1 0)
       (push.close
         (0 0)
         (touch.gloc.of parse-syntax-rule)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (push.iloc 2 . 3)
         (apply.gloc.of parse-syntax-rule "./boot/macro/synrule.scm" . 72775))
       (push.gloc.of |.fn3.1`3|)
       (apply.gloc.of |.call-with-values| "./boot/macro/synrule.scm" . 71702))
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 61445))
   (push)
   (subr.gloc.of cons 2 "./boot/macro/synrule.scm" . 61445)
   (ret.cons "./boot/macro/synrule.scm" . 61445))
 (set.gloc.of compile-syntax-rules)
 (ret.const.unspec))

;
((push.const . |.patvars|)
 (push.const)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 14337))
((close
   (3 0 . make-syntax-object)
   (push.const . type:syntax)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 16446))
 (set.gloc.of make-syntax-object)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-expr)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 17453))
 (set.gloc.of syntax-object-expr)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-renames)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 18477))
 (set.gloc.of syntax-object-renames)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-lexname)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 19501))
 (set.gloc.of syntax-object-lexname)
 (ret.const.unspec))
((close
   (1 0 . wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 23562)
   (const . type:syntax)
   (ret.eq? "./boot/macro/syncase.scm" . 23557))
 (set.gloc.of wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (2 0 . lookup-lexical-name)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 27665))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of renamed-id?)
     (push.iloc.0 . 0)
     (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 28686))
   (if.true (ret.iloc 0 . 0))
   (call
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/syncase.scm" . 29715))
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 29729))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 28679))
   (ret.iloc 2 . 0))
 (set.gloc.of lookup-lexical-name)
 (ret.const.unspec))
((close
   (1 0 . contain-non-id-wrapped-syntax-object?)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/macro/syncase.scm" . 37897))
 (set.gloc.of |contain-non-id-wrapped-syntax-object?`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 39964)
       (apply.gloc.of |loop`7| "./boot/macro/syncase.scm" . 39958))
     (if.true.ret)
     (touch.gloc.of |loop`7|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 39981)
     (apply.gloc.of |loop`7| "./boot/macro/syncase.scm" . 39975))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 40978)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 43033)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`7|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 44067)
         (apply.gloc.of |loop`7| "./boot/macro/syncase.scm" . 44061))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 45092)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 45085))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 42020)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 42017)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 42002))
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 46098))
   (if.true.ret.const . #f)
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 48146))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . unwrap-syntax)
   (call
     (touch.gloc.of |contain-non-id-wrapped-syntax-object?`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |contain-non-id-wrapped-syntax-object?`2| "./boot/macro/syncase.scm" . 50188))
   (if.true
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 55332)
               (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 55326))
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 56356)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 56350))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 57374)
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 58413)
             (apply.gloc.of for-each "./boot/macro/syncase.scm" . 58398))
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 59422))
           (if.true
             (call
               (touch.gloc.of syntax-object-renames)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 60460))
             (push)
             (extend . 1)
             (iloc.0 . 0)
             (if.null?.ret.const . #t)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 62529)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 62500)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 63548)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 63561)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 63524))
           (call
             (touch.gloc.of wrapped-syntax-object?)
             (push.iloc.0 . 0)
             (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 64542))
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 66635)
                 (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 66606)
                 (if.true.ret)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 67654)
                 (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 67662)
                 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 67630))
               (call
                 (touch.gloc.of syntax-object-renames)
                 (push.iloc.0 . 0)
                 (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 68648))
               (push)
               (apply.gloc.of for-each "./boot/macro/syncase.scm" . 65566))
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 69668))
             (push)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 69662))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 53269))
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable->alist "./boot/macro/syncase.scm" . 70677))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 73766)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73760))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 73787)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73781))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 74796)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 74814)
           (ret.eq? "./boot/macro/syncase.scm" . 74807))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 75813))
       (iloc.0 . 0)
       (if.symbol?
         (touch.gloc.of make-syntax-object)
         (push.iloc.0 . 0)
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 77875)
           (if.true.ret)
           (ret.const))
         (push)
         (push.const . #f)
         (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 77847))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 78871))
       (if.true
         (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 79902))
         (if.true (ret.iloc 0 . 0))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 80937))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 80931))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 81943)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 82991)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 82981))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 82967))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 71694))
   (ret.iloc 0 . 0))
 (set.gloc.of unwrap-syntax)
 (ret.const.unspec))
((close
   (2 0 . identical-global-macro?)
   (call
     (touch.gloc.of macro?)
     (push.iloc.0 . 0)
     (apply.gloc.of macro? "./boot/macro/syncase.scm" . 92174))
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 93208)
   (ret.eq? "./boot/macro/syncase.scm" . 93198))
 (set.gloc.of |identical-global-macro?`2|)
 (close
   (2 0 . unrename-syntax)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (touch.gloc.of annotated?)
         (push.iloc.0 . 0)
         (apply.gloc.of annotated? "./boot/macro/syncase.scm" . 97298))
       (if.true
         (touch.gloc.of annotate)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 98344)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 98338))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 98361)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 98355))
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 98322))
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 99358)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 99352))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 99375)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 99369))
       (ret.cons "./boot/macro/syncase.scm" . 99346))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 101402))
       (push)
       (call
         (touch.gloc.of original-id)
         (push.iloc.0 . 0)
         (apply.gloc.of original-id "./boot/macro/syncase.scm" . 102424))
       (push)
       (extend . 2)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/syncase.scm" . 103447))
       (if.true (ret.iloc 0 . 1))
       (call
         (touch.gloc.of |identical-global-macro?`2|)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of |identical-global-macro?`2| "./boot/macro/syncase.scm" . 104471))
       (if.true (ret.iloc 0 . 1))
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 106510)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 107558)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 107548))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 107534))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 95237))
 (set.gloc.of unrename-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 116774)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 116768))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 116795)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 116789))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 117804)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 117822)
           (ret.eq? "./boot/macro/syncase.scm" . 117815))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 118821))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 119831)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 120879)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 120869))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 120855))
       (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 121879))
       (if.true
         (call
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 122917))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?.ret.const . #t)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 124990)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 124961)
           (if.true.ret)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 126009)
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 126022)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 125985))
         (touch.gloc.of syntax-object-expr)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 126999))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 128023))
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 130116)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 130087)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 131135)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 131143)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 131111))
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 132129))
           (push)
           (apply.gloc.of for-each "./boot/macro/syncase.scm" . 129047))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 133149))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 133143))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 114702))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 135190)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 112645))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.flatten-syntax|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 111619))
((close
   (3 1)
   (extend.enclose+
     (2 0 . match)
     (call
       (touch.gloc.of match-pattern?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/syncase.scm" . 142350))
     (if.false.ret)
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc 2 . 2)
     (push.const)
     (apply.gloc.of bind-pattern "./boot/macro/syncase.scm" . 143374))
   (call
     (touch.gloc.of unwrap-syntax)
     (push.iloc.1 . 1)
     (apply.gloc.of unwrap-syntax "./boot/macro/syncase.scm" . 145425))
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (ret.subr.gloc.of car "./boot/macro/syncase.scm" . 148529))
       (push)
       (push.const . "invalid syntax")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 148493))
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149531)
     (push.subr.gloc.of cadr 1 "./boot/macro/syncase.scm" . 151581)
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149531)
     (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 152603)
     (extend . 2)
     (call
       (push.iloc 3 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 149531)
       (push.subr.gloc.of car 1 "./boot/macro/syncase.scm" . 150554)
       (apply.iloc+ (4 . 0) "./boot/macro/syncase.scm" . 153629))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.1 . 0)
       (if.false.ret.const . #t)
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 156712)
       (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 156704))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 157725)
       (apply.iloc (1 . 1) "./boot/macro/syncase.scm" . 157719))
     (push.cdr.iloc (2 . 0) "./boot/macro/syncase.scm" . 158749)
     (apply.iloc+ (3 . 0) "./boot/macro/syncase.scm" . 158743))
   (push.iloc 3 . 3)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 146439))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax-dispatch|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 137217))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`23|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 186401)
       (apply.gloc.of |loop`23| "./boot/macro/syncase.scm" . 186395))
     (push)
     (call
       (touch.gloc.of |loop`23|)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 186422)
       (apply.gloc.of |loop`23| "./boot/macro/syncase.scm" . 186416))
     (push)
     (extend . 2)
     (call
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 187429)
       (iloc.0 . 0)
       (if.not.eq?.ret.const . #f)
       (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 187447)
       (iloc.0 . 1)
       (ret.eq? "./boot/macro/syncase.scm" . 187442))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 188448))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 189458)
   (if.true
     (call
       (touch.gloc.of |loop`23|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 190502)
       (apply.gloc.of |loop`23| "./boot/macro/syncase.scm" . 190496))
     (push)
     (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 190482))
   (push.iloc.0 . 0)
   (const . |.&NIL|)
   (if.eq?.ret.const)
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`23|)
 (close
   (2 0 . partial-wrap-syntax-object)
   (extend.enclose+
     (1 0 . loop)
     (call
       (touch.gloc.of |contain-wrapped-syntax-object?`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of |contain-wrapped-syntax-object?`2| "./boot/macro/syncase.scm" . 197650))
     (if.true
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 199720)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 199714))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 199741)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 199735))
         (push)
         (extend . 2)
         (call
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 200748)
           (iloc.0 . 0)
           (if.not.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 200766)
           (iloc.0 . 1)
           (ret.eq? "./boot/macro/syncase.scm" . 200761))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 201767))
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (const . |.&NIL|)
     (if.eq?
       (touch.gloc.of make-syntax-object)
       (push.const)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 204818))
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 206894)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 206866))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 207890)
     (if.true
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of |rewrite-nil`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |rewrite-nil`2| "./boot/macro/syncase.scm" . 208934))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 208914))
     (iloc.0 . 0)
     (if.pair?
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of |rewrite-nil`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |rewrite-nil`2| "./boot/macro/syncase.scm" . 210982))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 210962))
     (iloc.0 . 0)
     (if.null?.ret.const)
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 214034))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 196617))
 (set.gloc.of |partial-wrap-syntax-object`2|)
 (close
   (1 0 . contain-wrapped-syntax-object?)
   (touch.gloc.of |loop`9|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`9| "./boot/macro/syncase.scm" . 171017))
 (set.gloc.of |contain-wrapped-syntax-object?`2|)
 (close
   (1 0 . emit)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 165904))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 166933))
 (set.gloc.of |emit`2|)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (car.iloc (0 . 0) "./boot/macro/syncase.scm" . 173085)
     (if.null?.ret.const . #t)
     (call
       (touch.gloc.of |loop`9|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 173102)
       (apply.gloc.of |loop`9| "./boot/macro/syncase.scm" . 173096))
     (if.true.ret)
     (touch.gloc.of |loop`9|)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 173119)
     (apply.gloc.of |loop`9| "./boot/macro/syncase.scm" . 173113))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 174098)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 176153)
       (if.false.ret)
       (call
         (touch.gloc.of |loop`9|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 177187)
         (apply.gloc.of |loop`9| "./boot/macro/syncase.scm" . 177181))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 178212)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 178205))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 175140)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 175137)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 175122))
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 180242))
 (set.gloc.of |loop`9|)
 (close
   (1 0 . rewrite-nil)
   (touch.gloc.of |loop`23|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`23| "./boot/macro/syncase.scm" . 184329))
 (set.gloc.of |rewrite-nil`2|)
 (close
   (5 0 . syntax-transcribe)
   (iloc.0 . 1)
   (if.null?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 217097))
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 219153))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/syncase.scm" . 221201))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of rename-id "./boot/macro/syncase.scm" . 223276))
       (ret.cons "./boot/macro/syncase.scm" . 223267))
     (call
       (touch.gloc.of collect-rename-ids)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 224278))
     (push)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 223249))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 226346)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 226376)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 226356))
       (ret.cons "./boot/macro/syncase.scm" . 226340))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 226321))
   (push)
   (extend . 1)
   (call
     (iloc 4 . 4)
     (if.null? (ret.const))
     (iloc 3 . 0)
     (if.null?.ret.const)
     (touch.gloc.of filter)
     (push.gloc.of values)
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 234545)
         (push.iloc 5 . 4)
         (push.subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 235568)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 234545)
             (push.iloc 5 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 237633))
           (push)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 237666)
           (if.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 238663)
           (call
             (touch.gloc.of make-out-of-context)
             (push.iloc 6 . 1)
             (apply.gloc.of make-out-of-context "./boot/macro/syncase.scm" . 238671))
           (ret.cons "./boot/macro/syncase.scm" . 238657))
         (ret.const . #f))
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 218121))
     (push)
     (apply.gloc.of filter "./boot/macro/syncase.scm" . 218121))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc 5 . 1)
     (push.iloc 5 . 2)
     (push.iloc 5 . 0)
     (push.iloc 2 . 0)
     (push.gloc.of |emit`2|)
     (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 241687))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 243732))
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (const . |.&NIL|)
   (if.eq?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 245780))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 247857)
       (if.true.ret)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 247884)
       (if.true.ret)
       (ret.const))
     (push)
     (push.iloc 6 . 3)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 247828))
   (touch.gloc.of |partial-wrap-syntax-object`2|)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of extend-env)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 249909))
   (push)
   (apply.gloc.of |partial-wrap-syntax-object`2| "./boot/macro/syncase.scm" . 249876))
 (set.gloc.of syntax-transcribe)
 (ret.const.unspec))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 253957))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/i0|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 251905))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 258086)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 258053))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/i1|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 256001))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 262149))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/i2|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 260097))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 266278)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 266245))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/i3|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 264193))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 270341))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/c0|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 268289))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 274437))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/c1|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 272385))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.iloc.0 . 2)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 278533))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/c2|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 276481))
((close
   (4 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.iloc.0 . 3)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 282629))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.syntax/c3|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 280577))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 290858)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 290852))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 290875)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 290869))
       (ret.cons "./boot/macro/syncase.scm" . 290846))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 291877))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 290827))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 292882)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 292920)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 292910))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 292896))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 289801))
 (set.gloc.of |rewrite`2|)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
   (call
     (touch.gloc.of make-pattern-variable)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
     (apply.gloc.of make-pattern-variable "./boot/macro/syncase.scm" . 287749))
   (ret.cons "./boot/macro/syncase.scm" . 287749))
 (set.gloc.of |.fn2.1`2|)
 (close
   (2 0 . expand-syntax-case)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 287749)
     (ret.subr.gloc.of |.list?| "./boot/macro/syncase.scm" . 287749))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 287749)
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
     (extend . 2)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 287749)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 287749))
     (push)
     (extend . 1)
     (call
       (call
         (push.iloc.0 . 0)
         (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 287749)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 0)
         (apply.gloc.of every1 "./boot/macro/syncase.scm" . 287749))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "invalid literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 287749))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 0)
         (apply.gloc.of unique-id-list? "./boot/macro/syncase.scm" . 287749))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "duplicate literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 287749))
     (call
       (push.const . _)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 287749)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "_ in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 287749))
     (call
       (push.const . ...)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 287749)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "... in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 287749))
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of lookup-lexical-name)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 287749))
         (ret.cons "./boot/macro/syncase.scm" . 287749))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 287749))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of |rewrite`2|)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 287749))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . parse-pattern)
       (call
         (touch.gloc.of |rewrite`2|)
         (call
           (touch.gloc.of unrename-syntax)
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 287749))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of |rewrite`2| "./boot/macro/syncase.scm" . 287749))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 287749))
       (call
         (touch.gloc.of check-pattern)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of check-pattern "./boot/macro/syncase.scm" . 287749))
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of |.fn2.1`2|)
           (call
             (touch.gloc.of collect-vars-ranks)
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.const . 0)
             (push.const)
             (apply.gloc.of collect-vars-ranks "./boot/macro/syncase.scm" . 287749))
           (push)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 287749))
         (push)
         (push.iloc 7 . 1)
         (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 287749))
       (push)
       (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 287749))
     (touch.gloc.of annotate)
     (push.const . |.syntax-dispatch|)
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 287749))
     (push)
     (call
       (touch.gloc.of expand-form)
       (push.iloc 4 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 287749))
     (push)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 287749)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 287749)
           (ret.pair? "./boot/macro/syncase.scm" . 287749))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
           (ret.null? "./boot/macro/syncase.scm" . 287749))
         (if.true
           (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
           (extend . 2)
           (push.close
             (0 0)
             (push.iloc.1 . 1)
             (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 287749))
           (push.close
             (2 0)
             (push.const . |.list|)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 287749)
             (push.const . #f)
             (call
               (touch.gloc.of expand-form)
               (push.const . |.LAMBDA|)
               (push.const |.patvars|)
               (push.iloc.1 . 0)
               (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 287749)
               (push.iloc.0 . 1)
               (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 287749))
             (push)
             (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 287749))
           (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 287749))
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of |.cdddr| 1 "./boot/macro/syncase.scm" . 287749)
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.caddr| 1 "./boot/macro/syncase.scm" . 287749)
         (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 287749)
         (extend . 3)
         (push.close
           (0 0)
           (push.iloc.1 . 2)
           (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 287749))
         (push.close
           (2 0)
           (push.const . |.list|)
           (push.const . quote)
           (push.iloc.0 . 0)
           (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 287749)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 1)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 287749)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 287749))
           (push)
           (call
             (touch.gloc.of expand-form)
             (push.const . |.LAMBDA|)
             (push.const |.patvars|)
             (push.iloc.1 . 0)
             (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 287749)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 287749))
           (push)
           (ret.subr.gloc.of |.list| "./boot/macro/syncase.scm" . 287749))
         (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 287749))
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 287749))
     (push)
     (push.subr.gloc.of |.cons*| 5 "./boot/macro/syncase.scm" . 287749)
     (push.iloc 4 . 1)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 287749))
   (push.const . syntax-case)
   (push.const . "invalid syntax")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 287749))
 (set.gloc.of expand-syntax-case)
 (ret.const.unspec))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 352298)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 352292))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 352315)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 352309))
       (ret.cons "./boot/macro/syncase.scm" . 352286))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 353317))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 352267))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 354322)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 354360)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 354350))
       (push)
       (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 354336))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 351241))
 (set.gloc.of |rewrite`2|)
 (close
   (2 0 . expand-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 349189)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 349189)
     (ret.null? "./boot/macro/syncase.scm" . 349189))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 349189)
     (extend . 1)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 349189))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 349189))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of pattern-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of pattern-variable? "./boot/macro/syncase.scm" . 349189))
           (if.false.ret)
           (push.iloc.1 . 0)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 349189)
           (ret.cons "./boot/macro/syncase.scm" . 349189))
         (call
           (touch.gloc.of collect-unique-ids)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-unique-ids "./boot/macro/syncase.scm" . 349189))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 349189))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 349189))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of check-template)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-template "./boot/macro/syncase.scm" . 349189))
     (call
       (touch.gloc.of expand-form)
       (push.const . |.patvars|)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 349189))
     (push)
     (extend . 1)
     (iloc 2 . 0)
     (if.symbol?
       (call
         (touch.gloc.of lookup-lexical-name)
         (push.iloc 3 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 349189))
       (push)
       (extend . 1)
       (push.iloc 3 . 0)
       (iloc.0 . 0)
       (if.eq?
         (iloc 2 . 0)
         (if.null?
           (touch.gloc.of annotate)
           (push.const . |.syntax/i0|)
           (push.iloc.1 . 0)
           (push.const . quote)
           (push.iloc 3 . 0)
           (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
           (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 349189)
           (push.iloc 5 . 0)
           (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
         (touch.gloc.of annotate)
         (push.const . |.syntax/i1|)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
         (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 349189)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . |.syntax/i2|)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
         (push.const . quote)
         (push.iloc.0 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
         (push.subr.gloc.of |.list| 4 "./boot/macro/syncase.scm" . 349189)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
       (touch.gloc.of annotate)
       (push.const . |.syntax/i3|)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.subr.gloc.of |.list| 4 "./boot/macro/syncase.scm" . 349189)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.iloc.0 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 349189))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of renamed-id?)
             (push.iloc.0 . 0)
             (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 349189))
           (if.false.ret)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (if.eq?.ret.const . #f)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (ret.cons "./boot/macro/syncase.scm" . 349189))
         (call
           (touch.gloc.of collect-rename-ids)
           (push.iloc 2 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 349189))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 349189))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 349189))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . |.syntax/c0|)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
         (push.subr.gloc.of |.list| 3 "./boot/macro/syncase.scm" . 349189)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
       (touch.gloc.of annotate)
       (push.const . |.syntax/c1|)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.const . quote)
       (push.iloc 2 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.subr.gloc.of |.list| 4 "./boot/macro/syncase.scm" . 349189)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
     (iloc 2 . 0)
     (if.null?
       (touch.gloc.of annotate)
       (push.const . |.syntax/c2|)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
       (push.subr.gloc.of |.list| 4 "./boot/macro/syncase.scm" . 349189)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
     (touch.gloc.of annotate)
     (push.const . |.syntax/c3|)
     (push.iloc.1 . 0)
     (push.const . quote)
     (push.iloc 3 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
     (push.const . quote)
     (push.iloc 2 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
     (push.const . quote)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/macro/syncase.scm" . 349189)
     (push.subr.gloc.of |.list| 5 "./boot/macro/syncase.scm" . 349189)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 349189))
   (push.const . syntax)
   (push.const . "expected exactly one datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 349189))
 (set.gloc.of expand-syntax)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`5|)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 406558)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 406552))
     (push)
     (call
       (touch.gloc.of |loop`5|)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 406579)
       (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 406573))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 407588)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 407606)
       (ret.eq? "./boot/macro/syncase.scm" . 407599))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 408605))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 409615)
   (if.true
     (call
       (push.gloc.of |loop`5|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 410663)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 410653))
     (push)
     (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 410639))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 411663))
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 412693))
     (push)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 412687))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . syntax->datum)
   (touch.gloc.of strip-rename-suffix)
   (call
     (touch.gloc.of |loop`5|)
     (push.iloc.0 . 0)
     (apply.gloc.of |loop`5| "./boot/macro/syncase.scm" . 404486))
   (push)
   (apply.gloc.of strip-rename-suffix "./boot/macro/syncase.scm" . 404486))
 (set.gloc.of syntax->datum)
 (ret.const.unspec))
((close
   (2 0 . datum->syntax)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 417801))
   (if.false.call
     (push.const . datum->syntax)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 418861)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 418825))
   (call
     (touch.gloc.of retrieve-rename-suffix)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 419883))
     (push)
     (apply.gloc.of retrieve-rename-suffix "./boot/macro/syncase.scm" . 419859))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-renames)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 420891))
     (if.null?
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 421908))
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 422932))
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 4)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 428071)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 428065))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 428088)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 428082))
         (ret.cons "./boot/macro/syncase.scm" . 428059))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 429083)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 430131)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 430121))
         (push)
         (apply.gloc.of list->vector "./boot/macro/syncase.scm" . 430107))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 432162)
         (if.true.ret)
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/syncase.scm" . 434252)
         (push.iloc 2 . 0)
         (push.subr.gloc.of string-append 2 "./boot/macro/syncase.scm" . 434237)
         (push.subr.gloc.of string->symbol 1 "./boot/macro/syncase.scm" . 434221)
         (extend . 1)
         (push.iloc 3 . 2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syncase.scm" . 435236)
         (call
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 436278))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq?
             (push.iloc 4 . 3)
             (push.iloc.1 . 0)
             (call
               (touch.gloc.of env-lookup)
               (push.iloc 4 . 1)
               (push.iloc 2 . 0)
               (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 439370))
             (push)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 439341))
           (push.iloc 4 . 3)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 442413))
         (ret.iloc 0 . 0))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 426002))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 446515)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 446505)
       (if.true.ret)
       (ret.const))
     (push)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 446477))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.iloc.1 . 3)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 447525)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 447501))
 (set.gloc.of datum->syntax)
 (ret.const.unspec))
((close
   (1 0 . identifier?)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 451594))
   (if.false.ret)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 452627))
   (push)
   (ret.subr.gloc.of symbol? "./boot/macro/syncase.scm" . 452618))
 (set.gloc.of identifier?)
 (ret.const.unspec))
((close
   (2 0 . bound-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 456713))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 457778)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 457737))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 458761))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 459826)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 459785))
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 460810))
   (push)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 460835))
   (ret.eq? "./boot/macro/syncase.scm" . 460805))
 (set.gloc.of bound-identifier=?)
 (ret.const.unspec))
((close
   (2 0 . free-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 464905))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 465969)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 465929))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 466953))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 468017)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 467977))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 469008))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 470034))
   (push)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 471058))
   (push)
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 472103))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 472082))
   (push)
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 473127))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 473106))
   (push)
   (extend . 4)
   (call (iloc.0 . 0) (if.false.ret) (ret.iloc 0 . 1))
   (if.true (push.iloc.0 . 0) (iloc.0 . 1) (ret.eq? "./boot/macro/syncase.scm" . 475149))
   (push.iloc.0 . 2)
   (iloc.0 . 3)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 0)
   (iloc.0 . 3)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 2)
   (iloc.0 . 1)
   (ret.eq? "./boot/macro/syncase.scm" . 478225))
 (set.gloc.of free-identifier=?)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of make-syntax-object)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syncase.scm" . 484394))
   (push)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 484374))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0 . generate-temporaries)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 482313)
   (if.false.call
     (push.const . generate-temporaries)
     (push.const . "expected list, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 483380)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 483337))
   (push.gloc.of |.fn1.1`1|)
   (push.iloc.0 . 0)
   (apply.gloc.of map "./boot/macro/syncase.scm" . 484357))
 (set.gloc.of generate-temporaries)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer)
   (touch.gloc.of make-variable-transformer-token)
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 490514))
       (if.true (ret.iloc 0 . 0))
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 492562))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 490504))
   (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 488453))
 (set.gloc.of make-variable-transformer)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer-token)
   (push.const . type:variable-transformer-token)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 496645))
 (set.gloc.of make-variable-transformer-token)
 (ret.const.unspec))
((close
   (1 0 . variable-transformer-token?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 500746)
   (const . type:variable-transformer-token)
   (ret.eq? "./boot/macro/syncase.scm" . 500741))
 (set.gloc.of variable-transformer-token?)
 (ret.const.unspec))
((close
   (1 1)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 0)
     (apply.gloc.of |.flatten-syntax| "./boot/macro/syncase.scm" . 509979))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 1) "./boot/macro/syncase.scm" . 511015)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 511003))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.close
     (1 0 . thunk)
     (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (2 . 0) "./boot/macro/syncase.scm" . 506912))
     (push.gloc.of |.fn1.1`1|)
     (apply.gloc.of call-with-values "./boot/macro/syncase.scm" . 505876))
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of procedure? 1 "./boot/macro/syncase.scm" . 512014)
   (if.true
     (push.close
       (0 0)
       (touch.gloc.of closure-arity)
       (push.iloc 2 . 0)
       (apply.gloc.of closure-arity "./boot/macro/syncase.scm" . 513064))
     (push.close
       (2 0)
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.0 . 1)
       (if.false.ret)
       (=n.iloc (0 . 0) 1 "./boot/macro/syncase.scm" . 514079)
       (if.false.ret)
       (=n.iloc (0 . 1) 0 "./boot/macro/syncase.scm" . 514091)
       (if.false.ret)
       (ret.iloc 1 . 0))
     (apply.gloc.of |.call-with-values| "./boot/macro/syncase.scm" . 504837))
   (call
     (touch.gloc.of variable-transformer-token?)
     (push.iloc.1 . 0)
     (apply.gloc.of variable-transformer-token? "./boot/macro/syncase.scm" . 515086))
   (if.true
     (push.iloc.1 . 0)
     (push.const . 1)
     (subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 516121)
     (set.iloc 1 . 0)
     (touch.gloc.of make-variable-transformer-token)
     (push.iloc.0 . 0)
     (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 517134))
   (ret.iloc 1 . 0))
 (set.gloc.of |.fn2.1`2|)
 (push.const . |.transformer-thunk|)
 (push.gloc.of |.fn2.1`2|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 507925))

;
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/library.scm" . 5150))
 (set.gloc.of scheme-library-paths)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 6176))
 (set.gloc.of scheme-library-exports)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 7201))
 (set.gloc.of scheme-library-versions)
 (ret.const.unspec))
((close
   (2 0 . symbol-list->string)
   (push.gloc.of string-append)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 14371)
       (if.symbol?
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 16438)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/library.scm" . 16422)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 17452)
           (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 17446))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/library.scm" . 16416)
         (ret.cons "./boot/macro/library.scm" . 15386))
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 19488)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 19482))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 12305))
   (push)
   (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 10243)
   (apply.gloc.of apply "./boot/macro/library.scm" . 10243))
 (set.gloc.of symbol-list->string)
 (ret.const.unspec))
((close
   (1 0 . generate-library-id)
   (touch.gloc.of library-name->id)
   (push.const . #f)
   (push.iloc.0 . 0)
   (apply.gloc.of library-name->id "./boot/macro/library.scm" . 23557))
 (set.gloc.of generate-library-id)
 (ret.const.unspec))
((close
   (2 0 . library-name->id)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.true
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 31809))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 31757))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 32781))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 34830)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 34848)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 34843))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 35853))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.1 . 1)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 36919))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 36893))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 36877))
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 37932)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 37929)
     (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 37913)
     (extend . 1)
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 38931))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 39997))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 39971))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 39955))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 40979))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 41993))
 (set.gloc.of library-name->id)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 55310)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 55325)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 55338))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-name->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 50244))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 50189))
     (push.const . library)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 51213))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 57358)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 57376)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 57371))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 58384))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 60468)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 60465)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 60449)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 60444)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . #f)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 62494)
       (if.false.ret)
       (touch.gloc.of every1)
       (push.gloc.of |exact-nonnegative-integer?`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 62507))
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 63518))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 64521))
 (set.gloc.of library-name->version)
 (ret.const.unspec))
((close
   (2 0 . library-reference->name)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 72769))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 72717))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 73741))
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.1 . 1)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 75788))
   (if.true (ret.iloc 1 . 1))
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 77866)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 77863)
   (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 77848)
   (extend . 1)
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 78869))
   (if.true (ret.iloc 0 . 0))
   (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 79898))
 (set.gloc.of library-reference->name)
 (ret.const.unspec))
((close
   (2 0 . flatten-library-reference)
   (call
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 83982)
       (if.false.ret)
       (push.iloc.0 . 1)
       (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 83999)
       (ret.subr.gloc.of not "./boot/macro/library.scm" . 83994))
     (if.true.ret)
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 85053))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 85001))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 83973)
     (if.false.ret)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (touch.gloc.of flatten-library-reference)
     (push.iloc.0 . 0)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 83973))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 83973))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 83973))
   (ret.iloc 0 . 1))
 (set.gloc.of flatten-library-reference)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 102414)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 102429)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 102442))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (2 0 . library-reference->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . import)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 97347))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 97293))
     (push.const . import)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 98317))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 104462)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 104479)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 104474))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 105488))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 106552)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 106549)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 106534)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 106529)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 107550)
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 108579))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 109577))
 (set.gloc.of library-reference->version)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 116750)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 116765)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 116778))
 (set.gloc.of |exact-nonnegative-integer?`2|)
 (close
   (4 0 . test-library-versions)
   (call
     (extend.enclose
       (1 0 . loop)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 119819)
         (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 119819))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . not)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
           (apply.iloc (2 . 0) "./boot/macro/library.scm" . 119819))
         (push)
         (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . or)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . and)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of every1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
       (extend.enclose
         (2 0 . loop)
         (call
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/macro/library.scm" . 119819)
             (if.false.ret)
             (push.iloc.0 . 1)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
           (if.true.ret)
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 5 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (iloc.0 . 1)
         (if.null?.ret.const . #t)
         (push.iloc.0 . 0)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (subr.gloc.of >= 2 "./boot/macro/library.scm" . 119819)
         (if.false.ret)
         (touch.gloc.of every2)
         (push.close
           (2 0)
           (call
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (0 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of |.list?| "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 1)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (ret.null? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . not)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (call
               (push.iloc 2 . 0)
               (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
               (apply.iloc (4 . 0) "./boot/macro/library.scm" . 119819))
             (push)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . >=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of >= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . <=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of <= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . and)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of every1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . or)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
           (call
             (touch.gloc.of |exact-nonnegative-integer?`2|)
             (push.iloc 2 . 1)
             (apply.gloc.of |exact-nonnegative-integer?`2| "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (ret.subr.gloc.of = "./boot/macro/library.scm" . 119819))
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 8 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 8 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (apply.gloc.of every2 "./boot/macro/library.scm" . 119819))
       (push.iloc 4 . 3)
       (push.iloc 2 . 0)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 119819))
     (push.iloc.1 . 2)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 118793))
   (if.true.ret)
   (push.const . import)
   (push.const . "mismatch between version reference ~a and current version ~a")
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 142363)
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 143387))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 141321))
 (set.gloc.of test-library-versions)
 (ret.const.unspec))
((close
   (1 0 . make-shield-id-table)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (call
     (touch.gloc.of make-unbound)
     (apply.gloc.of make-unbound "./boot/macro/library.scm" . 147500))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 148510))
     (push.gloc.of coreform-primitives)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 148487))
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 151574)
           (apply.iloc (1 . 0) "./boot/macro/library.scm" . 151568))
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 152598)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 152592))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 154640))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 155664)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 156694)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 156688))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 149511))
   (ret.iloc 0 . 0))
 (set.gloc.of make-shield-id-table)
 (ret.const.unspec))
((close
   (3 0 . verify-no-unbound-id)
   (extend.enclose
     (1 0 . find-expression)
     (push.close
       (1 0)
       (extend.enclose
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq?.ret.const . #t)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 169002)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 168996)
         (if.true.ret.const . #f)
         (call
           (touch.gloc.of any1)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 170015))
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 171039))
       (call
         (push.car.iloc (4 . 1) "./boot/macro/library.scm" . 165933)
         (const . begin)
         (if.eq? (push.iloc 4 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 165951))
         (ret.iloc 4 . 1))
       (push)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 165908))
     (apply.gloc.of call/cc "./boot/macro/library.scm" . 163847))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (call
       (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 174112)
       (const . begin)
       (if.eq? (push.iloc 2 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 174130))
       (ret.iloc 2 . 1))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 175134))
       (iloc.0 . 0)
       (if.pair?
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 177178)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 177172)
         (if.true.ret)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/library.scm" . 178196))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 174087))
   (call
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 180262)
         (call
           (touch.gloc.of current-primitive-prefix)
           (apply.gloc.of current-primitive-prefix "./boot/macro/library.scm" . 180270))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 180245))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 181286)
         (call
           (touch.gloc.of current-rename-delimiter)
           (apply.gloc.of current-rename-delimiter "./boot/macro/library.scm" . 181294))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 181269))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 182310)
         (call
           (touch.gloc.of current-library-suffix)
           (apply.gloc.of current-library-suffix "./boot/macro/library.scm" . 182318))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 182293))
       (if.true.ret)
       (push.iloc 3 . 2)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 183351)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 183317)
       (if.true.ret)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 184347)
       (push.gloc.of coreform-primitives)
       (subr.gloc.of memq 2 "./boot/macro/library.scm" . 184341)
       (if.true.ret)
       (call
         (touch.gloc.of current-macro-expression)
         (push.const . #f)
         (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 186391))
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 188518)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 188467)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 189491))
       (push)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 190532)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 190515))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/library.scm" . 187415))
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 191503)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 179207))
   (ret.iloc 2 . 1))
 (set.gloc.of verify-no-unbound-id)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (cadr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (ret.cons "./boot/macro/library.scm" . 197639))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 197639))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 197639))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . parse-exports)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of reverse "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 197639))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 197639)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 197639)
       (extend . 2)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn1.1`1|)
           (push.iloc.0 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 197639))
         (if.true.ret)
         (push.const . export)
         (push.const . "malformed export spec")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 197639)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
       (push.iloc.0 . 0)
       (call
         (push.gloc.of |.fn2.1`2|)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/library.scm" . 197639))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 197639)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 197639))
     (push.const . export)
     (push.const . "malformed export spec")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 2 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 196613))
 (set.gloc.of parse-exports)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 231431))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 231431))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . parse-imports)
   (extend.unbound . 2)
   (push.close
     (3 0 . check-unbound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 219161)
       (if.true.ret)
       (push.const . import)
       (push.const . "attempt to reference unexported identifier ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 220211)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 220271))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 220185))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 218121))
   (push.close
     (3 0 . check-bound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 226330)
       (if.false.ret)
       (push.const . import)
       (push.const . "duplicate import identifiers ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 227380)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 227426))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 227354))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 225289))
   (enclose . 2)
   (extend.enclose
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 231431)
       (ret.pair? "./boot/macro/library.scm" . 231431))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 231431)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 231431)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (ret.subr.gloc.of memq "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 231431)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of memq 2 "./boot/macro/library.scm" . 231431)
           (ret.subr.gloc.of not "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 231431)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of |.fn1.1`1|)
           (push.iloc.1 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "malformed import set")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (call
           (call
             (touch.gloc.of unique-id-list?)
             (call
               (push.gloc.of car)
               (push.iloc.1 . 1)
               (apply.gloc.of map "./boot/macro/library.scm" . 231431))
             (push)
             (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
           (if.false.ret)
           (touch.gloc.of unique-id-list?)
           (call
             (push.gloc.of cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of map "./boot/macro/library.scm" . 231431))
           (push)
           (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "duplicate identifers in rename specs")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of cadr)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 1) "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of car)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 231431)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
             (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
             (ret.cons "./boot/macro/library.scm" . 231431))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 231431)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 231431)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.close
           (1 0)
           (push.const . "~a~a")
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of string->symbol 1 "./boot/macro/library.scm" . 231431)
           (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (ret.cons "./boot/macro/library.scm" . 231431))
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
           (push.const)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
         (push)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 2 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (call
         (touch.gloc.of flatten-library-reference)
         (push.iloc 5 . 0)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 231431))
       (push)
       (call
         (touch.gloc.of library-reference->version)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->version "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of |.require-scheme-library| "./boot/macro/library.scm" . 231431))
       (call
         (touch.gloc.of library-name->id)
         (push.iloc 7 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-name->id "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (iloc.1 . 1)
           (if.false.ret)
           (call
             (touch.gloc.of scheme-library-versions)
             (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 231431))
           (push)
           (push.iloc.0 . 0)
           (push.const . #f)
           (ret.subr.gloc.of core-hashtable-ref "./boot/macro/library.scm" . 231431))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of test-library-versions)
           (push.iloc 9 . 0)
           (push.iloc 3 . 0)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of test-library-versions "./boot/macro/library.scm" . 231431))
         (ret.const.unspec))
       (push.iloc 3 . 0)
       (call
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 231431)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (ret.subr.gloc.of append "./boot/macro/library.scm" . 231431))
         (push.const . import)
         (push.const . "attempt to import undefined library")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 9 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (6 . 0) "./boot/macro/library.scm" . 231431))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 4 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
   (push.iloc 2 . 1)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 230405))
 (set.gloc.of parse-imports)
 (ret.const.unspec))
((close
   (2 0 . parse-depends)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 292871)
       (ret.pair? "./boot/macro/library.scm" . 292871))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 292871)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 292871)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 292871)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 292871)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 292871)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 292871)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of flatten-library-reference)
           (push.iloc 3 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
           (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 292871))
         (push)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 292871))
       (push)
       (iloc.1 . 1)
       (push.cons)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 3 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 292871))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 292871))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 291845))
 (set.gloc.of parse-depends)
 (ret.const.unspec))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 319506))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 320540)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 320530))
   (if.true
     (touch.gloc.of |loop`8|)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 321560)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 321583)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 321554))
   (touch.gloc.of |loop`8|)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 323608)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 323624)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 323602))
 (set.gloc.of |loop`8|)
 (close
   (1 0 . permute-env)
   (touch.gloc.of |loop`8|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 317465)
   (push.const)
   (push.const)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 317449))
 (set.gloc.of |permute-env`2|)
 (close
   (2 0 . expand-library)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.caddr| 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cdddr| 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.caaddr| 1 "./boot/macro/library.scm" . 315397)
     (const . export)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of |.car| 1 "./boot/macro/library.scm" . 315397)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 315397))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cddddr| 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cadddr| 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of |.cdr| 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.cdaddr| 1 "./boot/macro/library.scm" . 315397)
     (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (extend . 4)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 315397))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of parse-exports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of parse-exports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 315397))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 6)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc.1 . 5)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (push.const . #f)
           (subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
           (if.false.ret)
           (push.const . library)
           (push.const . "duplicate export identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 4 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc.1 . 5)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 4)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (if.eq?.ret.const . #t)
           (push.const . library)
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc 2 . 4)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 1)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 315397))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable-copy 1 "./boot/macro/library.scm" . 315397)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 315397)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc 2 . 4)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 315397)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 3)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of expand-library-body)
         (push.iloc 7 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc 4 . 2)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of |permute-env`2|)
             (push.iloc 3 . 0)
             (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 315397))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 315397))
         (push)
         (call
           (touch.gloc.of |permute-env`2|)
           (push.iloc 2 . 0)
           (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 315397))
         (push)
         (apply.gloc.of expand-library-body "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc 4 . 4)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 315397))
   (push.const . library)
   (push.const . "expected library name, export spec, and import spec")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
 (set.gloc.of expand-library)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . |.require-scheme-library|)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 435223)
   (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 435223))
 (set.gloc.of |.fn3.1`3|)
 (close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 400414))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 400397))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 401448))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 401431))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 402454)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 404526)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 404517)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 406574)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 408659)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 408632)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 408632))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 409656))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 407590))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 412726))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 413750))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 411684))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 414742)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 416814)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 416805)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 418862)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 420947)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 420920)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 420920))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 421944))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 419878))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 425041)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 425014)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 425014))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 426065)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 426038)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 426038))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 423972))
   (push.const . library)
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 428054))
 (set.gloc.of |check-duplicate-definition`2|)
 (close
   (9 0 . expand-library-body)
   (extend.unbound . 6)
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/library.scm" . 374805)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/library.scm" . 375831)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 376874)
       (apply.gloc.of env-lookup "./boot/macro/library.scm" . 376858))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/library.scm" . 377876))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-macro)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/library.scm" . 382996))
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 389134))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 390175))
       (set.iloc 1 . 1)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 391199)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 391187))
     (set.iloc 2 . 7)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 392233)
       (push.iloc 3 . 7)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 392223))
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 392201))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 396322)
       (push.iloc 2 . 8)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 396310))
     (set.iloc 2 . 8)
     (ret.const.unspec))
   (push.close
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of |check-duplicate-definition`2|)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of |check-duplicate-definition`2| "./boot/macro/library.scm" . 432137))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 7)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 433182))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn3.1`3|)
       (push.iloc 3 . 6)
       (apply.gloc.of map "./boot/macro/library.scm" . 435218))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 440388)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 441393)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 441387)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 441382)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 442419)
             (push.iloc 6 . 7)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 442406))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 443421))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 441371))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 441371))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 439314))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 449576))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 453701)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 453691))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 453686)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 454734)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 454742)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 454710))
             (ret.const.unspec))
           (push.iloc 5 . 8)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 455728)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 452646))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 456742))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 449558)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 449558)
       (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 449558)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 458810)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 458804)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 458799)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 460849)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . template)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 462889)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 462889)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 462889))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . procedure)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 463913)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 463913))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . variable)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 464937)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 464937))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 465967))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 449558))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 449558)
       (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 449558))
     (push)
     (push.const . |.intern-scheme-library|)
     (push.const . quote)
     (push.iloc 3 . 1)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 467985)
     (push.const . quote)
     (push.iloc 3 . 2)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 467985)
     (push.const . quote)
     (call
       (push.close
         (1 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 474149)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 475186)
           (push.iloc 2 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 475180)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (touch.gloc.of make-import)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 475231)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 475218))
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 476210)
           (push.iloc 5 . 5)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 476204)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 475173))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 478252))
           (push.const . library)
           (push.const . "attempt to export unbound identifier ~u")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 480368)
           (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 480318)
           (push.iloc 6 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 481342)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 479276))
         (ret.cons "./boot/macro/library.scm" . 473117))
       (push.iloc 3 . 4)
       (apply.gloc.of map "./boot/macro/library.scm" . 434187))
     (push)
     (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 434187)
     (push.subr.gloc.of |.list| 4 "./boot/macro/library.scm" . 434187)
     (extend . 4)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 483353))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 484384))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 485398))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 487489)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 487497)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 487508))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 487461))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 488477))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 490543)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 492634)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 492604))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 493628))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 491567))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 489501))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 495629)
     (subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 495629)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 495629))
   (enclose . 5)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 503844)
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 5)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 505927)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 505883))
     (push.iloc.1 . 5)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 505861))
   (extend.enclose
     (4 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 507943)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 507964)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 507955))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 7)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 508970)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 508954))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 7)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 511005))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 510999))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 513047)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 513047)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 513047)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 513047))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 513047)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 513047)
           (extend . 3)
           (call
             (push.iloc 4 . 5)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 513047)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 513047)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 513047))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 513047)
             (push.iloc.1 . 1)
             (push.iloc 6 . 7)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 513047))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 513047))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (6 . 3) "./boot/macro/library.scm" . 513047))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 513047)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 513047))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 513047)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 513047))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 513047))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 513047)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 7)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
           (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 513047))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 513047))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 533569)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 533553))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 533548)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 533582)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 533538))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 5)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 534607)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 534558)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 535646)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 535582))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 536612)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 537667)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 537636))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 538651))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 539695))
           (push)
           (apply.iloc (5 . 3) "./boot/macro/library.scm" . 539675))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 540705)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 540739))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 540699))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 542777)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 542755))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 542789)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 542743))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 543771))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 545819))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 546886)
           (push.iloc 5 . 7)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 546864))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 7)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 548921)
             (push.iloc 5 . 7)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 548906))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 550952)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 550946))
           (call (push.iloc.0 . 0) (apply.iloc (5 . 0) "./boot/macro/library.scm" . 551970))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 553018)
             (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 553000)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 552994))
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555061)
           (push.iloc 3 . 2)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555076)
           (push.iloc 3 . 3)
           (apply.iloc (5 . 4) "./boot/macro/library.scm" . 555042))
         (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 508942))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557098)
       (push.iloc.1 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557113)
       (push.iloc.1 . 3)
       (apply.iloc (3 . 4) "./boot/macro/library.scm" . 557079))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 559137)
     (push.iloc.0 . 2)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 559152)
     (push.iloc.0 . 3)
     (apply.iloc (2 . 4) "./boot/macro/library.scm" . 559118))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 7)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 506902))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 506885))
 (set.gloc.of expand-library-body)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 564255)
   (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 564278)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/library.scm" . 567321)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/library.scm" . 568349)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 568375))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 569376)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 570418))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/macro/library.scm" . 571458)
   (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 571429))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . import-top-level-bindings)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/macro/library.scm" . 562179))
 (set.gloc.of import-top-level-bindings)
 (ret.const.unspec))
((close
   (2 0 . expand-import)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/library.scm" . 576522))
     (if.false.ret)
     (push.const . import)
     (push.const . "misplaced top-level directive")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 577546))
   (call
     (touch.gloc.of auto-compile-cache-update)
     (apply.gloc.of auto-compile-cache-update "./boot/macro/library.scm" . 578565))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 581690)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 581658)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 583725)
         (if.eq?.ret.const . #t)
         (push.const . import)
         (push.const . "duplicate import identifiers")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 584796))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 584829)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 584739))
       (push.iloc 2 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 586811)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 586819)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 586778))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 579624)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 579604))
     (push)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 579589))
   (touch.gloc.of import-top-level-bindings)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 588834)
   (apply.gloc.of import-top-level-bindings "./boot/macro/library.scm" . 588807))
 (set.gloc.of expand-import)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (call
       (touch.gloc.of generate-library-id)
       (push.iloc.0 . 0)
       (apply.gloc.of generate-library-id "./boot/macro/library.scm" . 592919))
     (push)
     (extend . 1)
     (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 593962))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 593942)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . pending)
     (if.eq?
       (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 596005))
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 595984)
       (push.const . library)
       (push.const . "encountered cyclic dependencies")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 597008))
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 601128))
         (push)
         (push.iloc 2 . 0)
         (push.const . pending)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 601107))
       (push.close
         (0 0)
         (touch.gloc.of load-scheme-library)
         (push.iloc 3 . 0)
         (push.const . #f)
         (apply.gloc.of load-scheme-library "./boot/macro/library.scm" . 603155))
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 605233))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 605213)
         (const . pending)
         (if.not.eq?.ret.const . #f)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 606253))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 606232))
       (apply.gloc.of dynamic-wind "./boot/macro/library.scm" . 599056))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.require-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 591875))
((call
   (push.const . equal?)
   (push.subr.gloc.of make-core-hashtable 1 "./boot/macro/library.scm" . 610333)
   (extend . 1)
   (ret.close
     (1 0 . unify-import-bindings)
     (push.close
       (1 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 613397)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of values "./boot/macro/library.scm" . 613390))
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 615452)
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/library.scm" . 612359)))
 (set.gloc.of unify-import-bindings)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of scheme-library-versions)
       (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 620591))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 620570))
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 621594))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of unify-import-bindings)
     (push.iloc.0 . 2)
     (apply.gloc.of unify-import-bindings "./boot/macro/library.scm" . 621630))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 621573))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.intern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 618497))
((close
   (1 0)
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 625693))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of core-hashtable-delete! "./boot/macro/library.scm" . 625669))
 (set.gloc.of |.fn1.1`1|)
 (push.const . |.unintern-scheme-library|)
 (push.gloc.of |.fn1.1`1|)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 623617))
((close
   (1 0 . permute-env)
   (touch.gloc.of |loop`8|)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 637977)
   (push.const)
   (push.const)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 637961))
 (set.gloc.of |permute-env`2|)
 (close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 640018))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 641052)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 641042))
   (if.true
     (touch.gloc.of |loop`8|)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 642072)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 642095)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 642066))
   (touch.gloc.of |loop`8|)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 644120)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 644136)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of |loop`8| "./boot/macro/library.scm" . 644114))
 (set.gloc.of |loop`8|)
 (close
   (2 0 . expand-top-level-program)
   (extend.unbound . 1)
   (push.const |.R6RS-TOP|)
   (enclose . 1)
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 635909)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 635909)
     (if.false.ret)
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 635909)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.caar| 1 "./boot/macro/library.scm" . 635909)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 635909))
   (if.true
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (push.iloc.1 . 0)
     (push.subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 635909)
     (extend . 2)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 635909))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 635909))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 635909))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 635909))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 635909))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 4)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 635909)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 635909)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
           (if.eq?.ret.const . #t)
           (push.const . "top-level program")
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 635909))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 635909))
         (push.iloc 2 . 3)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 635909))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 635909))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable-copy 1 "./boot/macro/library.scm" . 635909)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 635909)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 635909)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
       (push.iloc 2 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 635909)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 635909))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 2)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.const . #f)
       (call
         (touch.gloc.of expand-top-level-program-body)
         (push.iloc 8 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of |permute-env`2|)
             (push.iloc 3 . 0)
             (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 635909))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 635909))
         (push)
         (call
           (touch.gloc.of |permute-env`2|)
           (push.iloc 2 . 0)
           (apply.gloc.of |permute-env`2| "./boot/macro/library.scm" . 635909))
         (push)
         (apply.gloc.of expand-top-level-program-body "./boot/macro/library.scm" . 635909))
       (push)
       (push.iloc 4 . 3)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 635909))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
     (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 635909))
   (push.const . "top-level program")
   (push.const . "expected import form and top-level body")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.1 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 635909))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 635909))
 (set.gloc.of expand-top-level-program)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . |.require-scheme-library|)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 749591)
   (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 749591))
 (set.gloc.of |.fn1.1`1|)
 (close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 714782))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 714765))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 715816))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 715799))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 716822)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 718894)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 718885)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 720942)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 723027)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 723000)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 723000))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 724024))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 721958))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 727094))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 728118))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 726052))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 729110)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 731182)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 731173)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 733230)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 735315)
         (push.const ...)
         (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 735288)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 735288))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 736312))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 734246))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 739409)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 739382)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 739382))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 740433)
       (push.const ...)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 740406)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 740406))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 738340))
   (push.const . "top-level program")
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 742422))
 (set.gloc.of |check-duplicate-definition`2|)
 (close
   (8 0 . expand-top-level-program-body)
   (extend.unbound . 6)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 703502))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/library.scm" . 704543))
       (set.iloc 1 . 0)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 705567)
       (push.iloc 2 . 6)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 705555))
     (set.iloc 2 . 6)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 706601)
       (push.iloc 3 . 6)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 706591))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 706569))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 710690)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 710678))
     (set.iloc 2 . 7)
     (ret.const.unspec))
   (push.close+
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of |check-duplicate-definition`2|)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of |check-duplicate-definition`2| "./boot/macro/library.scm" . 746505))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 6)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 747550))
     (push)
     (extend . 1)
     (call
       (push.gloc.of |.fn1.1`1|)
       (push.iloc 3 . 5)
       (apply.gloc.of map "./boot/macro/library.scm" . 749586))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 754756)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 755761)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 755755)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 755750)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 756787)
             (push.iloc 6 . 6)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 756774))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 757789))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 755739))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
         (apply.gloc.of |.dynamic-wind| "./boot/macro/library.scm" . 755739))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 753682))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 763944))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 768069)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 768059))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 768054)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 769102)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 769110)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 769078))
             (ret.const.unspec))
           (push.iloc 5 . 7)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 770096)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 767014))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 771110))
       (push)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 763926)
       (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 763926)
       (push.subr.gloc.of |.list| 1 "./boot/macro/library.scm" . 763926)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 773178)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 773172)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 773167)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 775217)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . template)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 777257)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 777257)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 777257))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . procedure)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 778281)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 778281))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . variable)
           (if.eq?
             (push.const . |.set-top-level-macro!|)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of |.list| 2 "./boot/macro/library.scm" . 779305)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 779305))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 780335))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 763926))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/macro/library.scm" . 763926)
       (ret.subr.gloc.of |.list| "./boot/macro/library.scm" . 763926))
     (push)
     (extend . 3)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 782361))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 783392))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 784406))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 786497)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 786505)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 786516))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 786469))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 787485))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 789551)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 791642)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 791612))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 792636))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 790575))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 788509))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 794637)
     (push.subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 794637)
     (subr.gloc.of |.append| 2 "./boot/macro/library.scm" . 794637)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 794637))
   (enclose . 4)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 801828)
   (set.iloc 0 . 4)
   (call
     (push.const . 0)
     (extend . 1)
     (ret.close
       (0 0)
       (n+.iloc (1 . 0) 1 "./boot/macro/library.scm" . 806933)
       (set.iloc 1 . 0)
       (push.const . ".e~a")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 807963)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 807947)))
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 4)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 810055)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 810011))
     (push.iloc.1 . 4)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 809989))
   (extend.enclose
     (4 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 813086)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 813101)
       (push.iloc.0 . 3)
       (apply.iloc+ (2 . 3) "./boot/macro/library.scm" . 813067))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 814123)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 814144)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 814135))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 6)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 815150)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 815134))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 6)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 817185))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 817179))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdar| 1 "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cddar| 1 "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of |.cdddar| 1 "./boot/macro/library.scm" . 819227)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (subr.gloc.of |.list?| 1 "./boot/macro/library.scm" . 819227)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 819227)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 819227))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.caddar| 1 "./boot/macro/library.scm" . 819227)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cadar| 1 "./boot/macro/library.scm" . 819227)
           (extend . 3)
           (call
             (push.iloc 4 . 4)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 819227)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 819227)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 819227))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 819227)
             (push.iloc.1 . 1)
             (push.iloc 6 . 6)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 819227))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 819227))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 819227))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 819227)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 819227))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 819227)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 819227))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 819227))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 819227)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 6)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
           (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 819227))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 819227))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 839749)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 839733))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 839728)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 839762)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 839718))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 4)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 840787)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 840738)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 841826)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 841762))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 842792)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 843847)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 843816))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 1) "./boot/macro/library.scm" . 844831))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 845875))
           (push)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 845855))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 846885)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 846919))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 846879))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 848957)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 848935))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 848969)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 848923))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 849951))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 851999))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 853066)
           (push.iloc 5 . 6)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 853044))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 6)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 855098)
             (push.iloc 5 . 6)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 855083))
           (push)
           (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 855115)
           (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 855075)
           (push.iloc 2 . 1)
           (push.iloc 2 . 2)
           (push.iloc 2 . 3)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 855069))
         (apply.gloc.of |.call-with-values| "./boot/macro/library.scm" . 815122))
       (push.const . |.define|)
       (call (apply.iloc (3 . 5) "./boot/macro/library.scm" . 857138))
       (push)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 857156)
       (push.subr.gloc.of |.list| 3 "./boot/macro/library.scm" . 857121)
       (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 857168)
       (push.cons)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 857115))
     (push.const . |.define|)
     (call (apply.iloc (2 . 5) "./boot/macro/library.scm" . 859177))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 859195)
     (push.subr.gloc.of |.list| 3 "./boot/macro/library.scm" . 859160)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 859207)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 859154))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 6)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 811030))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 811013))
 (set.gloc.of expand-top-level-program-body)
 (ret.const.unspec))

;
((close
   (2 0 . extend-env)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/synenv.scm" . 9225))
 (set.gloc.of extend-env)
 (ret.const.unspec))
((close
   (2 0 . env-lookup)
   (call
     (iloc.0 . 1)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error: env-lookup: expect symbol but got ~s")
     (push.iloc.0 . 1)
     (apply.gloc.of scheme-error "./boot/macro/synenv.scm" . 14345))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 15372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of import?)
       (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 17441)
       (apply.gloc.of import? "./boot/macro/synenv.scm" . 17432))
     (if.true
       (push.cddr.iloc (0 . 0) "./boot/macro/synenv.scm" . 18470)
       (extend . 1)
       (subr.gloc.of current-macro-environment 0)
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 19482))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of cdr "./boot/macro/synenv.scm" . 21528))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 23564))
 (set.gloc.of env-lookup)
 (ret.const.unspec))
((close
   (2 0 . env-delete!)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 27660)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of set-car! 2 "./boot/macro/synenv.scm" . 29713)
     (push.iloc.0 . 0)
     (push.const . no-use)
     (ret.subr.gloc.of set-cdr! "./boot/macro/synenv.scm" . 30737))
   (ret.const.unspec))
 (set.gloc.of env-delete!)
 (ret.const.unspec))
((close
   (3 0 . lexical=?)
   (push.iloc.0 . 1)
   (iloc.0 . 2)
   (if.eq?.ret.const . #t)
   (call
     (touch.gloc.of original-id)
     (push.iloc.0 . 1)
     (apply.gloc.of original-id "./boot/macro/synenv.scm" . 62487))
   (push)
   (call
     (touch.gloc.of original-id)
     (push.iloc.0 . 2)
     (apply.gloc.of original-id "./boot/macro/synenv.scm" . 62504))
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 63519))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 63547))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (call
     (push.iloc.1 . 1)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 65584))
   (if.false.ret)
   (push.iloc.1 . 2)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (touch.gloc.of unbound?)
   (push.iloc.0 . 1)
   (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 66608))
 (set.gloc.of |lexical=?`2|)
 (close
   (2 0 . free-id=?)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/synenv.scm" . 69653))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of lookup-lexical-name)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 69690))
   (push)
   (extend . 1)
   (iloc 2 . 1)
   (if.symbol?
     (touch.gloc.of |lexical=?`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of lookup-lexical-name)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 71713))
     (push)
     (apply.gloc.of |lexical=?`2| "./boot/macro/synenv.scm" . 71695))
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/synenv.scm" . 72726))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (iloc.0 . 0) (ret.eq? "./boot/macro/synenv.scm" . 72770))
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 3 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/synenv.scm" . 74805))
     (push)
     (push.iloc 2 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 74784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of renamed-id?)
     (push.iloc 2 . 0)
     (apply.gloc.of renamed-id? "./boot/macro/synenv.scm" . 75804))
   (if.true (push.iloc 2 . 0) (iloc.0 . 0) (ret.eq? "./boot/macro/synenv.scm" . 75821))
   (touch.gloc.of |lexical=?`2|)
   (push.iloc 3 . 0)
   (push.iloc 2 . 0)
   (push.iloc.0 . 0)
   (apply.gloc.of |lexical=?`2| "./boot/macro/synenv.scm" . 75833))
 (set.gloc.of free-id=?)
 (ret.const.unspec))
((close
   (1 0 . make-import)
   (push.const . import)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 79877))
 (set.gloc.of make-import)
 (ret.const.unspec))
((close (0 0 . make-unbound) (ret.const unbound)) (set.gloc.of make-unbound) (ret.const.unspec))
((close
   (1 0 . make-out-of-context)
   (iloc.0 . 0)
   (if.true (push.const . out-of-context) (iloc.0 . 0) (ret.cons "./boot/macro/synenv.scm" . 89097))
   (ret.const out-of-context . #f))
 (set.gloc.of make-out-of-context)
 (ret.const.unspec))
((close
   (1 0 . make-pattern-variable)
   (push.const . pattern-variable)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 94213))
 (set.gloc.of make-pattern-variable)
 (ret.const.unspec))
((close
   (2 0 . make-macro)
   (push.const . macro)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 98309))
 (set.gloc.of make-macro)
 (ret.const.unspec))
((close
   (2 0 . make-macro-variable)
   (push.const . macro-variable)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 102405))
 (set.gloc.of make-macro-variable)
 (ret.const.unspec))
((close
   (1 0 . make-special)
   (push.const . special)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 106501))
 (set.gloc.of make-special)
 (ret.const.unspec))
((close
   (1 0 . import?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 111631)
   (const . import)
   (ret.eq? "./boot/macro/synenv.scm" . 111626))
 (set.gloc.of import?)
 (ret.const.unspec))
((close
   (1 0 . unbound?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 116751)
   (const . unbound)
   (ret.eq? "./boot/macro/synenv.scm" . 116746))
 (set.gloc.of unbound?)
 (ret.const.unspec))
((close
   (1 0 . out-of-context?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 121871)
   (const . out-of-context)
   (ret.eq? "./boot/macro/synenv.scm" . 121866))
 (set.gloc.of out-of-context?)
 (ret.const.unspec))
((close
   (1 0 . macro?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 126995)
   (const . macro)
   (if.eq?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 128019)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 128014))
 (set.gloc.of macro?)
 (ret.const.unspec))
((close
   (1 0 . macro-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 133135)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 133130))
 (set.gloc.of macro-variable?)
 (ret.const.unspec))
((close
   (1 0 . pattern-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 138255)
   (const . pattern-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 138250))
 (set.gloc.of pattern-variable?)
 (ret.const.unspec))
((close
   (1 0 . special?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 143375)
   (const . special)
   (ret.eq? "./boot/macro/synenv.scm" . 143370))
 (set.gloc.of special?)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 147479)
   (push.const . "unquote appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 147461))
 (set.gloc.of unexpected-unquote)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote-splicing)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 151575)
   (push.const . "unquote-splicing appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 151557))
 (set.gloc.of unexpected-unquote-splicing)
 (ret.const.unspec))
((close
   (2 0 . unexpected-auxiliary-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 155671)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 155653))
 (set.gloc.of unexpected-auxiliary-syntax)
 (ret.const.unspec))
((close
   (2 0 . unexpected-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 159767)
   (push.const . "misplaced syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 159749))
 (set.gloc.of unexpected-syntax)
 (ret.const.unspec))
((subr.gloc.of make-core-hashtable 0 "./boot/macro/synenv.scm" . 161810)
 (set.gloc.of core-env)
 (ret.const.unspec))
((close
   (2 0 . init-core-macro)
   (push.gloc.of core-env)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (subr.gloc.of core-hashtable-set! 3 "./boot/macro/synenv.scm" . 167943)
   (push.gloc.of core-env)
   (call
     (touch.gloc.of core-primitive-name)
     (push.iloc.0 . 0)
     (apply.gloc.of core-primitive-name "./boot/macro/synenv.scm" . 168997))
   (push)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 168967))
 (set.gloc.of |init-core-macro`1|)
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . lambda)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-lambda)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 171047))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 171011))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . quote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 172071))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 172035))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . if)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-if)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 173095))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 173059))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . set!)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-set!)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 174119))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 174083))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 175143))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 175107))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 176167))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 176131))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 177191))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 177155))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . begin)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-begin)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 178215))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 178179))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 179239))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 179203))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . quasiquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quasiquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 180263))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 180227))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 181287))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 181251))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 182311))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 182275))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 183335))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 183299))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . cond)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-cond)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 184359))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 184323))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 185383))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 185347))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . do)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-do)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 186407))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 186371))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . and)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-and)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 187431))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 187395))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . or)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-or)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 188455))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 188419))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . letrec*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 189479))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 189443))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . library)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-library)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 190503))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 190467))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . define-macro)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-macro)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 191527))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 191491))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let*-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 192551))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 192515))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . let-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 193575))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 193539))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 194599))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 194563))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax-case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 195623))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 195587))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . identifier-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-identifier-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 196647))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 196611))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . assert)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-assert)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 197671))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 197635))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . unquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 198695))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 198659))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . unquote-splicing)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote-splicing)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 199719))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 199683))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . syntax-rules)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 200743))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 200707))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . else)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 201767))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 201731))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . =>)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 202791))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 202755))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . ...)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 203815))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 203779))
 (call
   (touch.gloc.of |init-core-macro`1|)
   (push.const . _)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 204839))
   (push)
   (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 204803))
 (touch.gloc.of |init-core-macro`1|)
 (push.const . import)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-import)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 205863))
 (push)
 (apply.gloc.of |init-core-macro`1| "./boot/macro/synenv.scm" . 205827))
((push.gloc.of core-env)
 (push.const . lambda)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 207905)
 (set.gloc.of denote-lambda)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . begin)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 208929)
 (set.gloc.of denote-begin)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 209953)
 (set.gloc.of denote-define)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 210977)
 (set.gloc.of denote-define-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 212001)
 (set.gloc.of denote-let-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 213025)
 (set.gloc.of denote-letrec-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-macro)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 214049)
 (set.gloc.of denote-define-macro)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . library)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 215073)
 (set.gloc.of denote-library)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 216097)
 (set.gloc.of denote-quasiquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 217121)
 (set.gloc.of denote-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . if)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 218145)
 (set.gloc.of denote-if)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . set!)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 219169)
 (set.gloc.of denote-set!)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 220193)
 (set.gloc.of denote-unquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 221217)
 (set.gloc.of denote-unquote-splicing)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 222241)
 (set.gloc.of denote-let)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 223265)
 (set.gloc.of denote-letrec)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 224289)
 (set.gloc.of denote-let*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . cond)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 225313)
 (set.gloc.of denote-cond)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 226337)
 (set.gloc.of denote-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . do)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 227361)
 (set.gloc.of denote-do)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . and)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 228385)
 (set.gloc.of denote-and)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . or)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 229409)
 (set.gloc.of denote-or)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 230433)
 (set.gloc.of denote-letrec*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 231457)
 (set.gloc.of denote-let*-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 232481)
 (set.gloc.of denote-let-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 233505)
 (set.gloc.of denote-syntax-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 234529)
 (set.gloc.of denote-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 235553)
 (set.gloc.of denote-syntax-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 236577)
 (set.gloc.of denote-syntax-rules)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . else)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 237601)
 (set.gloc.of denote-else)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . =>)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 238625)
 (set.gloc.of denote-=>)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . import)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 239649)
 (set.gloc.of denote-import)
 (ret.const.unspec))
((close
   (2 0 . denote-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of macro?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 244754))
   (push)
   (apply.gloc.of macro? "./boot/macro/synenv.scm" . 244746))
 (set.gloc.of denote-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-special?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of special?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 249876))
   (push)
   (apply.gloc.of special? "./boot/macro/synenv.scm" . 249866))
 (set.gloc.of denote-special?)
 (ret.const.unspec))
((close
   (2 0 . denote-lambda?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 254991))
   (push)
   (gloc.of denote-lambda)
   (ret.eq? "./boot/macro/synenv.scm" . 254986))
 (set.gloc.of denote-lambda?)
 (ret.const.unspec))
((close
   (2 0 . denote-begin?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 260111))
   (push)
   (gloc.of denote-begin)
   (ret.eq? "./boot/macro/synenv.scm" . 260106))
 (set.gloc.of denote-begin?)
 (ret.const.unspec))
((close
   (2 0 . denote-let?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 265231))
   (push)
   (gloc.of denote-let)
   (ret.eq? "./boot/macro/synenv.scm" . 265226))
 (set.gloc.of denote-let?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 270351))
   (push)
   (gloc.of denote-define-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 270346))
 (set.gloc.of denote-define-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-let-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 275471))
   (push)
   (gloc.of denote-let-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 275466))
 (set.gloc.of denote-let-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-letrec-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 280591))
   (push)
   (gloc.of denote-letrec-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 280586))
 (set.gloc.of denote-letrec-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-define?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 285711))
   (push)
   (gloc.of denote-define)
   (ret.eq? "./boot/macro/synenv.scm" . 285706))
 (set.gloc.of denote-define?)
 (ret.const.unspec))
((close
   (2 0 . denote-quote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 290831))
   (push)
   (gloc.of denote-quote)
   (ret.eq? "./boot/macro/synenv.scm" . 290826))
 (set.gloc.of denote-quote?)
 (ret.const.unspec))
((close
   (2 0 . denote-quasiquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 295951))
   (push)
   (gloc.of denote-quasiquote)
   (ret.eq? "./boot/macro/synenv.scm" . 295946))
 (set.gloc.of denote-quasiquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 301071))
   (push)
   (gloc.of denote-unquote)
   (ret.eq? "./boot/macro/synenv.scm" . 301066))
 (set.gloc.of denote-unquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote-splicing?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 306191))
   (push)
   (gloc.of denote-unquote-splicing)
   (ret.eq? "./boot/macro/synenv.scm" . 306186))
 (set.gloc.of denote-unquote-splicing?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 311311))
   (push)
   (gloc.of denote-define-macro)
   (ret.eq? "./boot/macro/synenv.scm" . 311306))
 (set.gloc.of denote-define-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-syntax-rules?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 316431))
   (push)
   (gloc.of denote-syntax-rules)
   (ret.eq? "./boot/macro/synenv.scm" . 316426))
 (set.gloc.of denote-syntax-rules?)
 (ret.const.unspec))
((close
   (2 0 . denote-else?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 321551))
   (push)
   (gloc.of denote-else)
   (ret.eq? "./boot/macro/synenv.scm" . 321546))
 (set.gloc.of denote-else?)
 (ret.const.unspec))
((close
   (2 0 . denote-=>?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 326671))
   (push)
   (gloc.of denote-=>)
   (ret.eq? "./boot/macro/synenv.scm" . 326666))
 (set.gloc.of denote-=>?)
 (ret.const.unspec))
((close
   (2 0 . denote-set!?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 331791))
   (push)
   (gloc.of denote-set!)
   (ret.eq? "./boot/macro/synenv.scm" . 331786))
 (set.gloc.of denote-set!?)
 (ret.const.unspec))
((push.const . |.LIST|)
 (const . |.list|)
 (push.cons)
 (push.const . |.CONS|)
 (const . |.cons|)
 (push.cons)
 (push.const . |.CONS*|)
 (const . |.cons*|)
 (push.cons)
 (push.const . |.APPEND|)
 (const . |.append|)
 (push.cons)
 (push.const . |.VECTOR|)
 (const . |.vector|)
 (push.cons)
 (push.const . |.LIST->VECTOR|)
 (const . |.list->vector|)
 (push.cons)
 (push.const . |.EQ?|)
 (const . |.eq?|)
 (push.cons)
 (push.const . |.EQV?|)
 (const . |.eqv?|)
 (push.cons)
 (push.const . |.MEMQ|)
 (const . |.memq|)
 (push.cons)
 (push.const . |.MEMV|)
 (const . |.memv|)
 (push.cons)
 (push.const . |.CALL-WITH-VALUES|)
 (const . |.call-with-values|)
 (push.cons)
 (push.const . |.APPLY|)
 (const . |.apply|)
 (push.cons)
 (push.const . |.CDR|)
 (const . |.cdr|)
 (push.cons)
 (push.const . |.IDENTIFIER?|)
 (const . |.identifier?|)
 (push.cons)
 (push.const . |.MAKE-VARIABLE-TRANSFORMER|)
 (const . |.make-variable-transformer|)
 (push.cons)
 (push.const . |.ASSERTION-VIOLATION|)
 (const . |.assertion-violation|)
 (push.cons)
 (push.const . |.UNSPECIFIED|)
 (const . |.unspecified|)
 (push.cons)
 (push.const . |.QUOTE|)
 (gloc.of denote-quote)
 (push.cons)
 (push.const . |.LET|)
 (gloc.of denote-let)
 (push.cons)
 (push.const . |.LETREC*|)
 (gloc.of denote-letrec*)
 (push.cons)
 (push.const . |.BEGIN|)
 (gloc.of denote-begin)
 (push.cons)
 (push.const . |.LAMBDA|)
 (gloc.of denote-lambda)
 (push.cons)
 (push.const . |.IF|)
 (gloc.of denote-if)
 (push.cons)
 (push.const . |.SET!|)
 (gloc.of denote-set!)
 (push.cons)
 (push.const . |.OR|)
 (gloc.of denote-or)
 (push.cons)
 (push.const . |.COND|)
 (gloc.of denote-cond)
 (push.cons)
 (push.const . |.ELSE|)
 (gloc.of denote-else)
 (push.cons)
 (push.const . |.DEFINE-SYNTAX|)
 (gloc.of denote-define-syntax)
 (push.cons)
 (push.const . |.SYNTAX|)
 (gloc.of denote-syntax)
 (push.cons)
 (push.const . |.SYNTAX-CASE|)
 (gloc.of denote-syntax-case)
 (push.cons)
 (subr.gloc.of list 30 "./boot/macro/synenv.scm" . 334851)
 (set.gloc.of private-primitives-environment)
 (ret.const.unspec))
((push.gloc.of core-env)
 (ret.subr.gloc.of current-macro-environment "./boot/macro/synenv.scm" . 369665))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/compile.scm" . 5147))
 (set.gloc.of ht-local-closures)
 (ret.const.unspec))
((close
   (1 0 . local-closure?)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/compile.scm" . 9248))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 9228)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 10273)
     (push.const stack)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 10267))
   (ret.const . #f))
 (set.gloc.of local-closure?)
 (ret.const.unspec))
((close
   (1 0)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 16413)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 17435)
   (const . lambda)
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of local-closure?)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 18470)
     (apply.gloc.of local-closure? "./boot/compile.scm" . 18454))
   (if.false.ret)
   (call
     (touch.gloc.of ht-local-closures)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 19499))
   (push)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 19519)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 19478))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . collect-local-closure)
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/compile.scm" . 15365))
 (set.gloc.of collect-local-closure)
 (ret.const.unspec))
((close
   (1 0 . make-application-comment)
   (subr.gloc.of backtrace 0 "./boot/compile.scm" . 24585)
   (if.true
     (subr.gloc.of current-source-comments 0 "./boot/compile.scm" . 25616)
     (if.true
       (subr.gloc.of current-source-comments 0)
       (push)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 27676)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 29733)
         (if.true
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . |.&SOURCE-PATH|)
           (push.const . #f)
           (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 30766)
           (push.iloc.0 . 0)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 30834)
           (ret.subr.gloc.of |.cons*| "./boot/compile.scm" . 29729))
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . |.&SOURCE-PATH|)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 31784)
         (iloc.0 . 0)
         (ret.cons "./boot/compile.scm" . 29729))
       (push.iloc.1 . 0)
       (ret.subr.gloc.of list "./boot/compile.scm" . 33820))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 35856))
   (ret.const))
 (set.gloc.of make-application-comment)
 (ret.const.unspec))
((close
   (1 0 . make-closure-comment)
   (call
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 40977))
     (if.false.ret)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 42021))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of core-hashtable-ref "./boot/compile.scm" . 42001))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/compile.scm" . 40965))
   (ret.const))
 (set.gloc.of make-closure-comment)
 (ret.const.unspec))
((close
   (1 0 . top-level-subr)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 49162)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 50193)
   (subr.gloc.of subr? 1 "./boot/compile.scm" . 50186)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 51210))
 (set.gloc.of top-level-subr)
 (ret.const.unspec))
((close
   (1 0 . top-level-value-or-false)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 56330)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 57354))
 (set.gloc.of top-level-value-or-false)
 (ret.const.unspec))
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 62479)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 62504)
       (apply.gloc.of formals->list "./boot/compile.scm" . 62489))
     (ret.cons "./boot/compile.scm" . 62473))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/compile.scm" . 64533))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . make-formals-operand)
   (push.iloc.0 . 1)
   (subr.gloc.of list? 1 "./boot/compile.scm" . 68620)
   (if.true
     (push.iloc.0 . 1)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 68642)
     (push.const . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 68636))
   (iloc.0 . 1)
   (if.pair?
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 69669)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/compile.scm" . 69666)
     (push.const . 1)
     (ret.subr.gloc.of list "./boot/compile.scm" . 69660))
   (ret.const 0 1))
 (set.gloc.of make-formals-operand)
 (ret.const.unspec))
((close
   (2 0 . make-iloc-operand)
   (extend.enclose+
     (2 0 . loop1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 76824)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 76816)
     (if.true
       (push.iloc.0 . 1)
       (call
         (extend.enclose+
           (2 0 . loop2)
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 79905)
           (iloc 4 . 0)
           (if.eq? (ret.iloc 0 . 1))
           (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 81955)
           (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 81966)
           (apply.iloc+ (1 . 0) "./boot/compile.scm" . 81948))
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 78888)
         (push.const . 0)
         (apply.iloc+ (0 . 0) "./boot/compile.scm" . 78870))
       (ret.cons "./boot/compile.scm" . 75783))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 82967)
     (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 82978)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 82960))
   (push.iloc.1 . 1)
   (push.const . 0)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 74757))
 (set.gloc.of make-iloc-operand)
 (ret.const.unspec))
((close
   (3 0 . iloc-iota)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 89102)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/compile.scm" . 90137)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of + 2 "./boot/compile.scm" . 90167)
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 90131))
   (push.n+.iloc (1 . 2) -1 "./boot/compile.scm" . 88087)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 88069))
 (set.gloc.of iloc-iota)
 (ret.const.unspec))
((close
   (2 0 . cte-extend-iloc)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "./boot/compile.scm" . 94213))
 (set.gloc.of cte-extend-iloc)
 (ret.const.unspec))
((close
   (2 0 . iloc?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 101405)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 101397)
     (if.true.ret)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 102427)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 102421))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 99338))
 (set.gloc.of iloc?)
 (ret.const.unspec))
((close
   (1 0 . immediate-literal?)
   (push.iloc.0 . 0)
   (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 106505)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of char? 1 "./boot/compile.scm" . 106517)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of boolean? 1 "./boot/compile.scm" . 106527)
   (if.true.ret)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 107549)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 107574)
   (ret.subr.gloc.of symbol? "./boot/compile.scm" . 107565))
 (set.gloc.of immediate-literal?)
 (ret.const.unspec))
((close
   (2 0 . compile-touch)
   (call
     (iloc.0 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 113686)
     (if.true.ret.const . #f)
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 114710))
     (push)
     (ret.subr.gloc.of not "./boot/compile.scm" . 114705))
   (if.true
     (push.const . touch.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 112651)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 112651))
   (ret.const))
 (set.gloc.of compile-touch)
 (ret.const.unspec))
((close
   (4 0 . compile-lambda-helper)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/compile.scm" . 120849))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of cte-extend-iloc)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 121874))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of make-formals-operand)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of make-formals-operand "./boot/compile.scm" . 122900))
   (push)
   (push.iloc 2 . 2)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 122892)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 123918))
   (ret.cons "./boot/compile.scm" . 121863))
 (set.gloc.of compile-lambda-helper)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 128027))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of cons)
     (push.gloc.of =)
     (push.gloc.of <)
     (push.gloc.of <=)
     (push.gloc.of >)
     (push.gloc.of >=)
     (push.gloc.of eq?)
     (push.gloc.of null?)
     (push.gloc.of pair?)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of eqv?)
     (push.gloc.of equal?)
     (push.subr.gloc.of list 18 "./boot/compile.scm" . 129039)
     (apply.gloc.of for-each "./boot/compile.scm" . 128005))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 130053))
 (set.gloc.of ht-special-subr-expression)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 133123)
 (set.gloc.of alist-special-binary-subr)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 136195)
 (set.gloc.of alist-special-binary-subr-negate)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 139267)
 (set.gloc.of alist-special-binary-subr-iloc)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 142339)
 (set.gloc.of alist-special-binary-subr-iloc-negate)
 (ret.const.unspec))
((close
   (4 0 . compile-anonymous)
   (iloc.0 . 2)
   (if.true
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 150568)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 150545))
     (push)
     (push.const . ret.subr.gloc.of)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 150603)
     (push.iloc.0 . 3)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 149513)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151592)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 151569))
   (push)
   (push.const . subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 151623)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151643)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 151635)
   (push.iloc.0 . 3)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 149513)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 149513)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 149513))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (4 0 . compile-subr-expression)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 153620))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 154660)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 154643)
   (extend . 1)
   (push.gloc.of ht-special-subr-expression)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 155661)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 156699)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (iloc 2 . 2)
         (if.true.ret.const)
         (iloc 2 . 3)
         (if.true
           (push.const . ret.const.unspec)
           (push.subr.gloc.of list 1 "./boot/compile.scm" . 159789)
           (ret.subr.gloc.of list "./boot/compile.scm" . 159783))
         (push.const . const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 160813)
         (ret.subr.gloc.of list "./boot/compile.scm" . 160807))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 161824))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 162843)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of pair?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 165943)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 165923))
           (push)
           (push.const . ret.pair?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 164894)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 164894))
         (push.iloc.0 . 0)
         (gloc.of null?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 167991)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 167971))
           (push)
           (push.const . ret.null?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 166942)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 166942))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 170015))
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 171043)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 171036))
       (if.true
         (iloc 2 . 2)
         (if.true.ret.const)
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 175178)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 175159))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 174121)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 174121))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 177226)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 177207))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 176169)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 176169))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 179275)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 179256))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 178217)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 178217))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 181323)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 181304))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 180265)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 180265))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 183338))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 184348))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 185371)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of cons)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 188469)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 188451))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 188508)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 188488))
           (push)
           (push.const . ret.cons)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 187422)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 187422)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 187422))
         (push.iloc.0 . 0)
         (gloc.of eq?)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 190517)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 190499))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 190556)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 190536))
           (push)
           (push.const . ret.eq?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 189470)
           (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 189470)
           (ret.subr.gloc.of |.append| "./boot/compile.scm" . 189470))
         (push.iloc.0 . 0)
         (gloc.of eqv?)
         (if.eq?
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 192574)
           (extend . 1)
           (call
             (call
               (touch.gloc.of immediate-literal?)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 192555)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193577))
             (if.true.ret)
             (touch.gloc.of immediate-literal?)
             (push.iloc.0 . 0)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193603))
           (if.true
             (call
               (touch.gloc.of compile-argument)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 194619)
               (push.iloc 3 . 1)
               (apply.gloc.of compile-argument "./boot/compile.scm" . 194601))
             (push)
             (call
               (touch.gloc.of compile-expression)
               (push.iloc 3 . 0)
               (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 194658)
               (push.iloc 3 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 194638))
             (push)
             (push.const . ret.eq?)
             (iloc 2 . 0)
             (push.cons)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 193569)
             (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 193569)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 193569))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.iloc 2 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 195621))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 197663))
       (push.iloc.0 . 0)
       (push.gloc.of alist-special-binary-subr)
       (subr.gloc.of assq 2 "./boot/compile.scm" . 198687)
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 199723)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 199742)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 201787)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 201817))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 201858)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 201853)
             (ret.subr.gloc.of values "./boot/compile.scm" . 201835))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 202811)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 202841))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 202882)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 202877)
             (ret.subr.gloc.of values "./boot/compile.scm" . 202859))
           (push.const . #f)
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 203835))
         (push.close
           (3 0)
           (iloc.0 . 2)
           (if.true
             (push.iloc.0 . 2)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 204857))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 204841)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 204841))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 205866))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 206894))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 206937)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 206932)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 206982))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 205865)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 205865)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 205865))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 207914))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 208942))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 208985)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 208980)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 209037))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 207913)
             (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 207913)
             (ret.subr.gloc.of |.append| "./boot/compile.scm" . 207913))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 209967))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 199711))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 213035)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 213054)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 214085)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 214115))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 214133))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 215109)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 215139))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 215157))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 216133))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 218163))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 217123)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 217123))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 219175))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 213023))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 221227)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 221246)
         (extend . 2)
         (call
           (push.iloc.0 . 1)
           (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 222250)
           (if.false.ret)
           (iloc.0 . 0)
           (if.not.symbol?.ret.const . #f)
           (touch.gloc.of iloc?)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of iloc? "./boot/compile.scm" . 222280))
         (if.true
           (push.const . n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 223281))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 223311)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 222241)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 222241))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 3)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 224293))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 227359))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 3)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 229396))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc 2 . 3)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 230413))
 (set.gloc.of compile-subr-expression)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 234523))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of cons)
     (push.subr.gloc.of list 8 "./boot/compile.scm" . 235535)
     (apply.gloc.of for-each "./boot/compile.scm" . 234501))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 236549))
 (set.gloc.of ht-special-subr-argument)
 (ret.const.unspec))
((close
   (3 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243748)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 243725))
   (push)
   (push.const . push.subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 243784)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243804)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 243796)
   (push.iloc.0 . 2)
   (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 242695)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 242695)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 242695))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (2 0 . compile-subr-argument)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 245780))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 246820)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 246803)
   (extend . 1)
   (push.gloc.of ht-special-subr-argument)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 247821)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 248859)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (push.const . push.const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 249912)
         (ret.subr.gloc.of list "./boot/compile.scm" . 249906))
       (push.const . subr.gloc.of)
       (push.car.iloc (2 . 0) "./boot/compile.scm" . 251948)
       (push.const 0)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 250906)
       (push.const . push)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 251963)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 250906))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 252955)
     (if.null?
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 253983)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 253976))
       (if.true
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . push.car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 255059)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 255040))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 255006)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 255006))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . push.cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 256083)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 256064))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 256030)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 256030))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . push.cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 257109)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 257090))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 257054)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 257054))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . push.cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 258133)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 258114))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 258078)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 258078))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 259108))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 260120))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 261147)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of cons)
       (if.eq?
         (call
           (touch.gloc.of compile-argument)
           (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 263217)
           (push.iloc 2 . 1)
           (apply.gloc.of compile-argument "./boot/compile.scm" . 263199))
         (push)
         (call
           (touch.gloc.of compile-expression)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 263256)
           (push.iloc 2 . 1)
           (push.const . #f)
           (push.const . #f)
           (apply.gloc.of compile-expression "./boot/compile.scm" . 263236))
         (push)
         (push.const . push.cons)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 263281)
         (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 262170)
         (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 262170)
         (ret.subr.gloc.of |.append| "./boot/compile.scm" . 262170))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 265255)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 265274)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 266305))
             (if.false.ret)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 266322))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 266338))
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 267329))
             (if.false.ret)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 267346))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 267362))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 268353))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . push.n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 270388))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 269343)
             (ret.subr.gloc.of |.list| "./boot/compile.scm" . 269343))
           (touch.gloc.of |compile-anonymous`2|)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 3 . 0)
           (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 271395))
         (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 265243))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 273447)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 273466)
         (extend . 2)
         (call
           (call
             (touch.gloc.of iloc?)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 274470))
           (if.false.ret)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 274487))
         (if.true
           (push.const . push.n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 275506))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 275536)
           (push.iloc 2 . 0)
           (push.subr.gloc.of |.cons*| 4 "./boot/compile.scm" . 274461)
           (ret.subr.gloc.of |.list| "./boot/compile.scm" . 274461))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 2 . 0)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 276513))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 278555))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 280596))
   (cdr.iloc (2 . 0) "./boot/compile.scm" . 281624)
   (if.null?
     (push.const . subr.gloc.of)
     (push.car.iloc (2 . 0) "./boot/compile.scm" . 282658)
     (push.const 0)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 281613)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 282673)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 281613))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 283665))
 (set.gloc.of compile-subr-argument)
 (ret.const.unspec))
((close
   (2 0 . compile-argument-each)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of append)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 288808)
       (apply.gloc.of apply "./boot/compile.scm" . 288794))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 291862)
     (call
       (touch.gloc.of compile-argument)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 290857)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 290839))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 291856))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 287749))
 (set.gloc.of compile-argument-each)
 (ret.const.unspec))
((close
   (2 0 . compile-argument)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 296995)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 296979))
     (if.true
       (touch.gloc.of compile-subr-argument)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-subr-argument "./boot/compile.scm" . 298003))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 299032)
     (const . lambda)
     (if.eq?
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 300086)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 300098)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 300110))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 300063))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of local-closure?)
         (push.iloc.1 . 0)
         (apply.gloc.of local-closure? "./boot/compile.scm" . 301081))
       (if.true
         (push.const . push.close+)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of list "./boot/compile.scm" . 302105))
       (push.const . push.close)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 303129))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 304152)
     (const . quote)
     (if.eq?
       (push.const . push.const)
       (cadr.iloc (0 . 0) "./boot/compile.scm" . 305188)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 304146))
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 307223))
     (push)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 307260)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 306194)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 306194))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . push.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 309293)
       (ret.subr.gloc.of list "./boot/compile.scm" . 309287))
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 311319))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 312354))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 313375)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . push.iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 314418)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 314395))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . push.iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 315442)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 315419))
       (push.const . push.iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 316443))
     (push.const . push.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 311315)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 311315))
   (push.const . push.const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 318475))
 (set.gloc.of compile-argument)
 (ret.const.unspec))
((close
   (4 0 . compile-call)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 324624))
     (push)
     (push.const . apply)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 324661)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 323595)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 323595))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of iloc? "./boot/compile.scm" . 326675))
     (if.true
       (call
         (touch.gloc.of ht-local-closures)
         (apply.gloc.of ht-local-closures "./boot/compile.scm" . 327729))
       (push)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 327703)
       (if.true
         (push.const . apply.iloc+)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 3)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 328743))
         (push)
         (push.iloc.0 . 2)
         (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
       (push.const . apply.iloc)
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 329766))
       (push)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 327699)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 327699))
     (call
       (touch.gloc.of top-level-subr)
       (push.iloc.0 . 0)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 330771))
     (if.true
       (push.const . ret.subr.gloc.of)
       (push.iloc.0 . 0)
       (push.iloc.0 . 2)
       (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 330770)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 330770))
     (push.const . apply.gloc.of)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of |.cons*| 3 "./boot/compile.scm" . 332818)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 332818))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (push.const . apply)
   (iloc.0 . 2)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 334859))
 (set.gloc.of compile-call)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-begin)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 339985)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?
     (iloc.1 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 342045)
       (ret.subr.gloc.of list "./boot/compile.scm" . 342039))
     (ret.const))
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 343061)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 344098)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 344078))
   (touch.gloc.of compile-expression-seq)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 346126))
 (set.gloc.of compile-expression-begin)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-quote)
   (iloc.0 . 2)
   (if.true.ret.const)
   (iloc.0 . 3)
   (if.true
     (push.const . ret.const)
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 352269))
   (push.const . const)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 353293))
 (set.gloc.of compile-expression-quote)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-define)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 357413)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 357393))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 359454)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 357381)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 358434)
       (ret.subr.gloc.of list "./boot/compile.scm" . 358428))
     (ret.const))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 357381))
 (set.gloc.of compile-expression-define)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-set!)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 363557)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 363537))
   (push)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 364578)
       (ret.subr.gloc.of list "./boot/compile.scm" . 364572))
     (ret.const))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of iloc?)
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 365589)
     (push.iloc.1 . 1)
     (apply.gloc.of iloc? "./boot/compile.scm" . 365582))
   (if.true
     (push.iloc.0 . 0)
     (push.const . set.iloc)
     (call
       (touch.gloc.of make-iloc-operand)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 366646)
       (push.iloc.1 . 1)
       (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 366627))
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 365581))
   (push.iloc.0 . 0)
   (call
     (subr.gloc.of backtrace 0 "./boot/compile.scm" . 368671)
     (if.true
       (touch.gloc.of compile-touch)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 368698)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-touch "./boot/compile.scm" . 368683))
     (ret.const))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 369711)
   (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 368654)
   (iloc.0 . 1)
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 368654)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 368654))
 (set.gloc.of compile-expression-set!)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-lambda)
   (call
     (touch.gloc.of compile-lambda-helper)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 373800)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 373812)
     (call
       (touch.gloc.of make-closure-comment)
       (push.iloc.0 . 0)
       (apply.gloc.of make-closure-comment "./boot/compile.scm" . 373824))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 373777))
   (push)
   (extend . 1)
   (iloc.1 . 2)
   (if.true.ret.const)
   (iloc.1 . 3)
   (if.true
     (push.const . ret.close)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 375821))
   (push.const . close)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 376845))
 (set.gloc.of compile-expression-lambda)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-let)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 380947)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 381988)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 381964))
   (call
     (touch.gloc.of collect-local-closure)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 384035)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 384012))
   (call
     (push.gloc.of car)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 385057)
     (apply.gloc.of map "./boot/compile.scm" . 385048))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of compile-argument-each)
     (call
       (push.gloc.of cadr)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 386111)
       (apply.gloc.of map "./boot/compile.scm" . 386101))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 386078))
   (push)
   (push.const . extend)
   (push.iloc.0 . 0)
   (subr.gloc.of length 1 "./boot/compile.scm" . 387113)
   (push.cons)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (1 . 0) "./boot/compile.scm" . 388152)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 388164))
     (push)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 388128))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 386068)
   (extend . 1)
   (iloc 2 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 389150))
 (set.gloc.of compile-expression-let)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (push.const . set.iloc)
   (iloc.0 . 0)
   (push.cons)
   (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 426038)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 426038))
 (set.gloc.of |.fn1.1`1|)
 (close
   (4 0 . compile-expression-letrec*)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 393235)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 394276)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 394252))
   (push.iloc.0 . 0)
   (subr.gloc.of cdadr 1 "./boot/compile.scm" . 395283)
   (if.null?
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 396315)
     (extend . 1)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 397360)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 397354)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 397337))
     (push)
     (extend . 1)
     (call
       (cadr.iloc (1 . 0) "./boot/compile.scm" . 398371)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 398392)
       (const . lambda)
       (ret.eq? "./boot/compile.scm" . 398387))
     (if.true
       (call
         (touch.gloc.of collect-local-closure)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 399406)
         (apply.gloc.of collect-local-closure "./boot/compile.scm" . 399383))
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 400419)
       (extend . 1)
       (call
         (call
           (touch.gloc.of local-closure?)
           (push.iloc.0 . 0)
           (apply.gloc.of local-closure? "./boot/compile.scm" . 403497))
         (if.true (ret.const . extend.enclose+))
         (ret.const . extend.enclose))
       (push)
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 401473)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 401485)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 401497))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 401450))
       (push.cons)
       (call
         (touch.gloc.of compile-expression-seq)
         (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 402498)
         (push.iloc.1 . 0)
         (push.const . #f)
         (push.const . #t)
         (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 402474))
       (push.cons)
       (extend . 1)
       (iloc 4 . 3)
       (if.true (ret.iloc 0 . 0))
       (push.const . call)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 405547))
     (push.const . extend.unbound)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-argument)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 408634)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 408616))
     (push)
     (push.const . enclose)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (2 . 0) "./boot/compile.scm" . 410688)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 410664))
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 407581)
     (push.cons)
     (extend . 1)
     (iloc 3 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 411687))
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 413724)
   (extend . 1)
   (call
     (touch.gloc.of collect-local-closure)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 414734))
   (push.close
     (0 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc 3 . 0)
         (push.const)
         (ret.subr.gloc.of values "./boot/compile.scm" . 418850))
       (push.iloc.0 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 419886)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (push.car.iloc (0 . 0) "./boot/compile.scm" . 420933)
         (push.const quote lambda)
         (ret.subr.gloc.of memq "./boot/compile.scm" . 420927))
       (if.true
         (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 421934)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 421950)
         (iloc.1 . 1)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/compile.scm" . 421928))
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 422960)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/compile.scm" . 422952))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/compile.scm" . 416796))
   (push.close
     (2 0)
     (call
       (touch.gloc.of cte-extend-iloc)
       (call (push.gloc.of car) (push.iloc.1 . 0) (apply.gloc.of map "./boot/compile.scm" . 423980))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 423963))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of compile-argument-each)
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/compile.scm" . 425019))
       (push)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 424996))
     (push)
     (call
       (push.gloc.of append)
       (call
         (push.gloc.of |.fn1.1`1|)
         (call
           (touch.gloc.of iloc-iota)
           (push.const . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427075)
           (push.iloc.1 . 1)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427090)
           (apply.gloc.of iloc-iota "./boot/compile.scm" . 427062))
         (push)
         (call
           (push.close
             (1 0)
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 428123)
             (push.iloc.1 . 0)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 428103))
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/compile.scm" . 428086))
         (push)
         (apply.gloc.of map "./boot/compile.scm" . 426033))
       (push)
       (apply.gloc.of apply "./boot/compile.scm" . 426019))
     (push)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 429115)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 429091))
     (push)
     (extend . 3)
     (call
       (iloc.0 . 0)
       (if.null?
         (push.const . extend.unbound)
         (push.iloc 3 . 0)
         (subr.gloc.of length 1 "./boot/compile.scm" . 431161)
         (push.cons)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
         (ret.cons "./boot/compile.scm" . 430112))
       (push.const . extend.unbound)
       (push.iloc 3 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432185)
       (push.cons)
       (push.iloc.0 . 0)
       (push.const . enclose)
       (push.iloc.0 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432229)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (push.cons)
       (subr.gloc.of |.append| 2 "./boot/compile.scm" . 430112)
       (ret.cons "./boot/compile.scm" . 430112))
     (push)
     (extend . 1)
     (iloc 5 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 433188))
   (apply.gloc.of |.call-with-values| "./boot/compile.scm" . 413708))
 (set.gloc.of compile-expression-letrec*)
 (ret.const.unspec))
((close
   (5 0 . compile-unary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/compile.scm" . 460820)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 461845)
   (extend . 2)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 462875))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 463900))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 464945)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 464925))
   (push)
   (extend . 3)
   (call
     (push.iloc 2 . 4)
     (const . if.null?.ret.const)
     (if.not.eq?.ret.const . #f)
     (iloc.1 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (ret.eq? "./boot/compile.scm" . 466000))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 466970)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 466970))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 4)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 467994)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 467994)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 467994))
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 470052)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 470075)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 470069))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 471109)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 471070))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 472094)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 472094))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 473118))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 474142)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 474142))
 (set.gloc.of |compile-unary-special`2|)
 (close
   (4 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 441390)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 441370))
   (push)
   (extend . 1)
   (call
     (cdr.iloc (0 . 0) "./boot/compile.scm" . 442395)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 442417)
     (const . const)
     (ret.eq? "./boot/compile.scm" . 442412))
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of cdar 1 "./boot/compile.scm" . 443411)
     (if.true
       (touch.gloc.of compile-expression)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 444455)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 444435))
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 445479)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 445459))
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 446517)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 446497))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 447540)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 447520))
   (push)
   (extend . 2)
   (call
     (cadr.iloc (2 . 0) "./boot/compile.scm" . 448547)
     (if.not.symbol?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 448565)
     (push.iloc 2 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 448577)
     (ret.eq? "./boot/compile.scm" . 448560))
   (if.true
     (iloc 2 . 3)
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 449584)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 449563))
     (push.const . call)
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 450587)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 450587))
   (iloc 2 . 3)
   (if.true
     (call
       (cdr.iloc (0 . 1) "./boot/compile.scm" . 452652)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 1)
       (push.subr.gloc.of caar 1 "./boot/compile.scm" . 452674)
       (const . ret.const)
       (ret.eq? "./boot/compile.scm" . 452669))
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret.const)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 453700)
       (push.cons)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 452636))
   (push.const . call)
   (push.iloc.1 . 0)
   (push.const . if.true)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 0)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 455707)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 455707))
 (set.gloc.of |compile-anonymous`2|)
 (close
   (5 0 . compile-binary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cdadr 1 "./boot/compile.scm" . 478229)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 479253)
   (extend . 2)
   (call
     (touch.gloc.of compile-argument)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 480309)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 480291))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 481335)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 481315))
   (push)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 480283)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 482332))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 483377)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 483357))
   (push)
   (extend . 3)
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 484381)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 484404)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 484398))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 485438)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of |.append| "./boot/compile.scm" . 485399))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 486423)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 486423))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 487447))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of |.append| 2 "./boot/compile.scm" . 488471)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 488471))
 (set.gloc.of |compile-binary-special`2|)
 (close
   (4 0 . compile-expression-if)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/compile.scm" . 492563)
   (if.null?
     (iloc.0 . 2)
     (if.true
       (touch.gloc.of compile-expression)
       (push.const . and)
       (cdr.iloc (0 . 0) "./boot/compile.scm" . 494636)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 494608))
     (touch.gloc.of compile-expression)
     (push.const . if)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 495659)
     (push.const (|.unspecified|))
     (subr.gloc.of |.append| 2 "./boot/compile.scm" . 495632)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 495632))
   (call
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 497695)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 497724)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 497708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 499750)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 499742)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.null?)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 502818))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.pair?)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 504866))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.symbol?)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`2| "./boot/compile.scm" . 506914))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 508962))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`2|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.eq?)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 512034))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 513078))
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 514127)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 514120)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 514100)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 514094)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515116))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515142))
         (if.true
           (touch.gloc.of |compile-binary-special`2|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.const . if.eq?)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`2| "./boot/compile.scm" . 516136))
         (touch.gloc.of |compile-anonymous`2|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 517160))
       (touch.gloc.of |compile-anonymous`2|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 519202))
     (touch.gloc.of |compile-anonymous`2|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.iloc 2 . 3)
     (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 521243))
   (touch.gloc.of |compile-anonymous`2|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of |compile-anonymous`2| "./boot/compile.scm" . 523283))
 (set.gloc.of compile-expression-if)
 (ret.const.unspec))
((close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 541733)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 541713))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 541790)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 541774))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 540683))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 537637)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 537617))
   (push)
   (push.const . if.false.ret.const)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 537707)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 537691))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 536587))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 547860)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 548897)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 548877))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 549920)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 549947)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 549931))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 553006)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 553018)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 554034)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 554061)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 554045))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 556089)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 556081)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 559157))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 561205))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 563253))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 565301))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 568373))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 569417))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 570464)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 570457)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 570439)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 570433)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571455))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571481))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.not.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 572475))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 573499))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 575541))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 577582))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 579622))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 580651)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 580643)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 583719))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 585767))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 587815))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 589863))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 592935))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 593979))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 595026)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 595019)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 595001)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 594995)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596017))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596043))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 597037))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 598061))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 600103))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 602144))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 604180))
 (set.gloc.of |compile-clause`2|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 533541)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 533521))
   (push)
   (push.const . if.true.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 533563)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 533601)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 533585))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 532491))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 545827)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 545809))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 545866)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 545846))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 545924)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 545908))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 544779)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 544779))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (4 0 . compile-expression-or)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 606227)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #f)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 608280))
     (push.const . const)
     (const . #f)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 609304))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 610323)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 611360)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 611340))
   (call
     (iloc.0 . 3)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 613400)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 614424)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of top-level-value-or-false)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caaddr 1 "./boot/compile.scm" . 615472)
       (apply.gloc.of top-level-value-or-false "./boot/compile.scm" . 615446))
     (push)
     (gloc.of assertion-violation)
     (ret.eq? "./boot/compile.scm" . 615441))
   (if.true
     (call
       (touch.gloc.of compile-expression)
       (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 616484)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616464))
     (push)
     (push.const . if.false.call)
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 616544)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616524))
     (push.cons)
     (push.subr.gloc.of |.list| 1 "./boot/compile.scm" . 612363)
     (ret.subr.gloc.of |.append| "./boot/compile.scm" . 612363))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 618536)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 618520))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 619548))
 (set.gloc.of compile-expression-or)
 (ret.const.unspec))
((close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 637989)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 637969))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 638046)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 638030))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 636939))
 (set.gloc.of |compile-unary-special`4|)
 (close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 633893)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 633873))
   (push)
   (push.const . if.true.ret.const)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 633962)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 633946))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 632843))
 (set.gloc.of |compile-anonymous-negate`4|)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 642083)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 642065))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 642122)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 642102))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 642180)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 642164))
   (push.cons)
   (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 641035)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 641035))
 (set.gloc.of |compile-binary-special`4|)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 644116)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 645153)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 645133))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 646176)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 646203)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 646187))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 649262)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 649274)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 650290)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 650317)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 650301))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 652345)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 652337)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.null?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 655413))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.pair?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 657461))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of |compile-unary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.symbol?.ret.const)
             (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 659509))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 661557))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of |compile-binary-special`4|)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.eq?.ret.const)
             (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 664629))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 665673))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 666720)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 666713)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 666695)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 666689)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667711))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667737))
             (if.true
               (touch.gloc.of |compile-binary-special`4|)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.eq?.ret.const)
               (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 668731))
             (touch.gloc.of |compile-anonymous-negate`4|)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 669755))
           (touch.gloc.of |compile-anonymous-negate`4|)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 671797))
         (touch.gloc.of |compile-anonymous-negate`4|)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 673838))
       (touch.gloc.of |compile-anonymous-negate`4|)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of |compile-anonymous-negate`4| "./boot/compile.scm" . 675878))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 676907)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 676899)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.null?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 679975))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.pair?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 682023))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of |compile-unary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.symbol?.ret.const)
         (apply.gloc.of |compile-unary-special`4| "./boot/compile.scm" . 684071))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 686119))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of |compile-binary-special`4|)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.eq?.ret.const)
         (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 689191))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 690235))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 691282)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 691275)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 691257)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 691251)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692273))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692299))
         (if.true
           (touch.gloc.of |compile-binary-special`4|)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.not.eq?.ret.const)
           (apply.gloc.of |compile-binary-special`4| "./boot/compile.scm" . 693293))
         (touch.gloc.of |compile-anonymous`4|)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 694317))
       (touch.gloc.of |compile-anonymous`4|)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 696359))
     (touch.gloc.of |compile-anonymous`4|)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 698400))
   (touch.gloc.of |compile-anonymous`4|)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of |compile-anonymous`4| "./boot/compile.scm" . 700436))
 (set.gloc.of |compile-clause`2|)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 629797)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 629777))
   (push)
   (push.const . if.false.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 629819)
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 629858)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 629842))
   (push.cons)
   (ret.subr.gloc.of |.append| "./boot/compile.scm" . 628747))
 (set.gloc.of |compile-anonymous`4|)
 (close
   (4 0 . compile-expression-and)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 702483)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #t)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 704536))
     (push.const . const)
     (const . #t)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 705560))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 706579)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 707616)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 707596))
   (call
     (touch.gloc.of |compile-clause`2|)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 709672)
     (push.iloc.0 . 1)
     (apply.gloc.of |compile-clause`2| "./boot/compile.scm" . 709656))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 710684))
 (set.gloc.of compile-expression-and)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . begin)
   (push.gloc.of compile-expression-begin)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 714757)
   (push.iloc.0 . 0)
   (push.const . quote)
   (push.gloc.of compile-expression-quote)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 715781)
   (push.iloc.0 . 0)
   (push.const . define)
   (push.gloc.of compile-expression-define)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 716805)
   (push.iloc.0 . 0)
   (push.const . set!)
   (push.gloc.of compile-expression-set!)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 717829)
   (push.iloc.0 . 0)
   (push.const . lambda)
   (push.gloc.of compile-expression-lambda)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 718853)
   (push.iloc.0 . 0)
   (push.const . let)
   (push.gloc.of compile-expression-let)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 719877)
   (push.iloc.0 . 0)
   (push.const . letrec*)
   (push.gloc.of compile-expression-letrec*)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 720901)
   (push.iloc.0 . 0)
   (push.const . if)
   (push.gloc.of compile-expression-if)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 721925)
   (push.iloc.0 . 0)
   (push.const . or)
   (push.gloc.of compile-expression-or)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 722949)
   (push.iloc.0 . 0)
   (push.const . and)
   (push.gloc.of compile-expression-and)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 723973)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 724997))
 (set.gloc.of ht-dispatch-expression)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of |loop`7|)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 735256)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 735274)
   (push.iloc.0 . 1)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 735266)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 735250))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . reverse-append)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/compile.scm" . 732169))
 (set.gloc.of |reverse-append`2|)
 (close
   (4 0 . compile-expression-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (touch.gloc.of |reverse-append`2|)
       (push.iloc.0 . 1)
       (apply.gloc.of |reverse-append`2| "./boot/compile.scm" . 740378))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 747542)
     (call
       (touch.gloc.of compile-expression)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 743448)
       (push.iloc 2 . 1)
       (call
         (iloc 2 . 2)
         (if.true.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 745515)
         (ret.pair? "./boot/compile.scm" . 745508))
       (push)
       (call
         (iloc 2 . 3)
         (if.false.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 746537)
         (ret.null? "./boot/compile.scm" . 746530))
       (push)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 742423))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 747536))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 739333))
 (set.gloc.of compile-expression-seq)
 (ret.const.unspec))
((close
   (4 0 . compile-expression)
   (iloc.0 . 0)
   (if.pair?
     (push.gloc.of ht-dispatch-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 755774)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 755731)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (0 . 0) "./boot/compile.scm" . 756773))
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 757795)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 757779))
     (if.true
       (touch.gloc.of compile-subr-expression)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-subr-expression "./boot/compile.scm" . 758803))
     (call
       (subr.gloc.of backtrace 0 "./boot/compile.scm" . 762916)
       (if.true
         (touch.gloc.of compile-touch)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 762943)
         (push.iloc.1 . 1)
         (apply.gloc.of compile-touch "./boot/compile.scm" . 762928))
       (ret.const))
     (push)
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 761910)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 761887))
     (push)
     (call
       (touch.gloc.of compile-call)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 760877)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 760896)
       (push.subr.gloc.of length 1 "./boot/compile.scm" . 760888)
       (call
         (touch.gloc.of make-application-comment)
         (push.iloc.1 . 0)
         (apply.gloc.of make-application-comment "./boot/compile.scm" . 760908))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-call "./boot/compile.scm" . 760863))
     (push)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (push.subr.gloc.of |.append| 2 "./boot/compile.scm" . 763931)
     (extend . 1)
     (iloc 2 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 764965))
   (iloc.0 . 3)
   (if.true
     (push.iloc.0 . 0)
     (const . |.&UNDEF|)
     (if.eq?
       (push.const . ret.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 769053)
       (ret.subr.gloc.of list "./boot/compile.scm" . 769047))
     (push.iloc.0 . 0)
     (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 770071)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 771101)
       (ret.subr.gloc.of list "./boot/compile.scm" . 771095))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of iloc?)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 773147))
       (if.true
         (push.const . ret.iloc)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 774185))
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
       (push.const . ret.gloc.of)
       (push.iloc.0 . 0)
       (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 773143)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 773143))
     (push.const . ret.const)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 776214))
   (iloc.0 . 2)
   (if.true.ret.const)
   (push.iloc.0 . 0)
   (const . |.&UNDEF|)
   (if.eq?
     (push.const . const.undef)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 780317)
     (ret.subr.gloc.of list "./boot/compile.scm" . 780311))
   (push.iloc.0 . 0)
   (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 781335)
   (if.true
     (push.const . const.unspec)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 782365)
     (ret.subr.gloc.of list "./boot/compile.scm" . 782359))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 784411))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 785446))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 786467)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 787505)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 787487))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 788529)
         (push.cons)
         (ret.subr.gloc.of |.list| "./boot/compile.scm" . 788511))
       (push.const . iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of |.list| "./boot/compile.scm" . 789535))
     (push.const . gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of |.list| 2 "./boot/compile.scm" . 784407)
     (ret.subr.gloc.of |.list| "./boot/compile.scm" . 784407))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of |.list| "./boot/compile.scm" . 791574))
 (set.gloc.of compile-expression)
 (ret.const.unspec))
((close
   (1 0 . compile-coreform)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of ht-local-closures)
       (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
     (set.iloc 1 . 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 1)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of compile-expression)
     (push.iloc 2 . 0)
     (push.const)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 0)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (apply.gloc.of |.dynamic-wind| "./boot/compile.scm" . 797703))
 (set.gloc.of compile-coreform)
 (ret.const.unspec))

;
((close
   (3 0 . dynamic-wind)
   (call (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 11269))
   (call
     (touch.gloc.of current-dynamic-wind-record)
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (push.cons)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12342))
     (push.cons)
     (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12293))
   (push.iloc.0 . 1)
   (push.close
     (0 1)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16429))
       (push)
       (push.subr.gloc.of cdr 1 "./boot/dynamic-wind.scm" . 16424)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16395))
     (call (apply.iloc (1 . 2) "./boot/dynamic-wind.scm" . 17419))
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/dynamic-wind.scm" . 18443))
   (apply.gloc.of call-with-values "./boot/dynamic-wind.scm" . 13317))
 (set.gloc.of dynamic-wind)
 (ret.const.unspec))
((close
   (2 0 . common-tail)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25619)
   (push.iloc.0 . 1)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25635)
   (extend . 2)
   (touch.gloc.of |.L0`9|)
   (call
     (iloc.0 . 0)
     (>.iloc (0 . 1) "./boot/dynamic-wind.scm" . 26647)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 26670)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 26657))
     (ret.iloc 1 . 0))
   (push)
   (call
     (iloc.0 . 1)
     (>.iloc (0 . 0) "./boot/dynamic-wind.scm" . 27671)
     (if.true
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 27694)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 27681))
     (ret.iloc 1 . 1))
   (push)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |common-tail`2|)
 (close
   (2 0 . |.L0|)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq? (ret.iloc 0 . 0))
   (touch.gloc.of |.L0`9|)
   (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 26684)
   (push.cdr.iloc (0 . 1) "./boot/dynamic-wind.scm" . 27708)
   (apply.gloc.of |.L0`9| "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of |.L0`9|)
 (close
   (3 0 . perform-dynamic-wind)
   (call
     (call
       (touch.gloc.of |common-tail`2|)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 30754))
       (push)
       (apply.gloc.of |common-tail`2| "./boot/dynamic-wind.scm" . 30737))
     (push)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.const.unspec))
         (call
           (touch.gloc.of current-dynamic-wind-record)
           (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 33837)
           (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 33808))
         (call (push.iloc.0 . 0) (subr.gloc.of cdar 1 "./boot/dynamic-wind.scm" . 34833) (apply))
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 35862)
         (apply.iloc+ (1 . 0) "./boot/dynamic-wind.scm" . 35856))
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 31767))
       (push)
       (apply.iloc+ (0 . 0) "./boot/dynamic-wind.scm" . 31751))
     (extend.enclose
       (1 0 . loop)
       (push.iloc.0 . 0)
       (iloc 2 . 0)
       (if.eq? (ret.const.unspec))
       (call
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 38934)
         (apply.iloc (1 . 0) "./boot/dynamic-wind.scm" . 38928))
       (call (push.iloc.0 . 0) (subr.gloc.of caar 1 "./boot/dynamic-wind.scm" . 39953) (apply))
       (touch.gloc.of current-dynamic-wind-record)
       (push.iloc.0 . 0)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 40976))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 36871))
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of apply "./boot/dynamic-wind.scm" . 41989))
 (set.gloc.of perform-dynamic-wind)
 (ret.const.unspec))
((close (0 0) (ret.const . #f))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . call-with-port)
   (push.gloc.of |.fn1.1`1|)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/dynamic-wind.scm" . 48145))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of close-port "./boot/dynamic-wind.scm" . 49169))
   (apply.gloc.of dynamic-wind "./boot/dynamic-wind.scm" . 46085))
 (set.gloc.of call-with-port)
 (ret.const.unspec))

;
((close
   (1 0 . raise)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 7180))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 9233))
     (call
       (call (apply.gloc.of make-non-continuable-violation "./boot/exception.scm" . 10274))
       (push)
       (call (push.const . raise) (apply.gloc.of make-who-condition "./boot/exception.scm" . 11298))
       (push)
       (call
         (push.const . "returned from non-continuable exception")
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 12322))
       (push)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of list 1 "./boot/exception.scm" . 13372)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 13346))
       (push)
       (apply.gloc.of condition "./boot/exception.scm" . 10263))
     (push)
     (apply.iloc (0 . 0) "./boot/exception.scm" . 10257))
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 15372))
   (push.const . "error in raise: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 16479))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 16396))
 (set.gloc.of raise)
 (ret.const.unspec))
((close
   (1 0 . raise-continuable)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 20492))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 21534))
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 23564))
   (push.const . "error in raise-continuable: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 24683))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 24588))
 (set.gloc.of raise-continuable)
 (ret.const.unspec))
((close
   (2 0 . with-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 28691))
   (push)
   (extend . 1)
   (push.const . #f)
   (push.close
     (1 0 . tmp2)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-exception-handler)
         (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
       (set.iloc 1 . 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc 3 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
     (push.close (0 0) (push.iloc 2 . 0) (apply.iloc (4 . 0) "./boot/exception.scm" . 33809))
     (push.close
       (0 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 33809))
     (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 33809))
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
     (set.iloc 1 . 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 1)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
   (push.close (0 0) (apply.iloc (3 . 1) "./boot/exception.scm" . 34825))
   (push.close
     (0 0)
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 0)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 34825))
   (apply.gloc.of |.dynamic-wind| "./boot/exception.scm" . 34825))
 (set.gloc.of with-exception-handler)
 (ret.const.unspec))
((close
   (2 1 . assertion-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 42011))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 43044))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 44059))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 45106))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 42005)
       (apply.gloc.of filter "./boot/exception.scm" . 40973))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 39942))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 38917))
 (set.gloc.of assertion-violation)
 (ret.const.unspec))
((close
   (1 1 . undefined-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 52251))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 53284))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 54344)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 54320))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 52245)
       (apply.gloc.of filter "./boot/exception.scm" . 51213))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 50182))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 49157))
 (set.gloc.of undefined-violation)
 (ret.const.unspec))
((close
   (1 1 . lexical-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-lexical-violation "./boot/exception.scm" . 61467))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 62500))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 63560)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 63536))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 61461)
       (apply.gloc.of filter "./boot/exception.scm" . 60429))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 59398))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 58373))
 (set.gloc.of lexical-violation)
 (ret.const.unspec))
((close
   (3 1 . syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 70732))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 70683))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 71716))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 72731))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 70677)
       (apply.gloc.of filter "./boot/exception.scm" . 69645))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 68614))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 67589))
 (set.gloc.of syntax-violation)
 (ret.const.unspec))
((close
   (2 1 . error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-error "./boot/exception.scm" . 79899))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 80932))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 81947))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 82994))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 79893)
       (apply.gloc.of filter "./boot/exception.scm" . 78861))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 77830))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 76805))
 (set.gloc.of error)
 (ret.const.unspec))
((close
   (2 1 . implementation-restriction-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (apply.gloc.of make-implementation-restriction-violation "./boot/exception.scm" . 90139))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 91172))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 92187))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 93234))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 90133)
       (apply.gloc.of filter "./boot/exception.scm" . 89101))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 88070))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 87045))
 (set.gloc.of implementation-restriction-violation)
 (ret.const.unspec))
((close
   (3 1 . undefined/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 100428))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 100379))
       (push)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 101403))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 102436))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 103451))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 100373)
       (apply.gloc.of filter "./boot/exception.scm" . 99341))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 98310))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 97285))
 (set.gloc.of undefined/syntax-violation)
 (ret.const.unspec))
((close
   (0 1 . scheme-error)
   (push.const . #t)
   (push.const . "~!")
   (subr.gloc.of format 2 "./boot/exception.scm" . 107525)
   (subr.gloc.of current-error-port 0)
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 108589))
   (if.true
     (call
       (push.gloc.of format)
       (push.iloc.1 . 0)
       (apply.gloc.of apply "./boot/exception.scm" . 109594))
     (push)
     (apply.gloc.of raise "./boot/exception.scm" . 109587))
   (push.iloc.0 . 0)
   (push.const . "~&~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 111630)
   (call
     (push.gloc.of format)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of apply "./boot/exception.scm" . 112654))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 113678)
   (subr.gloc.of display-backtrace 0 "./boot/exception.scm" . 114702)
   (push.iloc.0 . 0)
   (push.const . "~%[exit]~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 115726)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/exception.scm" . 116750))
 (set.gloc.of scheme-error)
 (ret.const.unspec))
((close
   (3 1 . raise-i/o-filename-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-i/o-filename-error "./boot/exception.scm" . 123931))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 124964))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 125979))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 127026))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 123925)
       (apply.gloc.of filter "./boot/exception.scm" . 122893))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 121862))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 120837))
 (set.gloc.of raise-i/o-filename-error)
 (ret.const.unspec))
((close
   (2 1 . raise-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-i/o-error "./boot/exception.scm" . 134171))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 135204))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 136219))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 137266))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 134165)
       (apply.gloc.of filter "./boot/exception.scm" . 133133))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 132102))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 131077))
 (set.gloc.of raise-i/o-error)
 (ret.const.unspec))
((close
   (4 1 . raise-misc-i/o-error-with-port)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 4)
         (apply.gloc.of apply "./boot/exception.scm" . 145435))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 146468))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 147483))
       (push)
       (call
         (iloc.0 . 3)
         (if.false.ret)
         (push.iloc.0 . 3)
         (apply.gloc.of make-i/o-port-error "./boot/exception.scm" . 148517))
       (push)
       (call
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (push.subr.gloc.of cons* 2 "./boot/exception.scm" . 149557)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 149531))
       (push)
       (push.subr.gloc.of list 5 "./boot/exception.scm" . 145429)
       (apply.gloc.of filter "./boot/exception.scm" . 144397))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 143366))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 142341))
 (set.gloc.of raise-misc-i/o-error-with-port)
 (ret.const.unspec))
((close
   (3 1 . raise-misc-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of apply "./boot/exception.scm" . 156699))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 157732))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 158747))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 160800))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 156693)
       (apply.gloc.of filter "./boot/exception.scm" . 155661))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 154630))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 153605))
 (set.gloc.of raise-misc-i/o-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-read-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-read-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 164869))
 (set.gloc.of raise-i/o-read-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-write-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-write-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 168965))
 (set.gloc.of raise-i/o-write-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-protection-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-protection-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 173061))
 (set.gloc.of raise-i/o-file-protection-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-is-read-only-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-file-is-read-only-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 177157))
 (set.gloc.of raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-already-exists-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-already-exists-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 181253))
 (set.gloc.of raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-does-not-exist-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-does-not-exist-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 185349))
 (set.gloc.of raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-invalid-position-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-invalid-position-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 189445))
 (set.gloc.of raise-i/o-invalid-position-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-decoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-decoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 193541))
 (set.gloc.of raise-i/o-decoding-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-encoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-encoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 197637))
 (set.gloc.of raise-i/o-encoding-error)
 (ret.const.unspec))

;
((subr.gloc.of make-weak-core-hashtable 0 "./boot/record.scm" . 5156)
 (set.gloc.of nongenerative-record-types)
 (ret.const.unspec))
((close
   (6 0 . make-rtd)
   (push.const . type:record-type-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 9221))
 (set.gloc.of make-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 13322)
   (const . type:record-type-descriptor)
   (ret.eq? "./boot/record.scm" . 13317))
 (set.gloc.of record-type-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rtd-name)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 15395))
 (set.gloc.of rtd-name)
 (ret.const.unspec))
((close
   (1 0 . rtd-parent)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 16419))
 (set.gloc.of rtd-parent)
 (ret.const.unspec))
((close
   (1 0 . rtd-uid)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 17443))
 (set.gloc.of rtd-uid)
 (ret.const.unspec))
((close
   (1 0 . rtd-sealed?)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 18467))
 (set.gloc.of rtd-sealed?)
 (ret.const.unspec))
((close
   (1 0 . rtd-opaque?)
   (push.iloc.0 . 0)
   (push.const . 5)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 19491))
 (set.gloc.of rtd-opaque?)
 (ret.const.unspec))
((close
   (1 0 . rtd-fields)
   (push.iloc.0 . 0)
   (push.const . 6)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 20515))
 (set.gloc.of rtd-fields)
 (ret.const.unspec))
((close
   (2 0 . rtd-ancestor?)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 27670))
     (push)
     (apply.iloc+ (1 . 0) "./boot/record.scm" . 27664))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/record.scm" . 24581))
 (set.gloc.of rtd-ancestor?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`5|)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 33812))
     (push)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 34853))
     (push)
     (push.subr.gloc.of length 1 "./boot/record.scm" . 34845)
     (push.subr.gloc.of + 2 "./boot/record.scm" . 34836)
     (apply.gloc.of |loop`5| "./boot/record.scm" . 33806))
   (ret.iloc 0 . 1))
 (set.gloc.of |loop`5|)
 (close
   (1 0 . rtd-inherited-field-count)
   (touch.gloc.of |loop`5|)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 31765))
   (push)
   (push.const . 0)
   (apply.gloc.of |loop`5| "./boot/record.scm" . 31749))
 (set.gloc.of rtd-inherited-field-count)
 (ret.const.unspec))
((close
   (1 0 . rtd-total-field-count)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 40968))
   (push)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 41008))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 41000)
   (ret.subr.gloc.of + "./boot/record.scm" . 40965))
 (set.gloc.of rtd-total-field-count)
 (ret.const.unspec))
((close
   (1 0 . record-type-name)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 45065))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 46128))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 46089))
   (touch.gloc.of rtd-name)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-name "./boot/record.scm" . 47109))
 (set.gloc.of record-type-name)
 (ret.const.unspec))
((close
   (1 0 . record-type-parent)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 51209))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 52272))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 52233))
   (touch.gloc.of rtd-parent)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-parent "./boot/record.scm" . 53253))
 (set.gloc.of record-type-parent)
 (ret.const.unspec))
((close
   (1 0 . record-type-uid)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 57353))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 58416))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 58377))
   (touch.gloc.of rtd-uid)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-uid "./boot/record.scm" . 59397))
 (set.gloc.of record-type-uid)
 (ret.const.unspec))
((close
   (1 0 . record-type-generative?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 63497))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 64560))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 64521))
   (call
     (touch.gloc.of rtd-uid)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-uid "./boot/record.scm" . 65546))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 65541))
 (set.gloc.of record-type-generative?)
 (ret.const.unspec))
((close
   (1 0 . record-type-sealed?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 69641))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 70704))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 70665))
   (touch.gloc.of rtd-sealed?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-sealed? "./boot/record.scm" . 71685))
 (set.gloc.of record-type-sealed?)
 (ret.const.unspec))
((close
   (1 0 . record-type-opaque?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 75785))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 76848))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 76809))
   (touch.gloc.of rtd-opaque?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-opaque? "./boot/record.scm" . 77829))
 (set.gloc.of record-type-opaque?)
 (ret.const.unspec))
((close
   (1 0 . record-type-field-names)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 81929))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 82992))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 82953))
   (call
     (push.gloc.of cdr)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 83996))
     (push)
     (apply.gloc.of map "./boot/record.scm" . 83987))
   (push)
   (apply.gloc.of list->vector "./boot/record.scm" . 83973))
 (set.gloc.of record-type-field-names)
 (ret.const.unspec))
((close
   (2 0 . record-field-mutable?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 88073))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 89136))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 89197)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 89097))
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 90132))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-ref 2 "./boot/record.scm" . 90122)
   (ret.subr.gloc.of car "./boot/record.scm" . 90117))
 (set.gloc.of record-field-mutable?)
 (ret.const.unspec))
((close
   (6 0 . make-record-type-descriptor)
   (push.iloc.0 . 0)
   (subr.gloc.of symbol? 1 "./boot/record.scm" . 94217)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "symbol")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 96286))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 97310)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 95241))
   (push.iloc.0 . 5)
   (subr.gloc.of vector? 1 "./boot/record.scm" . 98313)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "vector")
       (push.iloc.0 . 5)
       (push.const . 6)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 100382))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 101406)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 99337))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 103438))
     (if.false.call
       (push.const . make-record-type-descriptor)
       (call
         (touch.gloc.of wrong-type-argument-message)
         (push.const . "record-type descriptor or #f")
         (push.iloc.0 . 1)
         (push.const . 2)
         (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 105507))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.iloc.0 . 4)
       (push.iloc.0 . 5)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 106531)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 104462))
     (if.false.ret)
     (call
       (touch.gloc.of rtd-sealed?)
       (push.iloc.0 . 1)
       (apply.gloc.of rtd-sealed? "./boot/record.scm" . 107535))
     (if.false.ret)
     (push.const . make-record-type-descriptor)
     (push.const . "attempt to extend a sealed record-type")
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 108559))
   (call
     (iloc.0 . 4)
     (if.true.ret)
     (iloc.0 . 1)
     (if.false.ret)
     (touch.gloc.of rtd-opaque?)
     (push.iloc.0 . 1)
     (apply.gloc.of rtd-opaque? "./boot/record.scm" . 111645))
   (push)
   (call
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (ret.null? "./boot/record.scm" . 113690))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . mutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #t)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . immutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #f)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (push.const . make-record-type-descriptor)
       (push.const . "malformed field specifiers")
       (push.iloc 2 . 5)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 113690))
     (push.iloc.0 . 5)
     (push.subr.gloc.of vector->list 1 "./boot/record.scm" . 120856)
     (apply.gloc.of map "./boot/record.scm" . 109573))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of make-rtd)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of make-rtd "./boot/record.scm" . 121874))
   (push)
   (extend . 1)
   (iloc 2 . 2)
   (if.true
     (push.gloc.of nongenerative-record-types)
     (push.iloc 2 . 2)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/record.scm" . 123920)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 125988))
         (push)
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 126002))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 125982)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127012))
         (push)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127029))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 127006)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128038))
         (push)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128055))
         (push)
         (ret.subr.gloc.of equal? "./boot/record.scm" . 128030))
       (if.true (ret.iloc 0 . 0))
       (push.const . make-record-type-descriptor)
       (push.const . "mismatched subsequent call for nongenerative record-type")
       (push.iloc 3 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (push.iloc 3 . 3)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 132142)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 130073))
     (push.gloc.of nongenerative-record-types)
     (push.iloc 3 . 2)
     (push.iloc.1 . 0)
     (subr.gloc.of core-hashtable-set! 3 "./boot/record.scm" . 134167)
     (ret.iloc 1 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of make-record-type-descriptor)
 (ret.const.unspec))
((close
   (4 0 . make-rcd)
   (push.const . type:record-constructor-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 138245))
 (set.gloc.of make-rcd)
 (ret.const.unspec))
((close
   (1 0 . record-constructor-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 142346)
   (const . type:record-constructor-descriptor)
   (ret.eq? "./boot/record.scm" . 142341))
 (set.gloc.of record-constructor-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rcd-rtd)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 144428))
 (set.gloc.of rcd-rtd)
 (ret.const.unspec))
((close
   (1 0 . rcd-protocol)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 145452))
 (set.gloc.of rcd-protocol)
 (ret.const.unspec))
((close
   (1 0 . rcd-custom-protocol?)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 146476))
 (set.gloc.of rcd-custom-protocol?)
 (ret.const.unspec))
((close
   (1 0 . rcd-parent)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 147500))
 (set.gloc.of rcd-parent)
 (ret.const.unspec))
((close
   (1 0)
   (ret.close
     (0 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/record.scm" . 160783)))
 (set.gloc.of |.fn2.1`2|)
 (close
   (1 0 . default-protocol)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 151571))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 153637))
     (push)
     (extend . 1)
     (ret.close
       (1 0)
       (ret.close
         (0 1)
         (push.close
           (0 0)
           (touch.gloc.of split-at)
           (push.iloc.1 . 0)
           (push.iloc 3 . 0)
           (apply.gloc.of split-at "./boot/record.scm" . 156743))
         (push.close
           (2 0)
           (call
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (apply.gloc.of apply "./boot/record.scm" . 157722))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of apply "./boot/record.scm" . 157715))
         (apply.gloc.of |.call-with-values| "./boot/record.scm" . 155663))))
   (ret.gloc.of |.fn2.1`2|))
 (set.gloc.of default-protocol)
 (ret.const.unspec))
((close
   (3 0 . make-record-constructor-descriptor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 164873))
   (if.false.call
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 166942))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 167966)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 165897))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of record-constructor-descriptor?)
       (push.iloc.0 . 1)
       (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 169998))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor or #f")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 172067))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 173091)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 171022))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (push.iloc.0 . 2)
     (subr.gloc.of procedure? 1 "./boot/record.scm" . 175118)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "procedure or #f")
       (push.iloc.0 . 2)
       (push.const . 3)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 177187))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 178211)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 176142))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 180238))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 181262))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 186378))
     (if.false.ret)
     (call
       (touch.gloc.of rcd-rtd)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-rtd "./boot/record.scm" . 187411))
     (push)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 187428))
     (if.eq?.ret.const . #t)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 188430))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 193546))
     (if.false.ret)
     (iloc.0 . 1)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "expected #f for protocol since no parent constructor descriptor is provided")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 195598))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rcd-custom-protocol?)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-custom-protocol? "./boot/record.scm" . 200714))
     (if.false.ret)
     (iloc.0 . 2)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const
       .
       "expected procedure for protocol since parent constructor descriptor have custom one")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 202766))
   (touch.gloc.of make-rcd)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 2)
     (if.true.ret)
     (touch.gloc.of default-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of default-protocol "./boot/record.scm" . 208930))
   (push)
   (call (iloc.0 . 2) (if.false.ret) (ret.const . #t))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 210974))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of make-record-constructor-descriptor "./boot/record.scm" . 213027))
     (ret.const . #f))
   (push)
   (apply.gloc.of make-rcd "./boot/record.scm" . 215047))
 (set.gloc.of make-record-constructor-descriptor)
 (ret.const.unspec))
((close
   (1 0 . record?)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 219171)
     (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 219146))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 220196)
     (apply.gloc.of record-type-opaque? "./boot/record.scm" . 220175))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 220170))
 (set.gloc.of record?)
 (ret.const.unspec))
((close
   (1 0 . record-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/record.scm" . 224265))
   (if.true
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 225289))
   (push.const . record-rtd)
   (call
     (touch.gloc.of wrong-type-argument-message)
     (push.const . "non-opaque record")
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 226346))
   (push)
   (apply.gloc.of assertion-violation "./boot/record.scm" . 226313))
 (set.gloc.of record-rtd)
 (ret.const.unspec))
((close
   (3 0 . make-nested-conser)
   (call
     (call
       (extend.enclose
         (1 0 . loop)
         (call
           (touch.gloc.of rcd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rcd-parent "./boot/record.scm" . 232464))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (ret.close
             (0 1)
             (ret.close
               (0 1)
               (ret.close
                 (0 1)
                 (call
                   (call
                     (call (push.iloc 3 . 0) (apply.iloc (5 . 0) "./boot/record.scm" . 238634))
                     (push)
                     (push.iloc.0 . 0)
                     (push.iloc 2 . 0)
                     (push.subr.gloc.of append 2 "./boot/record.scm" . 239658)
                     (apply.gloc.of apply "./boot/record.scm" . 238627))
                   (push)
                   (call
                     (touch.gloc.of rcd-protocol)
                     (push.iloc 3 . 0)
                     (apply.gloc.of rcd-protocol "./boot/record.scm" . 237603))
                   (apply))
                 (push)
                 (push.iloc.1 . 0)
                 (apply.gloc.of apply "./boot/record.scm" . 237595)))))
         (ret.close
           (0 1)
           (ret.close
             (0 1)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.subr.gloc.of append 2 "./boot/record.scm" . 244776)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of length 1 "./boot/record.scm" . 245789)
             (=.iloc (6 . 2) "./boot/record.scm" . 245786)
             (if.true
               (push.gloc.of tuple)
               (push.iloc 6 . 1)
               (push.iloc.0 . 0)
               (apply.gloc.of apply "./boot/record.scm" . 246810))
             (push.const . "record constructor")
             (push.const . "wrong number of arguments")
             (push.iloc.0 . 0)
             (apply.gloc.of assertion-violation "./boot/record.scm" . 247834))))
       (push.iloc.1 . 0)
       (apply.iloc (0 . 0) "./boot/record.scm" . 231431))
     (apply))
   (push)
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 230406))
   (apply))
 (set.gloc.of make-nested-conser)
 (ret.const.unspec))
((close
   (3 0 . make-simple-conser)
   (push.close
     (0 1)
     (push.iloc.0 . 0)
     (subr.gloc.of length 1 "./boot/record.scm" . 253967)
     (=.iloc (1 . 2) "./boot/record.scm" . 253964)
     (if.true
       (push.gloc.of tuple)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of apply "./boot/record.scm" . 254988))
     (push.const . "record constructor")
     (push.const . "wrong number of arguments")
     (push.iloc.0 . 0)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 256012))
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 251910))
   (apply))
 (set.gloc.of make-simple-conser)
 (ret.const.unspec))
((close
   (2 0 . flat-field-offset)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 260104))
   (push)
   (push.iloc.0 . 1)
   (push.const . 1)
   (ret.subr.gloc.of + "./boot/record.scm" . 260101))
 (set.gloc.of flat-field-offset)
 (ret.const.unspec))
((close
   (2 0 . make-accessor)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 265239)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 265258))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 266273)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 266254))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 266292))
     (push.const . "record accessor")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 268398))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 268370)
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 268341))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 268302)))
 (set.gloc.of make-accessor)
 (ret.const.unspec))
((close
   (2 0 . make-mutator)
   (ret.close
     (2 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 273431)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 273450))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 274465)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 274446))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 274484))
     (push.const . "record mutator")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 276589))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 276561)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of list 2 "./boot/record.scm" . 276605)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 276532))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 276494)))
 (set.gloc.of make-mutator)
 (ret.const.unspec))
((close
   (1 0 . make-predicate)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 281620)
     (if.eq?.ret.const . #t)
     (touch.gloc.of rtd-ancestor?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 282654)
     (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 282635)))
 (set.gloc.of make-predicate)
 (ret.const.unspec))
((close
   (1 0 . record-constructor)
   (call
     (touch.gloc.of record-constructor-descriptor?)
     (push.iloc.0 . 0)
     (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 286729))
   (if.false.call
     (push.const . record-constructor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 287794))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 287753))
   (call
     (touch.gloc.of rcd-rtd)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-rtd "./boot/record.scm" . 288784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of rcd-parent)
     (push.iloc.1 . 0)
     (apply.gloc.of rcd-parent "./boot/record.scm" . 289803))
   (if.true
     (touch.gloc.of make-nested-conser)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 290856))
     (push)
     (apply.gloc.of make-nested-conser "./boot/record.scm" . 290827))
   (touch.gloc.of make-simple-conser)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 291888))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 291880)
   (apply.gloc.of make-simple-conser "./boot/record.scm" . 291851))
 (set.gloc.of record-constructor)
 (ret.const.unspec))
((close
   (1 0 . record-predicate)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 295945))
   (if.false.call
     (push.const . record-predicate)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 297008))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 296969))
   (touch.gloc.of make-predicate)
   (push.iloc.0 . 0)
   (apply.gloc.of make-predicate "./boot/record.scm" . 297989))
 (set.gloc.of record-predicate)
 (ret.const.unspec))
((close
   (2 0 . record-accessor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 302089))
   (if.false.call
     (push.const . record-accssor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 303150))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 303209)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 303113))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 304153))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 304145)
   (subr.gloc.of < 3 "./boot/record.scm" . 304137)
   (if.false.call
     (push.const . record-accssor)
     (push.const . "field index out of range")
     (apply.gloc.of assertion-violation "./boot/record.scm" . 305161))
   (touch.gloc.of make-accessor)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 306200))
   (push)
   (apply.gloc.of make-accessor "./boot/record.scm" . 306181))
 (set.gloc.of record-accessor)
 (ret.const.unspec))
((close
   (2 0 . record-mutator)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 310281))
   (if.false.call
     (push.const . record-mutator)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 311342))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 311401)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 311305))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 312345))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 312337)
   (subr.gloc.of < 3 "./boot/record.scm" . 312329)
   (if.false.call
     (push.const . record-mutator)
     (push.const . "field index out of range")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 313417)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 313353))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of record-field-mutable? "./boot/record.scm" . 314377))
   (if.false.call
     (push.const . record-mutator)
     (push.const . "specified field is immutable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 315469)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 315401))
   (touch.gloc.of make-mutator)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 316439))
   (push)
   (apply.gloc.of make-mutator "./boot/record.scm" . 316421))
 (set.gloc.of record-mutator)
 (ret.const.unspec))
((close
   (3 0 . make-record-type)
   (push.const . type:record-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 320517))
 (set.gloc.of make-record-type)
 (ret.const.unspec))
((close
   (1 0 . record-type?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 324618)
   (const . type:record-type)
   (ret.eq? "./boot/record.scm" . 324613))
 (set.gloc.of record-type?)
 (ret.const.unspec))
((close
   (1 0 . record-type-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 328713))
   (if.false.call
     (push.const . record-type-rtd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 329775))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 329737))
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 330757))
 (set.gloc.of record-type-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-rcd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 334857))
   (if.false.call
     (push.const . record-type-rcd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 335919))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 335881))
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 336901))
 (set.gloc.of record-type-rcd)
 (ret.const.unspec))

;
((call
   (call
     (push.const . &condition)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 6159))
   (push)
   (extend . 1)
   (push.const . &condition)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 7183))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 8197))
 (set.gloc.of &condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition-component)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/condition.scm" . 10292))
 (set.gloc.of compound-condition-component)
 (ret.const.unspec))
((close
   (0 1 . condition)
   (push.const . type:condition)
   (call
     (push.gloc.of append)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of condition? "./boot/condition.scm" . 17438))
         (if.false.call
           (push.const . condition)
           (push.const . "expected condition, but got ~r")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/condition.scm" . 18494)
           (push.iloc.1 . 0)
           (apply.gloc.of assertion-violation "./boot/condition.scm" . 18462))
         (push.iloc.0 . 0)
         (apply.gloc.of simple-conditions "./boot/condition.scm" . 19482))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/condition.scm" . 16403))
     (push)
     (apply.gloc.of apply "./boot/condition.scm" . 15372))
   (push)
   (ret.subr.gloc.of tuple "./boot/condition.scm" . 14341))
 (set.gloc.of condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition?)
   (push.iloc.0 . 0)
   (subr.gloc.of tuple? 1 "./boot/condition.scm" . 24586)
   (if.false.ret)
   (push.const . type:condition)
   (push.iloc.0 . 0)
   (push.const . 0)
   (subr.gloc.of tuple-ref 2 "./boot/condition.scm" . 25631)
   (ret.eq? "./boot/condition.scm" . 25610))
 (set.gloc.of compound-condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-condition?)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/condition.scm" . 29706))
   (if.false.ret)
   (touch.gloc.of rtd-ancestor?)
   (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 30745))
   (push)
   (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 30774))
   (push)
   (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 30730))
 (set.gloc.of simple-condition?)
 (ret.const.unspec))
((close
   (1 0 . condition?)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 34825))
   (if.true.ret)
   (touch.gloc.of compound-condition?)
   (push.iloc.0 . 0)
   (apply.gloc.of compound-condition? "./boot/condition.scm" . 35849))
 (set.gloc.of condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-conditions)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 39948))
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of list "./boot/condition.scm" . 39970))
   (call
     (touch.gloc.of compound-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition? "./boot/condition.scm" . 40972))
   (if.true
     (touch.gloc.of compound-condition-component)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition-component "./boot/condition.scm" . 40996))
   (push.const . simple-conditions)
   (push.const . "expected condition, but got ~r")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/condition.scm" . 43060)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 43020))
 (set.gloc.of simple-conditions)
 (ret.const.unspec))
((close
   (1 0 . condition-predicate)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 47128))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 47113))
   (if.false.call
     (push.const . condition-predicate)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 48179)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 48137))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 50190))
     (if.true
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 51233))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 51214))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 52238))
     (if.true
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of rtd-ancestor?)
         (push.iloc 2 . 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 53307))
         (push)
         (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 53288))
       (call
         (touch.gloc.of compound-condition-component)
         (push.iloc.0 . 0)
         (apply.gloc.of compound-condition-component "./boot/condition.scm" . 54292))
       (push)
       (apply.gloc.of any1 "./boot/condition.scm" . 53262))
     (ret.const . #f)))
 (set.gloc.of condition-predicate)
 (ret.const.unspec))
((close
   (2 0 . wrong-type)
   (push.const . "condition accessor")
   (push.const . "expected condition of a subtype of ~s, but got ~r")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 3 "./boot/condition.scm" . 62515)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 62473))
 (set.gloc.of |wrong-type`2|)
 (close
   (2 0 . condition-accessor)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 64536))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 64521))
   (if.false.call
     (push.const . condition-accessor)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 65586)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 65545))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 68622))
     (if.true
       (call
         (call
           (touch.gloc.of rtd-ancestor?)
           (push.iloc.1 . 0)
           (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 69669))
           (push)
           (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 69650))
         (if.true.ret)
         (touch.gloc.of |wrong-type`2|)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 69687))
       (push.iloc.0 . 0)
       (apply.iloc (1 . 1) "./boot/condition.scm" . 70670))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 71694))
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of rtd-ancestor?)
             (push.iloc 2 . 0)
             (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 72775))
             (push)
             (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 72756))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call
           (touch.gloc.of compound-condition-component)
           (push.iloc.0 . 0)
           (apply.gloc.of compound-condition-component "./boot/condition.scm" . 73755))
         (push)
         (apply.gloc.of any1 "./boot/condition.scm" . 72725))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (apply.iloc (2 . 1) "./boot/condition.scm" . 72718))
       (touch.gloc.of |wrong-type`2|)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 76821))
     (touch.gloc.of |wrong-type`2|)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of |wrong-type`2| "./boot/condition.scm" . 78862)))
 (set.gloc.of condition-accessor)
 (ret.const.unspec))
((close
   (1 0 . list-parents)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of |loop`7| "./boot/condition.scm" . 86025))
 (set.gloc.of |list-parents`2|)
 (close
   (2 0 . loop)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-parent "./boot/condition.scm" . 87058))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of |loop`7|)
     (push.iloc.0 . 0)
     (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 88111))
     (push)
     (iloc.1 . 1)
     (push.cons)
     (apply.gloc.of |loop`7| "./boot/condition.scm" . 88097))
   (push.cdr.iloc (1 . 1) "./boot/condition.scm" . 89120)
   (ret.subr.gloc.of reverse "./boot/condition.scm" . 89111))
 (set.gloc.of |loop`7|)
 (close
   (2 0 . describe-condition)
   (call (push.iloc.0 . 1) (apply.gloc.of condition? "./boot/condition.scm" . 91148))
   (if.true
     (subr.gloc.of make-string-output-port 0)
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . "  #<condition~!")
     (subr.gloc.of format 2 "./boot/condition.scm" . 93198)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 96295))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of |list-parents`2|)
           (push.iloc.0 . 0)
           (apply.gloc.of |list-parents`2| "./boot/condition.scm" . 98349))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of record-type-field-names "./boot/condition.scm" . 99386))
         (push)
         (push.subr.gloc.of vector-length 1 "./boot/condition.scm" . 99371)
         (extend . 2)
         (push.iloc 3 . 0)
         (push.const . "~%    ~a")
         (call (push.iloc.1 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 97322))
         (push)
         (subr.gloc.of format 3 "./boot/condition.scm" . 100384)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (push.iloc 3 . 0)
           (push.const . " ~s")
           (push.iloc.0 . 0)
           (ret.subr.gloc.of format "./boot/condition.scm" . 101429))
         (=n.iloc (0 . 1) 1 "./boot/condition.scm" . 102439)
         (if.true
           (push.iloc 3 . 0)
           (push.const . ": ~s")
           (call
             (push.iloc 2 . 0)
             (call
               (push.iloc.1 . 0)
               (push.const . 0)
               (apply.gloc.of record-accessor "./boot/condition.scm" . 103483))
             (apply))
           (push)
           (ret.subr.gloc.of format "./boot/condition.scm" . 103463))
         (>n.iloc (0 . 1) 1 "./boot/condition.scm" . 104487)
         (if.true
           (extend.enclose+
             (2 0 . loop)
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.iloc 5 . 0)
             (push.const . "~%     ~a: ~s")
             (push.car.iloc (0 . 1) "./boot/condition.scm" . 109646)
             (call
               (push.iloc 4 . 0)
               (call
                 (push.iloc 3 . 0)
                 (push.iloc.0 . 0)
                 (apply.gloc.of record-accessor "./boot/condition.scm" . 109657))
               (apply))
             (push)
             (subr.gloc.of format 4 "./boot/condition.scm" . 109618)
             (push.n+.iloc (0 . 0) 1 "./boot/condition.scm" . 110648)
             (push.cdr.iloc (0 . 1) "./boot/condition.scm" . 110656)
             (apply.iloc+ (1 . 0) "./boot/condition.scm" . 110642))
           (push.const . 0)
           (call
             (push.iloc 2 . 0)
             (apply.gloc.of record-type-field-names "./boot/condition.scm" . 105536))
           (push)
           (push.subr.gloc.of vector->list 1 "./boot/condition.scm" . 105522)
           (apply.iloc+ (0 . 0) "./boot/condition.scm" . 106537))
         (ret.const.unspec))
       (call (push.iloc.1 . 1) (apply.gloc.of simple-conditions "./boot/condition.scm" . 94233))
       (push)
       (apply.gloc.of for-each "./boot/condition.scm" . 92172))
     (push.iloc.0 . 0)
     (push.const . "~%   >")
     (subr.gloc.of format 2 "./boot/condition.scm" . 112654)
     (push.iloc.1 . 0)
     (push.const . "~a~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/condition.scm" . 113698)
     (ret.subr.gloc.of format "./boot/condition.scm" . 113678))
   (push.iloc.0 . 0)
   (push.const . "~s~!")
   (push.iloc.0 . 1)
   (ret.subr.gloc.of format "./boot/condition.scm" . 115724))
 (set.gloc.of describe-condition)
 (ret.const.unspec))
((call
   (call
     (push.const . &message)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 118837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable message)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 118798))
   (push)
   (extend . 1)
   (push.const . &message)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 119864))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 119824))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 120839))
 (set.gloc.of &message)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 121908))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 121888))
 (set.gloc.of make-message-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 122929))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 122908))
 (set.gloc.of message-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123951))
   (push)
   (call
     (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123995))
     (push)
     (push.const . 0)
     (apply.gloc.of record-accessor "./boot/condition.scm" . 123978))
   (push)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 123931))
 (set.gloc.of condition-message)
 (ret.const.unspec))
((call
   (call
     (push.const . &warning)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 127029))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 126990))
   (push)
   (extend . 1)
   (push.const . &warning)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 128056))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 128016))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 129031))
 (set.gloc.of &warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 130090))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 130070))
 (set.gloc.of make-warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 131111))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 131090))
 (set.gloc.of warning?)
 (ret.const.unspec))
((call
   (call
     (push.const . &serious)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 134197))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 134158))
   (push)
   (extend . 1)
   (push.const . &serious)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 135224))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 135184))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 136199))
 (set.gloc.of &serious)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 137268))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 137248))
 (set.gloc.of make-serious-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 138289))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 138268))
 (set.gloc.of serious-condition?)
 (ret.const.unspec))
((call
   (call
     (push.const . &error)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 141363))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 141326))
   (push)
   (extend . 1)
   (push.const . &error)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 142392))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 142352))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 143367))
 (set.gloc.of &error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 144424))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 144404))
 (set.gloc.of make-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 145445))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 145424))
 (set.gloc.of error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &violation)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 148535))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 148494))
   (push)
   (extend . 1)
   (push.const . &violation)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 149560))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 149520))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 150535))
 (set.gloc.of &violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 151596))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 151576))
 (set.gloc.of make-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 152617))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 152596))
 (set.gloc.of violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &assertion)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 155703))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 155662))
   (push)
   (extend . 1)
   (push.const . &assertion)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 156728))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 156688))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 157703))
 (set.gloc.of &assertion)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 158774))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 158754))
 (set.gloc.of make-assertion-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 159795))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 159774))
 (set.gloc.of assertion-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &irritants)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 162871))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable irritants)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 162830))
   (push)
   (extend . 1)
   (push.const . &irritants)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 163896))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 163856))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 164871))
 (set.gloc.of &irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 165935))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 165918))
 (set.gloc.of &irritants-irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 166966))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 166946))
 (set.gloc.of make-irritants-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 167987))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 167966))
 (set.gloc.of irritants-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 169009))
   (push)
   (push.gloc.of &irritants-irritants)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 168989))
 (set.gloc.of condition-irritants)
 (ret.const.unspec))
((call
   (call
     (push.const . &who)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 172081))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable who)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 172046))
   (push)
   (extend . 1)
   (push.const . &who)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 173112))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 173072))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 174087))
 (set.gloc.of &who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 175139))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 175122))
 (set.gloc.of &who-who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 176176))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 176156))
 (set.gloc.of make-who-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 177197))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 177176))
 (set.gloc.of who-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 178219))
   (push)
   (push.gloc.of &who-who)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 178199))
 (set.gloc.of condition-who)
 (ret.const.unspec))
((call
   (call
     (push.const . &non-continuable)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 181309))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 181262))
   (push)
   (extend . 1)
   (push.const . &non-continuable)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 182328))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 182288))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 183303))
 (set.gloc.of &non-continuable)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 184380))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 184360))
 (set.gloc.of make-non-continuable-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 185401))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 185380))
 (set.gloc.of non-continuable-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &implementation-restriction)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 188488))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 188430))
   (push)
   (extend . 1)
   (push.const . &implementation-restriction)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 189496))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 189456))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 190471))
 (set.gloc.of &implementation-restriction)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 192535))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 192515))
 (set.gloc.of make-implementation-restriction-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 194584))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 194563))
 (set.gloc.of implementation-restriction-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &lexical)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 197685))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 197646))
   (push)
   (extend . 1)
   (push.const . &lexical)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 198712))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 198672))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 199687))
 (set.gloc.of &lexical)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 200756))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 200736))
 (set.gloc.of make-lexical-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 201777))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 201756))
 (set.gloc.of lexical-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &syntax)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 204852))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable form) (immutable subform)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 204814))
   (push)
   (extend . 1)
   (push.const . &syntax)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 205880))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 205840))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 206855))
 (set.gloc.of &syntax)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 207911))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 207894))
 (set.gloc.of &syntax-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 208938))
   (push)
   (push.const . 1)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 208921))
 (set.gloc.of &syntax-subform)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 209971))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 209951))
 (set.gloc.of make-syntax-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 210992))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 210971))
 (set.gloc.of syntax-violation?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 212019))
   (push)
   (push.gloc.of &syntax-form)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 211999))
 (set.gloc.of syntax-violation-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 213046))
   (push)
   (push.gloc.of &syntax-subform)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 213026))
 (set.gloc.of syntax-violation-subform)
 (ret.const.unspec))
((call
   (call
     (push.const . &undefined)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 216119))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 216078))
   (push)
   (extend . 1)
   (push.const . &undefined)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 217144))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 217104))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 218119))
 (set.gloc.of &undefined)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 219190))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 219170))
 (set.gloc.of make-undefined-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 220211))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 220190))
 (set.gloc.of undefined-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 223281))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 223246))
   (push)
   (extend . 1)
   (push.const . &i/o)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 224312))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 224272))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 225287))
 (set.gloc.of &i/o)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 226348))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 226328))
 (set.gloc.of make-i/o-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 227369))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 227348))
 (set.gloc.of i/o-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-read)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 230454))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 230414))
   (push)
   (extend . 1)
   (push.const . &i/o-read)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 231480))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 231440))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 232455))
 (set.gloc.of &i/o-read)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 233521))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 233501))
 (set.gloc.of make-i/o-read-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 234542))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 234521))
 (set.gloc.of i/o-read-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-write)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 237623))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 237582))
   (push)
   (extend . 1)
   (push.const . &i/o-write)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 238648))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 238608))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 239623))
 (set.gloc.of &i/o-write)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 240690))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 240670))
 (set.gloc.of make-i/o-write-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 241711))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 241690))
 (set.gloc.of i/o-write-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-invalid-position)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 244802))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable position)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 244750))
   (push)
   (extend . 1)
   (push.const . &i/o-invalid-position)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 245816))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 245776))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 246791))
 (set.gloc.of &i/o-invalid-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 248852))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 248835))
 (set.gloc.of &i/o-invalid-position-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 250903))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 250883))
 (set.gloc.of make-i/o-invalid-position-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 251962))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 251941))
 (set.gloc.of i/o-invalid-position-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 253975))
   (push)
   (push.gloc.of &i/o-invalid-position-position)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 253955))
 (set.gloc.of i/o-error-position)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-filename)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 257082))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable filename)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 257038))
   (push)
   (extend . 1)
   (push.const . &i/o-filename)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 258104))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 258064))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 259079))
 (set.gloc.of &i/o-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 260145))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 260128))
 (set.gloc.of &i/o-filename-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 261173))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 261153))
 (set.gloc.of make-i/o-filename-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 262194))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 262173))
 (set.gloc.of i/o-filename-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 263216))
   (push)
   (push.gloc.of &i/o-filename-filename)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 263196))
 (set.gloc.of i/o-error-filename)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-protection)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 266305))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 266254))
   (push)
   (extend . 1)
   (push.const . &i/o-file-protection)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 267320))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 267280))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 268295))
 (set.gloc.of &i/o-file-protection)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 270359))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 270339))
 (set.gloc.of make-i/o-file-protection-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 271417))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 271396))
 (set.gloc.of i/o-file-protection-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-is-read-only)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 274499))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 274446))
   (push)
   (extend . 1)
   (push.const . &i/o-file-is-read-only)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 275512))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 275472))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 276487))
 (set.gloc.of &i/o-file-is-read-only)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 277566))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 277546))
 (set.gloc.of make-i/o-file-is-read-only-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 278587))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 278566))
 (set.gloc.of i/o-file-is-read-only-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-already-exists)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 281669))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 281614))
   (push)
   (extend . 1)
   (push.const . &i/o-file-already-exists)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 282680))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 282640))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 283655))
 (set.gloc.of &i/o-file-already-exists)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 284736))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 284716))
 (set.gloc.of make-i/o-file-already-exists-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 285757))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 285736))
 (set.gloc.of i/o-file-already-exists-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-does-not-exist)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 288837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 288782))
   (push)
   (extend . 1)
   (push.const . &i/o-file-does-not-exist)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 289848))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 289808))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 290823))
 (set.gloc.of &i/o-file-does-not-exist)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 291904))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 291884))
 (set.gloc.of make-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 292925))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 292904))
 (set.gloc.of i/o-file-does-not-exist-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-port)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 295990))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable port)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 295950))
   (push)
   (extend . 1)
   (push.const . &i/o-port)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 297016))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 296976))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 297991))
 (set.gloc.of &i/o-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 299049))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 299032))
 (set.gloc.of &i/o-port-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 300081))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 300061))
 (set.gloc.of make-i/o-port-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 301102))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 301081))
 (set.gloc.of i/o-port-error?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 302124))
   (push)
   (push.gloc.of &i/o-port-port)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 302104))
 (set.gloc.of i/o-error-port)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-decoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 305210))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 305166))
   (push)
   (extend . 1)
   (push.const . &i/o-decoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 306232))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 306192))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 307207))
 (set.gloc.of &i/o-decoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 308277))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 308257))
 (set.gloc.of make-i/o-decoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 309298))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 309277))
 (set.gloc.of i/o-decoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-encoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 312378))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable char)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 312334))
   (push)
   (extend . 1)
   (push.const . &i/o-encoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 313400))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 313360))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 314375))
 (set.gloc.of &i/o-encoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 315437))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 315420))
 (set.gloc.of &i/o-encoding-char)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 316469))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 316449))
 (set.gloc.of make-i/o-encoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 317490))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 317469))
 (set.gloc.of i/o-encoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 318517))
   (push)
   (push.gloc.of &i/o-encoding-char)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 318497))
 (set.gloc.of i/o-encoding-error-char)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-infinities)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 321595))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 321550))
   (push)
   (extend . 1)
   (push.const . &no-infinities)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 322616))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 322576))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 323591))
 (set.gloc.of &no-infinities)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 324666))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 324646))
 (set.gloc.of make-no-infinities-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 325687))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 325666))
 (set.gloc.of no-infinities-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-nans)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 328757))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 328718))
   (push)
   (extend . 1)
   (push.const . &no-nans)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 329784))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 329744))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 330759))
 (set.gloc.of &no-nans)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 331828))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 331808))
 (set.gloc.of make-no-nans-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 332849))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 332828))
 (set.gloc.of no-nans-violation?)
 (ret.const.unspec))

;
((call (push.const . 100) (apply.gloc.of make-parameter "./boot/pp.scm" . 62498))
 (set.gloc.of pretty-print-line-length)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/pp.scm" . 63525))
 (set.gloc.of pretty-print-initial-indent)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 64548))
 (set.gloc.of pretty-print-maximum-lines)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 65572))
 (set.gloc.of pretty-print-unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0 . parse)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (cddr.iloc (1 . 0) "./boot/pp.scm" . 149522)
       (ret.null? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (cddr.iloc (2 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "'")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quasiquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "`")
       (push.const . |.&NEST|)
       (push.const . 1)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote-splicing)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",@")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . let)
       (if.not.eq?.ret.const . #f)
       (cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (if.not.symbol?.ret.const . #f)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(let ~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 4)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type1?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type1?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type2?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type2?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (call
         (touch.gloc.of |symbol->length`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |symbol->length`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . 2)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of |indent-type3?`4|)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of |indent-type3?`4| "./boot/pp.scm" . 149522))
       (if.false.ret)
       (push.iloc 3 . 0)
       (subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.cdddr| 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of |.caddr| 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . |.&GROUP|)
       (push.const . "(~a ")
       (push.car.iloc (4 . 0) "./boot/pp.scm" . 149522)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . |.&NEST|)
       (push.const . 2)
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 2)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc.0 . 1)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.list| 5 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc.0 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of |.append| 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of |.cons*| 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of |.list| "./boot/pp.scm" . 149522))
     (call
       (iloc 3 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of symbol? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . |.&GROUP|)
       (push.const . "(")
       (push.const . |.&NEST|)
       (push.const . 2)
       (call
         (touch.gloc.of |parse-list`4|)
         (push.iloc 3 . 0)
         (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
     (push.const . |.&GROUP|)
     (push.const . "(")
     (push.const . |.&NEST|)
     (push.const . 1)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc 3 . 0)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 149522))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 149522)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 149522))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/pp.scm" . 184338)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/pp.scm" . 185369)
     (push.const . 0)
     (subr.gloc.of = 2 "./boot/pp.scm" . 185366)
     (if.true.ret.const . "#()")
     (push.const . |.&GROUP|)
     (push.const . "#(")
     (push.const . |.&NEST|)
     (push.const . 2)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 187453)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 187441))
     (push)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 185362)
     (push.const ")")
     (ret.subr.gloc.of |.cons*| "./boot/pp.scm" . 185362))
   (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/pp.scm" . 188434))
   (if.true
     (push.const . "~u")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/pp.scm" . 189458))
   (push.const . "~s")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/pp.scm" . 191506))
 (set.gloc.of |parse`4|)
 (close
   (1 0 . indent-type1?)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     define-macro
     define-inline
     define-constant
     syntax-rules
     syntax-case
     with-syntax
     lambda
     let-syntax
     letrec-syntax
     let
     letrec
     let*
     letrec
     letrec*
     let-values
     let*-values
     destructuring-match
     parameterize)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 74763))
 (set.gloc.of |indent-type1?`4|)
 (close
   (1 0 . symbol->length)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/pp.scm" . 134170)
   (ret.subr.gloc.of string-length "./boot/pp.scm" . 134155))
 (set.gloc.of |symbol->length`4|)
 (close
   (1 0 . infinite-print?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (3 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/pp.scm" . 197656)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/pp.scm" . 198680))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 200735)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/pp.scm" . 202795)
           (push.iloc.0 . 0)
           (push.iloc.1 . 2)
           (apply.iloc (2 . 0) "./boot/pp.scm" . 202789))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/pp.scm" . 203819)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/pp.scm" . 203813))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/pp.scm" . 204831)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 205855)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 2)
           (apply.iloc (3 . 0) "./boot/pp.scm" . 207923))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 207948)
         (apply.gloc.of any1 "./boot/pp.scm" . 207905))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/pp.scm" . 208927)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 209951)
         (>n.iloc (0 . 2) 0 "./boot/pp.scm" . 210980)
         (if.false.ret)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (push.n+.iloc (0 . 2) -1 "./boot/pp.scm" . 212048)
         (extend . 2)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (apply.iloc (3 . 0) "./boot/pp.scm" . 213048))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/pp.scm" . 213073)
         (apply.gloc.of any1 "./boot/pp.scm" . 213030))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (subr.gloc.of record-print-nesting-limit 0)
     (push)
     (apply.iloc (0 . 0) "./boot/pp.scm" . 196626))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of |infinite-print?`4|)
 (close
   (1 0 . indent-type2?)
   (push.iloc.0 . 0)
   (push.const if cond case and or set! import export cons map for-each exists for-all)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 82955))
 (set.gloc.of |indent-type2?`4|)
 (close
   (1 0 . parse-list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 139289)
   (if.null?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 140319)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 140312))
     (push)
     (ret.subr.gloc.of list "./boot/pp.scm" . 140306))
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 141337)
   (if.pair?
     (call
       (touch.gloc.of |parse`4|)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 142368)
       (apply.gloc.of |parse`4| "./boot/pp.scm" . 142361))
     (push)
     (push.const . #\;)
     (call
       (touch.gloc.of |parse-list`4|)
       (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 142395)
       (apply.gloc.of |parse-list`4| "./boot/pp.scm" . 142383))
     (push)
     (ret.subr.gloc.of cons* "./boot/pp.scm" . 142354))
   (call
     (touch.gloc.of |parse`4|)
     (push.car.iloc (0 . 0) "./boot/pp.scm" . 144415)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144408))
   (push)
   (push.const . #\;)
   (push.const . ".")
   (push.const . #\;)
   (call
     (touch.gloc.of |parse`4|)
     (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 144445)
     (apply.gloc.of |parse`4| "./boot/pp.scm" . 144438))
   (push)
   (ret.subr.gloc.of list "./boot/pp.scm" . 144402))
 (set.gloc.of |parse-list`4|)
 (close
   (2 0 . fits?)
   (>=n.iloc (0 . 0) 0 "./boot/pp.scm" . 91152)
   (if.false.ret)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 1) "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 2 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 3 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc 3 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&BREAK|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true.ret.const . #t)
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (const . |.&FLAT|)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.n+.iloc (4 . 0) -1 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (ret.subr.gloc.of string? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of - 2 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&GROUP|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.const . |.&FLAT|)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (const . |.&NEST|)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of |fits?`4|)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of + 2 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (iloc.0 . 0)
   (if.true
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 92180)
     (extend . 2)
     (touch.gloc.of |fits?`4|)
     (push.iloc 5 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (5 . 1) "./boot/pp.scm" . 92180)
     (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 92180)
     (apply.gloc.of |fits?`4| "./boot/pp.scm" . 92180))
   (ret.const . #f))
 (set.gloc.of |fits?`4|)
 (close
   (1 0 . indent-type3?)
   (push.iloc.0 . 0)
   (push.const do let-optionals)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 87051))
 (set.gloc.of |indent-type3?`4|)
 (close
   (1 1 . pretty-print)
   (call
     (iloc.0 . 1)
     (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of car "./boot/pp.scm" . 69666))
     (ret.subr.gloc.of current-output-port "./boot/pp.scm" . 69677))
   (push)
   (call
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70686))
     (if.false.ret)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70718))
     (push)
     (push.const . 1)
     (ret.subr.gloc.of - "./boot/pp.scm" . 70715))
   (push)
   (extend . 2)
   (extend.enclose
     (3 0 . print)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.gloc.of string?)
     (extend . 1)
     (call
       (iloc.1 . 2)
       (if.not.pair?.ret.const . #f)
       (car.iloc (1 . 2) "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cdar| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of |.cddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 2 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 3 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 4 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&BREAK|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (call
         (push.iloc 8 . 1)
         (const . #f)
         (if.eq?.ret.const . #t)
         (push.iloc 8 . 1)
         (push.const . 0)
         (ret.subr.gloc.of > "./boot/pp.scm" . 104463))
       (if.true
         (call
           (iloc 8 . 1)
           (if.false.ret)
           (n+.iloc (8 . 1) -1 "./boot/pp.scm" . 104463)
           (set.iloc 8 . 1)
           (ret.const.unspec))
         (push.iloc 8 . 0)
         (push.const . #\linefeed)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
         (call
           (extend.enclose+
             (1 0 . loop)
             (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.iloc 10 . 0)
             (push.const . #\space)
             (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 104463)
             (apply.iloc+ (1 . 0) "./boot/pp.scm" . 104463))
           (push.iloc.1 . 1)
           (apply.iloc+ (0 . 0) "./boot/pp.scm" . 104463))
         (push.iloc 6 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
       (ret.const.unspec))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (const . |.&FLAT|)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (extend . 1)
       (push.iloc 8 . 0)
       (push.const . #\space)
       (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.n+.iloc (6 . 1) 1 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (apply.iloc (4 . 0) "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 8 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of put-string 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&GROUP|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 3)
       (push.iloc.0 . 2)
       (push.const . |.&FLAT|)
       (push.iloc.0 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.0 . 0)
       (push.cons)
       (extend . 1)
       (call
         (touch.gloc.of |fits?`4|)
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.subr.gloc.of - 2 "./boot/pp.scm" . 104463)
         (push.iloc.0 . 0)
         (apply.gloc.of |fits?`4| "./boot/pp.scm" . 104463))
       (if.true
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
       (push.iloc 7 . 0)
       (push.iloc 7 . 1)
       (push.iloc.1 . 2)
       (push.const . |.&BREAK|)
       (push.iloc.1 . 1)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (iloc.1 . 0)
       (push.cons)
       (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of |.cdddar| 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (const . |.&NEST|)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cadr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cddr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.cons)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (iloc.0 . 0)
     (if.true
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.cadar| 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of |.caar| 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.car| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of |.caddar| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cdr| 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 104463)
       (push.cdr.iloc (6 . 2) "./boot/pp.scm" . 104463)
       (push.subr.gloc.of |.cons*| 3 "./boot/pp.scm" . 104463)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (ret.const . #f))
   (call
     (call
       (touch.gloc.of |infinite-print?`4|)
       (push.iloc 2 . 0)
       (apply.gloc.of |infinite-print?`4| "./boot/pp.scm" . 217099))
     (if.true
       (push.iloc.1 . 0)
       (push.const . "~w")
       (push.iloc 2 . 0)
       (ret.subr.gloc.of format "./boot/pp.scm" . 218123))
     (call (apply.gloc.of pretty-print-line-length "./boot/pp.scm" . 219160))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of collect-notify 0 "./boot/pp.scm" . 221199)
       (set.iloc 1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (push.close
       (0 0)
       (push.iloc 2 . 0)
       (push.const . 0)
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 221218))
       (push)
       (push.const . |.&FLAT|)
       (call
         (touch.gloc.of |parse`4|)
         (push.iloc 5 . 0)
         (apply.gloc.of |parse`4| "./boot/pp.scm" . 221256))
       (push)
       (push.subr.gloc.of |.list| 3 "./boot/pp.scm" . 221199)
       (push.subr.gloc.of |.list| 1 "./boot/pp.scm" . 221199)
       (apply.iloc (3 . 0) "./boot/pp.scm" . 221199))
     (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (apply.gloc.of |.dynamic-wind| "./boot/pp.scm" . 221199))
   (call
     (iloc.1 . 1)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of <= "./boot/pp.scm" . 222240))
   (if.true
     (push.iloc.1 . 0)
     (push.const . #\linefeed)
     (subr.gloc.of put-char 2 "./boot/pp.scm" . 223246)
     (call
       (extend.enclose+
         (1 0 . loop)
         (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 224321)
         (if.false.ret)
         (push.iloc 3 . 0)
         (push.const . #\space)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 224329)
         (if.false.ret)
         (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 224359)
         (apply.iloc+ (1 . 0) "./boot/pp.scm" . 224353))
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 224284))
       (push)
       (apply.iloc+ (0 . 0) "./boot/pp.scm" . 224270))
     (push.iloc.1 . 0)
     (push.const . "  ...")
     (ret.subr.gloc.of put-string "./boot/pp.scm" . 225294))
   (ret.const.unspec))
 (set.gloc.of pretty-print)
 (ret.const.unspec))

;
((close
   (1 0 . core-eval)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of backtrace 0 "./boot/eval.scm" . 8199)
     (set.iloc 1 . 0)
     (push.const . #f)
     (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (push.close
     (0 0)
     (touch.gloc.of interpret-coreform)
     (push.iloc 2 . 0)
     (apply.gloc.of interpret-coreform "./boot/eval.scm" . 8199))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of backtrace "./boot/eval.scm" . 8199))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 8199))
 (set.gloc.of core-eval)
 (ret.const.unspec))
((close
   (1 0 . compile)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
     (set.iloc 1 . 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 1)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 14361))
     (push)
     (apply.gloc.of compile-coreform "./boot/eval.scm" . 14343))
   (push.close
     (0 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 0)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 14343))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 14343))
 (set.gloc.of compile)
 (ret.const.unspec))
((close
   (1 0 . interpret)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call
     (push.const . #f)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
       (set.iloc 1 . 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 1)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 21536))
       (push)
       (apply.gloc.of compile-coreform "./boot/eval.scm" . 21518))
     (push.close
       (0 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 0)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 21518))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 21518))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 22535))
 (set.gloc.of interpret)
 (ret.const.unspec))
((close
   (1 0 . interpret-coreform)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call (push.iloc.0 . 0) (apply.gloc.of compile-coreform "./boot/eval.scm" . 26656))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 27655))
 (set.gloc.of interpret-coreform)
 (ret.const.unspec))
((close
   (0 1 . environment)
   (call
     (touch.gloc.of parse-imports)
     (push.const . environment)
     (iloc.0 . 0)
     (push.cons)
     (push.iloc.0 . 0)
     (apply.gloc.of parse-imports "./boot/eval.scm" . 31749))
   (push.const . type:eval-environment)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/eval.scm" . 32773))
 (set.gloc.of environment)
 (ret.const.unspec))
((close
   (2 0 . eval)
   (call
     (touch.gloc.of environment?)
     (push.iloc.0 . 1)
     (apply.gloc.of environment? "./boot/eval.scm" . 54284))
   (if.true
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 56334)
       (set.iloc 1 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 56334))
     (push.close
       (0 0)
       (touch.gloc.of interpret)
       (push.iloc 2 . 0)
       (apply.gloc.of interpret "./boot/eval.scm" . 56334))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 56334))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 56334))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 58389)
   (push.const . type:eval-environment)
   (subr.gloc.of eq? 2 "./boot/eval.scm" . 58384)
   (if.false.call
     (push.const . eval)
     (push.const . "expected environment, but got ~r, as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/eval.scm" . 59435)
     (apply.gloc.of assertion-violation "./boot/eval.scm" . 59408))
   (touch.gloc.of interpret)
   (push.const . begin)
   (push.const . library)
   (push.const |.R6RS-EVAL|)
   (push.const export)
   (push.const . import)
   (push.const
     rename
     (only (core primitives) set-top-level-value! string->symbol)
     (set-top-level-value! |.SET-TOP-LEVEL-VALUE!|)
     (string->symbol |.STRING->SYMBOL|))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 68646)
   (push.subr.gloc.of |.cons*| 3 "./boot/eval.scm" . 60428)
   (push.const . |.SET-TOP-LEVEL-VALUE!|)
   (push.const |.STRING->SYMBOL| ".R6RS-EVAL-RESULT")
   (push.iloc.0 . 0)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 60428)
   (push.subr.gloc.of |.list| 5 "./boot/eval.scm" . 60428)
   (push.const . let)
   (push.const (result |.R6RS-EVAL-RESULT|))
   (push.const set-top-level-value! '|.R6RS-EVAL-RESULT| |.&UNDEF|)
   (push.const . |.unintern-scheme-library|)
   (push.const . quote)
   (call
     (touch.gloc.of generate-library-id)
     (push.const |.R6RS-EVAL|)
     (apply.gloc.of generate-library-id "./boot/eval.scm" . 72760))
   (push)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 60428)
   (push.subr.gloc.of |.list| 2 "./boot/eval.scm" . 60428)
   (push.const result)
   (push.subr.gloc.of |.cons*| 5 "./boot/eval.scm" . 60428)
   (push.subr.gloc.of |.list| 3 "./boot/eval.scm" . 60428)
   (apply.gloc.of interpret "./boot/eval.scm" . 60428))
 (set.gloc.of eval)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 75805))
 (set.gloc.of scheme-load-verbose)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/eval.scm" . 76827))
 (set.gloc.of scheme-load-paths)
 (ret.const.unspec))
((close
   (1 0 . expand-path)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 80924)
     (push.const . 1)
     (subr.gloc.of > 2 "./boot/eval.scm" . 80921)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 80954)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 80948))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 81955)
     (push.const . #\~)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 81947))
   (if.true
     (push.const . "~a~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 82973))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 83008)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 82990)
     (ret.subr.gloc.of format "./boot/eval.scm" . 82958))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 84003)
     (push.const . #\.)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 83995))
   (if.true
     (push.const . "~a~/")
     (subr.gloc.of current-directory 0)
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 85059)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 85041)
     (ret.subr.gloc.of format "./boot/eval.scm" . 85006))
   (push.iloc.1 . 0)
   (push.const . ".")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 86030)
   (if.true
     (push.const . "~/")
     (subr.gloc.of current-directory 0)
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 87054))
   (push.iloc.1 . 0)
   (push.const . "~")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 88078)
   (if.true
     (push.const . "~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 89115))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 89102))
   (push.const . "~/")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 91150))
 (set.gloc.of expand-path)
 (ret.const.unspec))
((close
   (1 0 . confirm-path)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 102414)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |confirm-path`2|)
 (close
   (1 0 . path-not-found)
   (push.const . load)
   (push.const . "~a~/~a not found")
   (push.const . #\")
   (push.iloc.0 . 0)
   (push.const . #\")
   (push.subr.gloc.of format 4 "./boot/eval.scm" . 98340)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 98313))
 (set.gloc.of |path-not-found`2|)
 (close
   (1 0 . locate-load-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 104463)
   (push.const . 0)
   (subr.gloc.of = 2 "./boot/eval.scm" . 104460)
   (if.true
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 105484))
   (call
     (push.iloc.0 . 0)
     (push.const . ":")
     (subr.gloc.of string-contains 2 "./boot/eval.scm" . 106512)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 106545)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 106539))
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (push.iloc.0 . 0)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 107536))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 107556))
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 108562)
   (push.const #\. #\~)
   (subr.gloc.of memq 2 "./boot/eval.scm" . 108556)
   (if.true
     (call
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/eval.scm" . 109598))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 109584))
     (if.true.ret)
     (touch.gloc.of |path-not-found`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 109618))
   (call
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of |confirm-path`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (push.const . "/")
         (push.iloc.1 . 0)
         (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 110649)
         (apply.gloc.of expand-path "./boot/eval.scm" . 110636))
       (push)
       (apply.gloc.of |confirm-path`2| "./boot/eval.scm" . 110622))
     (push.const . ".")
     (call (apply.gloc.of scheme-load-paths "./boot/eval.scm" . 111644))
     (push.cons)
     (apply.gloc.of any1 "./boot/eval.scm" . 110604))
   (if.true.ret)
   (touch.gloc.of |path-not-found`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of |path-not-found`2| "./boot/eval.scm" . 113676))
 (set.gloc.of locate-load-file)
 (ret.const.unspec))
((close
   (1 0 . load-file-has-r6rs-comment?)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 118791)
     (set.iloc 1 . 0)
     (push.const . #t)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 118791))
   (push.close
     (0 0)
     (call
       (touch.gloc.of open-script-input-port)
       (call
         (touch.gloc.of locate-load-file)
         (push.iloc 2 . 0)
         (apply.gloc.of locate-load-file "./boot/eval.scm" . 118827))
       (push)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 118803))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . load)
     (subr.gloc.of core-read 3 "./boot/eval.scm" . 119817)
     (push.iloc.0 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 120841)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (ret.subr.gloc.of not "./boot/eval.scm" . 121865))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 118791))
   (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 118791))
 (set.gloc.of load-file-has-r6rs-comment?)
 (ret.const.unspec))
((close
   (1 0 . load)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/eval.scm" . 125964)
   (if.true
     (call
       (touch.gloc.of auto-compile-cache-update)
       (apply.gloc.of auto-compile-cache-update "./boot/eval.scm" . 126988))
     (touch.gloc.of load-scheme-library)
     (push.iloc.0 . 0)
     (apply.gloc.of load-scheme-library "./boot/eval.scm" . 128012))
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 130076))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 131091))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 131113))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 132122))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 135194))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 136218)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 137242))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 139290))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 146453)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 146453)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 146453)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 146453)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 146453))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (call
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 147509)
           (if.false.ret)
           (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 147521))
         (push)
         (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 147479)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 148515)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 149536)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 150560))
         (call
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 152608))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 153632))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 146453))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 146453)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 146453))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 142385))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 132110))
 (set.gloc.of load)
 (ret.const.unspec))
((close
   (1 0 . load-r6rs)
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 157717))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 158732))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 158754))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 159763))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 162835))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 163859)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 164883))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 166931))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 174094)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 174094)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 174094)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 174094)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 174094))
     (push.close
       (0 0)
       (call
         (subr.gloc.of backtrace 0 "./boot/eval.scm" . 174124)
         (if.false.ret)
         (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 174136))
       (push)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 174094)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 176156)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 177177)
         (if.true
           (push.iloc 6 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 178201)
           (call
             (touch.gloc.of expand-top-level-program)
             (push.iloc.1 . 0)
             (push.subr.gloc.of reverse 1 "./boot/eval.scm" . 179266)
             (push.const)
             (apply.gloc.of expand-top-level-program "./boot/eval.scm" . 179240))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/eval.scm" . 180251))
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 181275))
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 183321))
       (push.const)
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 175118))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 174094)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 174094))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 170026))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 159751))
 (set.gloc.of load-r6rs)
 (ret.const.unspec))
((close
   (1 0 . load-cache)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 187402))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 187424))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 188433))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 191498)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 192522))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-environment 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 198668)
       (set.iloc 1 . 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 198668)
       (set.iloc 1 . 1)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 198668)
       (set.iloc 1 . 2)
       (push.const . #f)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 198668)
       (push.const . #f)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 198668)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 198668))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (push.iloc 5 . 0)
         (push.const . #f)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 199706)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 200727)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 201751))
         (call
           (touch.gloc.of run-vmi)
           (push.const 1 . 0)
           (iloc.0 . 0)
           (push.cons)
           (apply.gloc.of run-vmi "./boot/eval.scm" . 203799))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 204823))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 198668))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 198668)
       (push.iloc.1 . 1)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 198668)
       (push.iloc.1 . 2)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 198668))
     (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 197668))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 188421))
 (set.gloc.of load-cache)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 206878))
 (set.gloc.of auto-compile-verbose)
 (ret.const.unspec))
((close
   (1 0)
   (iloc.0 . 0)
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of string? 1 "./boot/eval.scm" . 214034)
       (if.false.ret)
       (push.const . "~//.")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/eval.scm" . 214060)
       (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 214046))
     (if.true
       (push.const . "~/")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/eval.scm" . 214080))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const
       .
       "~&;; warning in auto-compile-cache: directory ~s not exist (temporary disable caching)~!~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/eval.scm" . 216077)
     (ret.const . #f))
   (ret.iloc 0 . 0))
 (set.gloc.of |.fn1.1`1|)
 (call
   (push.const . #f)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 211972))
 (set.gloc.of auto-compile-cache)
 (ret.const.unspec))
((close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 228417))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 228402)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 229430)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 230438)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 230464))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 231462)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 231492))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 232486))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 232509))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 224309)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 225336)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 225368)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 225365)
   (ret.subr.gloc.of = "./boot/eval.scm" . 225333))
 (set.gloc.of |.fn2.1`2|)
 (close
   (0 0 . auto-compile-cache-clean)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 221196))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn1.1`1|)
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn2.1`2|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 226346)
       (apply.gloc.of filter "./boot/eval.scm" . 223266))
     (push)
     (apply.gloc.of for-each "./boot/eval.scm" . 223249))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-clean)
 (ret.const.unspec))
((close
   (1 0 . inconsistent-cache-state)
   (call
     (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 240654))
     (if.false.ret)
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~&;; reset ~s~%")
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 241725))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 241678))
   (push.gloc.of |.fn2.1`2|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/eval.scm" . 239623))
 (set.gloc.of |inconsistent-cache-state`2|)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 254005)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 255032)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 255064)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 255061)
   (ret.subr.gloc.of = "./boot/eval.scm" . 255029))
 (set.gloc.of |.fn4.1`4|)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 243767))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 243752)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 244780)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 245788)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 245814))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 246812)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 246842))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 247836))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 247859))
 (set.gloc.of |.fn2.1`2|)
 (close
   (0 0 . auto-compile-cache-update)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 250892))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of filter)
       (push.gloc.of |.fn4.1`4|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 256042)
       (apply.gloc.of filter "./boot/eval.scm" . 252962))
     (push)
     (extend . 1)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (call
           (iloc.0 . 1)
           (if.false.ret)
           (push.close
             (1 0)
             (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 261199))
             (push)
             (push.const . "/")
             (push.iloc.0 . 0)
             (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 261184)
             (extend . 1)
             (push.iloc.0 . 0)
             (push.const . ".time")
             (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 262212)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 263222)
             (if.true
               (call
                 (touch.gloc.of make-file-input-port)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-file-input-port "./boot/eval.scm" . 265274))
               (push)
               (push.close
                 (1 0)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 267347)
                 (extend . 1)
                 (push.iloc.1 . 0)
                 (subr.gloc.of close-port 1 "./boot/eval.scm" . 268350)
                 (iloc.0 . 0)
                 (>=.iloc (5 . 1) "./boot/eval.scm" . 269381)
                 (if.true
                   (push.iloc 2 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 270405)
                   (push.iloc 3 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 271429)
                   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 272458))
                   (if.false.ret)
                   (push.const . #t)
                   (push.const . "~&;; clean ~s~%")
                   (push.iloc 3 . 0)
                   (ret.subr.gloc.of format "./boot/eval.scm" . 272481))
                 (ret.const.unspec))
               (apply.gloc.of call-with-port "./boot/eval.scm" . 264246))
             (touch.gloc.of |inconsistent-cache-state`2|)
             (push.iloc 5 . 0)
             (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 274486))
           (push.iloc 2 . 0)
           (apply.gloc.of for-each "./boot/eval.scm" . 259100))
         (ret.const.unspec))
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 278590))
       (push)
       (push.const . "/")
       (push.car.iloc (0 . 0) "./boot/eval.scm" . 278615)
       (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 278575)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const . ".time")
       (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 279603)
       (extend . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 280613)
       (if.true
         (call
           (touch.gloc.of make-file-input-port)
           (push.iloc.0 . 0)
           (apply.gloc.of make-file-input-port "./boot/eval.scm" . 282665))
         (push)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 284739)
           (extend . 1)
           (push.iloc.1 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 285764)
           (extend . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 286783)
           (extend . 1)
           (push.iloc 3 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 287789)
           (call
             (push.iloc 2 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 288830)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 288856)
             (if.false.ret)
             (push.iloc.0 . 0)
             (subr.gloc.of string? 1 "./boot/eval.scm" . 288883)
             (if.false.ret)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 288905))
           (if.true
             (call
               (touch.gloc.of stat-mtime)
               (push.iloc.0 . 0)
               (apply.gloc.of stat-mtime "./boot/eval.scm" . 290871))
             (=.iloc (1 . 0) "./boot/eval.scm" . 290868)
             (if.true
               (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 291898)
               (push.iloc 6 . 1)
               (apply.iloc (7 . 0) "./boot/eval.scm" . 291892))
             (push.cdr.iloc (6 . 0) "./boot/eval.scm" . 293946)
             (call
               (iloc 6 . 1)
               (if.true
                 (iloc 2 . 0)
                 (<.iloc (6 . 1) "./boot/eval.scm" . 296001)
                 (if.true (ret.iloc 2 . 0))
                 (ret.iloc 6 . 1))
               (ret.iloc 2 . 0))
             (push)
             (apply.iloc (7 . 0) "./boot/eval.scm" . 284715))
           (touch.gloc.of |inconsistent-cache-state`2|)
           (push.iloc 8 . 0)
           (apply.gloc.of |inconsistent-cache-state`2| "./boot/eval.scm" . 289844))
         (apply.gloc.of call-with-port "./boot/eval.scm" . 278556))
       (push.iloc.1 . 0)
       (subr.gloc.of delete-file 1 "./boot/eval.scm" . 299045)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 300074))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; clean ~s~%")
         (push.iloc.1 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 300097))
       (push.cdr.iloc (2 . 0) "./boot/eval.scm" . 301099)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "./boot/eval.scm" . 301093))
     (push.iloc.1 . 0)
     (push.const . #f)
     (apply.iloc (0 . 0) "./boot/eval.scm" . 257043))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-update)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 308254)
     (if.false.ret)
     (touch.gloc.of every1)
     (push.gloc.of string?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/eval.scm" . 308268))
   (if.true (ret.iloc 0 . 0))
   (push.const . library-extensions)
   (push.const . "expected list of strings, but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/eval.scm" . 310338)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 310297))
 (set.gloc.of |.fn1.1`1|)
 (call
   (push.const . ".ypsilon.sls")
   (push.const . ".ypsilon.ss")
   (push.const . ".ypsilon.scm")
   (push.const . ".sls")
   (push.const . ".ss")
   (push.const . ".scm")
   (push.subr.gloc.of list 6 "./boot/eval.scm" . 306195)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 306179))
 (set.gloc.of library-extensions)
 (ret.const.unspec))
((close
   (2 0 . locate-cache)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 380944))
   (if.false.ret)
   (push.const . "~a/~a.cache")
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 382008))
   (push)
   (call
     (touch.gloc.of symbol-list->string)
     (push.iloc.0 . 0)
     (push.const . ".")
     (apply.gloc.of symbol-list->string "./boot/eval.scm" . 382029))
   (push)
   (push.subr.gloc.of format 3 "./boot/eval.scm" . 381986)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 382999)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . ".time")
     (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 384045)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 385054)
     (if.false.ret)
     (call
       (touch.gloc.of make-file-input-port)
       (push.iloc.0 . 0)
       (apply.gloc.of make-file-input-port "./boot/eval.scm" . 387106))
     (push)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 389156)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 390180)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 391231)
       (subr.gloc.of equal? 2 "./boot/eval.scm" . 391211)
       (if.true (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 393259)
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/eval.scm" . 394283))
       (ret.const . #f))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 385049))
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of |locate-cache`4|)
 (close
   (4 0 . make-cache)
   (call
     (touch.gloc.of make-file-output-port)
     (push.iloc.0 . 1)
     (apply.gloc.of make-file-output-port "./boot/eval.scm" . 320527))
   (push)
   (push.close
     (1 0)
     (call
       (touch.gloc.of open-script-input-port)
       (push.iloc.1 . 0)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 323605))
     (push)
     (push.close
       (1 0)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 327706)
         (push.iloc 2 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 328730)
         (call
           (iloc 3 . 1)
           (if.false.ret)
           (push.iloc 3 . 1)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 329763)
           (if.false.ret)
           (push.iloc 3 . 1)
           (ret.subr.gloc.of delete-file "./boot/eval.scm" . 329782))
         (push.iloc.0 . 0)
         (apply.gloc.of raise "./boot/eval.scm" . 330778))
       (push.close
         (0 0)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (subr.gloc.of current-source-comments 0)
         (push)
         (subr.gloc.of current-environment 0)
         (push)
         (subr.gloc.of extend-lexical-syntax 0)
         (push)
         (subr.gloc.of backtrace 0)
         (push)
         (extend . 8)
         (push.close
           (0 0)
           (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 337948)
           (set.iloc 1 . 0)
           (subr.gloc.of current-environment 0 "./boot/eval.scm" . 337948)
           (set.iloc 1 . 1)
           (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 337948)
           (set.iloc 1 . 2)
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 337948)
           (set.iloc 1 . 3)
           (push.iloc.1 . 4)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 5)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 6)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 7)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 337948))
         (push.close
           (0 0)
           (extend.enclose+
             (0 0 . loop)
             (call
               (subr.gloc.of backtrace 0 "./boot/eval.scm" . 339004)
               (if.false.ret)
               (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 339016))
             (push)
             (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 338974)
             (push.iloc 5 . 0)
             (subr.gloc.of current-source-comments 0)
             (push)
             (push.const . load)
             (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 340009)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 341031)
             (if.true
               (push.iloc 7 . 0)
               (push.const . "~%")
               (subr.gloc.of format 2 "./boot/eval.scm" . 342055)
               (push.iloc 6 . 0)
               (subr.gloc.of close-port 1 "./boot/eval.scm" . 343079)
               (push.iloc 7 . 0)
               (ret.subr.gloc.of close-port "./boot/eval.scm" . 344103))
             (call
               (push.const . #f)
               (subr.gloc.of make-core-hashtable 0)
               (push)
               (extend . 2)
               (push.close
                 (0 0)
                 (call
                   (touch.gloc.of current-closure-comments)
                   (apply.gloc.of current-closure-comments "./boot/eval.scm" . 349232))
                 (set.iloc 1 . 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 1)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 349232))
               (push.close
                 (0 0)
                 (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 349250))
                 (push)
                 (apply.gloc.of compile-coreform "./boot/eval.scm" . 349232))
               (push.close
                 (0 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 0)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 349232))
               (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 349232))
             (push)
             (extend . 1)
             (push.iloc 8 . 0)
             (push.iloc.0 . 0)
             (subr.gloc.of put-fasl 2 "./boot/eval.scm" . 350249)
             (push.iloc 8 . 0)
             (push.const . "~%")
             (subr.gloc.of format 2 "./boot/eval.scm" . 351273)
             (call
               (touch.gloc.of run-vmi)
               (push.const 1 . 0)
               (iloc.0 . 0)
               (push.cons)
               (apply.gloc.of run-vmi "./boot/eval.scm" . 352297))
             (apply.iloc+ (3 . 0) "./boot/eval.scm" . 353321))
           (apply.iloc+ (0 . 0) "./boot/eval.scm" . 337948))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 1)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 2)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 337948)
           (push.iloc.1 . 3)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 337948))
         (apply.gloc.of |.dynamic-wind| "./boot/eval.scm" . 333880))
       (apply.gloc.of with-exception-handler "./boot/eval.scm" . 324629))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 321551))
   (apply.gloc.of call-with-port "./boot/eval.scm" . 318473))
 (set.gloc.of |make-cache`4|)
 (close
   (1 1 . load-scheme-library)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #t)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of car "./boot/eval.scm" . 315434))
   (push)
   (extend . 1)
   (extend.enclose
     (1 0 . locate-source)
     (call
       (touch.gloc.of symbol-list->string)
       (push.iloc.0 . 0)
       (push.const . "/")
       (apply.gloc.of symbol-list->string "./boot/eval.scm" . 367639))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.const . "~a/~a~a")
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 4 "./boot/eval.scm" . 370739)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 371752)
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call (apply.gloc.of library-extensions "./boot/eval.scm" . 372767))
         (push)
         (apply.gloc.of any1 "./boot/eval.scm" . 369689))
       (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 373783))
       (push)
       (apply.gloc.of any1 "./boot/eval.scm" . 368657))
     (if.true.ret)
     (iloc 3 . 0)
     (if.false.ret)
     (push.const . load-scheme-library)
     (push.const . "~s not found in scheme-library-paths: ~s")
     (push.iloc.0 . 0)
     (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 375914))
     (push)
     (push.subr.gloc.of format 3 "./boot/eval.scm" . 375858)
     (apply.gloc.of error "./boot/eval.scm" . 375830))
   (call
     (push.iloc 2 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 398347)
     (if.true.ret)
     (push.const . "internal error in load-scheme-library: unrecognized argument: ~s")
     (push.iloc 2 . 0)
     (apply.gloc.of scheme-error "./boot/eval.scm" . 399371))
   (call (push.iloc 2 . 0) (apply.iloc (0 . 0) "./boot/eval.scm" . 401422))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 403479))
     (if.true
       (call
         (touch.gloc.of |locate-cache`4|)
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of |locate-cache`4| "./boot/eval.scm" . 404521))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of load-cache)
         (push.iloc.0 . 0)
         (apply.gloc.of load-cache "./boot/eval.scm" . 406557))
       (push.const . "~a/~a.cache")
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 407621))
       (push)
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc 4 . 0)
         (push.const . ".")
         (apply.gloc.of symbol-list->string "./boot/eval.scm" . 407642))
       (push)
       (push.subr.gloc.of format 3 "./boot/eval.scm" . 407599)
       (extend . 1)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 408612))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; compile ~s~%~!")
         (push.iloc 2 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 408635))
       (call
         (touch.gloc.of |make-cache`4|)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 2 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 409670))
         (push)
         (apply.gloc.of |make-cache`4| "./boot/eval.scm" . 409631))
       (call
         (touch.gloc.of make-file-output-port)
         (push.iloc.0 . 0)
         (push.const . ".time")
         (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 410677)
         (apply.gloc.of make-file-output-port "./boot/eval.scm" . 412709))
       (push)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.const . "~s ~s ~s")
         (subr.gloc.of microsecond 0)
         (push)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 3 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 413790))
         (push)
         (push.iloc 3 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 413750))
       (apply.gloc.of call-with-port "./boot/eval.scm" . 411681))
     (push.iloc.0 . 0)
     (apply.gloc.of load "./boot/eval.scm" . 414743))
   (ret.const.unspec))
 (set.gloc.of load-scheme-library)
 (ret.const.unspec))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/interaction.scm" . 5144))
 (set.gloc.of dump-condition)
 (ret.const.unspec))
((close
   (1 0 . add-load-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 9228)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 10256)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 11292))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 12323))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 12310)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13364))
       (push.cons)
       (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13334))
     (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 14348))
   (push.const . add-load-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 16432)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 16396))
 (set.gloc.of add-load-path)
 (ret.const.unspec))
((close
   (1 0 . add-library-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 20492)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 21520)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 22556))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 23587))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 23574)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24631))
       (push.cons)
       (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24598))
     (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 25612))
   (push.const . add-library-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 27699)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 27660))
 (set.gloc.of add-library-path)
 (ret.const.unspec))
((close
   (0 0 . home-directory)
   (push.const . "~/")
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 33831)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 33814)
     (if.true
       (call
         (push.const . "HOMEDRIVE")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 34857)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (call
         (push.const . "HOMEPATH")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 35881)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (ret.subr.gloc.of string-append "./boot/interaction.scm" . 34838))
     (push.const . "HOME")
     (ret.subr.gloc.of lookup-process-environment "./boot/interaction.scm" . 36886))
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 31761)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/interaction.scm" . 37900)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of home-directory)
 (ret.const.unspec))
((close
   (1 1 . apply-scheme-proc-assistant)
   (push.const . #t)
   (extend . 1)
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.true.ret)
     (push.const . apply-scheme-proc-assistant)
     (push.const . "scheme continuation interleave with c/c++ continuation")
     (apply.gloc.of assertion-violation "./boot/interaction.scm" . 45076))
   (push.close
     (0 0)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of apply "./boot/interaction.scm" . 47125))
     (push)
     (extend . 1)
     (const . #f)
     (set.iloc 2 . 0)
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.false.ret)
     (touch.gloc.of escape)
     (apply.gloc.of escape "./boot/interaction.scm" . 50197))
   (apply.gloc.of dynamic-wind "./boot/interaction.scm" . 43015))
 (set.gloc.of apply-scheme-proc-assistant)
 (ret.const.unspec))
((close
   (0 0 . nonblock-skip-whitespace)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of nonblock-byte-ready? 1 "./boot/interaction.scm" . 54282)
   (if.false.ret)
   (call
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of lookahead-char 1 "./boot/interaction.scm" . 55316)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 56342)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of char-whitespace? "./boot/interaction.scm" . 57361))
   (if.false.ret)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of get-char 1 "./boot/interaction.scm" . 58378)
   (if.false.ret)
   (touch.gloc.of nonblock-skip-whitespace)
   (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 59402))
 (set.gloc.of nonblock-skip-whitespace)
 (ret.const.unspec))
((close
   (0 0 . read-eval-print-loop)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 63512)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 63559)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 63554)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 63549))
   (push)
   (extend . 1)
   (extend.enclose
     (0 0 . loop)
     (call
       (push.close
         (1 0)
         (push.close
           (1 0)
           (subr.gloc.of current-output-port 0)
           (push)
           (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 69647)
           (touch.gloc.of default-exception-handler)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 70671))
         (push.close
           (0 0)
           (call
             (touch.gloc.of nonblock-skip-whitespace)
             (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 72719))
           (call
             (subr.gloc.of current-environment 0)
             (push)
             (subr.gloc.of interaction-environment 0 "./boot/interaction.scm" . 73774)
             (if.eq?
               (push.const . #t)
               (push.const . "~&> ~!")
               (ret.subr.gloc.of format "./boot/interaction.scm" . 74771))
             (push.const . #t)
             (push.const . "~&~a: ~!")
             (subr.gloc.of current-environment 0)
             (push)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 75795))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 76815))
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 77839)
           (call
             (touch.gloc.of set-port-current-line!)
             (subr.gloc.of current-input-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-line! "./boot/interaction.scm" . 78863))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-output-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 79887))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-error-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 80911))
           (subr.gloc.of current-input-port 0)
           (push)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . read)
           (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 81947)
           (extend . 1)
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 82966)
             (if.false.ret)
             (push.const . 0)
             (ret.subr.gloc.of exit "./boot/interaction.scm" . 82985))
           (call
             (iloc 5 . 0)
             (if.false.ret)
             (push.const . #t)
             (push.const . "~%~!")
             (ret.subr.gloc.of format "./boot/interaction.scm" . 83998))
           (call
             (touch.gloc.of interpret)
             (push.iloc.0 . 0)
             (apply.gloc.of interpret "./boot/interaction.scm" . 85020))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of unspecified? 1 "./boot/interaction.scm" . 86042)
           (if.true.ret)
           (call (push.iloc.0 . 0) (apply.gloc.of pretty-print "./boot/interaction.scm" . 88090))
           (subr.gloc.of current-output-port 0)
           (push)
           (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 89114))
         (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 67596))
       (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 65545))
     (apply.iloc (1 . 0) "./boot/interaction.scm" . 90121))
   (apply.iloc (0 . 0) "./boot/interaction.scm" . 64519))
 (set.gloc.of read-eval-print-loop)
 (ret.const.unspec))
((close
   (0 0 . loop)
   (call
     (push.gloc.of |.fn2.1`2|)
     (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 94213))
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 110599))
 (set.gloc.of |loop`4|)
 (close
   (0 0)
   (call
     (touch.gloc.of nonblock-skip-whitespace)
     (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 102413))
   (call
     (touch.gloc.of current-macro-expression)
     (push.const . #f)
     (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 103437))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 104461)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . read)
   (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 105497)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 106518)
   (if.true (push.const . 0) (ret.subr.gloc.of exit "./boot/interaction.scm" . 106537))
   (call
     (touch.gloc.of interpret)
     (push.iloc.0 . 0)
     (apply.gloc.of interpret "./boot/interaction.scm" . 108566))
   (subr.gloc.of current-output-port 0)
   (push)
   (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 109590))
 (set.gloc.of |.fn5.1`5|)
 (close
   (1 0)
   (push.gloc.of |.fn6.1`6|)
   (push.gloc.of |.fn5.1`5|)
   (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 96264))
 (set.gloc.of |.fn2.1`2|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 100405))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 99341)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn1.1`1|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 100365))
 (set.gloc.of |.fn6.1`6|)
 (close
   (0 0 . quiet-read-eval-print-loop)
   (touch.gloc.of |loop`4|)
   (apply.gloc.of |loop`4| "./boot/interaction.scm" . 94213))
 (set.gloc.of quiet-read-eval-print-loop)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of |loop`7|)
       (push.car.iloc (0 . 0) "./boot/interaction.scm" . 147484)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 147478))
     (push)
     (call
       (touch.gloc.of |loop`7|)
       (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 147501)
       (apply.gloc.of |loop`7| "./boot/interaction.scm" . 147495))
     (ret.cons "./boot/interaction.scm" . 147472))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.const
       (|.LIST| . |.list|)
       (|.CONS| . |.cons|)
       (|.CONS*| . |.cons*|)
       (|.APPEND| . |.append|)
       (|.VECTOR| . |.vector|)
       (|.LIST->VECTOR| . |.list->vector|)
       (|.EQ?| . |.eq?|)
       (|.EQV?| . |.eqv?|)
       (|.MEMQ| . |.memq|)
       (|.MEMV| . |.memv|)
       (|.CALL-WITH-VALUES| . |.call-with-values|)
       (|.APPLY| . |.apply|)
       (|.CDR| . |.cdr|)
       (|.IDENTIFIER?| . |.identifier?|)
       (|.MAKE-VARIABLE-TRANSFORMER| . |.make-variable-transformer|)
       (|.ASSERTION-VIOLATION| . |.assertion-violation|)
       (|.UNSPECIFIED| . |.unspecified|)
       (|.QUOTE| . quote)
       (|.LET| . let)
       (|.LETREC*| . letrec*)
       (|.BEGIN| . begin)
       (|.LAMBDA| . lambda)
       (|.IF| . if)
       (|.SET!| . set!)
       (|.OR| . or)
       (|.COND| . cond)
       (|.ELSE| . else)
       (|.DEFINE-SYNTAX| . define-syntax)
       (|.SYNTAX| . syntax)
       (|.SYNTAX-CASE| . syntax-case))
     (push.subr.gloc.of assq 2 "./boot/interaction.scm" . 149527)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/interaction.scm" . 149520))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/interaction.scm" . 151568)
   (if.true
     (call
       (push.gloc.of |loop`7|)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/interaction.scm" . 152616)
       (apply.gloc.of map "./boot/interaction.scm" . 152606))
     (push)
     (apply.gloc.of list->vector "./boot/interaction.scm" . 152592))
   (ret.iloc 0 . 0))
 (set.gloc.of |loop`7|)
 (close
   (1 0 . unrename-private-primitives)
   (touch.gloc.of |loop`7|)
   (push.iloc.0 . 0)
   (apply.gloc.of |loop`7| "./boot/interaction.scm" . 145415))
 (set.gloc.of |.fn2.2`2|)
 (gloc.of |.fn2.2`2|)
 (set.gloc.of unrename-private-primitives)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . "~r")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 180296))
 (set.gloc.of |.fn1.1`1|)
 (close
   (2 0 . default-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/interaction.scm" . 157701))
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (call
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of backtrace-line-length 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
       (set.iloc 1 . 0)
       (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
       (set.iloc 1 . 1)
       (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
       (set.iloc 1 . 2)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
       (call
         (push.const . 10)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
     (push.close
       (0 0)
       (extend.unbound . 4)
       (push.close
         (0 0 . output-who-message)
         (push.iloc 4 . 0)
         (push.const . "error")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 165901)
         (call
           (call (push.iloc 5 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 166930))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . " in ~u")
           (call (push.iloc 5 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 167976))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 167954))
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of message-condition? "./boot/interaction.scm" . 168978))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . ": ~a")
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of condition-message "./boot/interaction.scm" . 170022))
         (push)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 170002))
       (push.close
         (0 0 . output-irritants)
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of irritants-condition? "./boot/interaction.scm" . 174100))
         (if.true
           (push.iloc 4 . 0)
           (push.const . "~%~%irritants:")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 175124)
           (push.close
             (1 0)
             (push.iloc 5 . 0)
             (push.const . "~% ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 177184)
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/interaction.scm" . 178215)
             (if.true
               (push.iloc 5 . 0)
               (push.const . " (")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 179239)
               (extend.enclose+
                 (1 0 . loop)
                 (iloc.0 . 0)
                 (if.pair?
                   (push.iloc 7 . 0)
                   (push.const . "~a")
                   (push.car.iloc (0 . 0) "./boot/interaction.scm" . 182338)
                   (subr.gloc.of format 3 "./boot/interaction.scm" . 182320)
                   (cdr.iloc (0 . 0) "./boot/interaction.scm" . 183358)
                   (if.pair?
                     (push.iloc 7 . 0)
                     (push.const . " ")
                     (subr.gloc.of format 2 "./boot/interaction.scm" . 184375)
                     (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 185405)
                     (apply.iloc+ (1 . 0) "./boot/interaction.scm" . 185399))
                   (push.iloc 7 . 0)
                   (push.const . ")")
                   (ret.subr.gloc.of format "./boot/interaction.scm" . 187447))
                 (ret.const.unspec))
               (call
                 (push.gloc.of |.fn1.1`1|)
                 (push.iloc.1 . 0)
                 (apply.gloc.of map "./boot/interaction.scm" . 180279))
               (push)
               (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 180263))
             (push.iloc 5 . 0)
             (push.const . " ~r")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 188460))
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 189470))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 174093))
         (ret.const.unspec))
       (push.close+
         (0 0 . output-expansion)
         (call (apply.gloc.of expansion-backtrace "./boot/interaction.scm" . 193554))
         (if.false.ret)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 194578))
         (if.false.ret)
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 196628))
           (set.iloc 1 . 0)
           (push.const . 7)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 196628))
         (push.close
           (0 0)
           (push.iloc 6 . 0)
           (push.const . "~%~%expanding:~%  >  ")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 196628)
           (call
             (call
               (touch.gloc.of unrename-private-primitives)
               (call
                 (touch.gloc.of current-macro-expression)
                 (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 197695))
               (push)
               (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 197666))
             (push)
             (push.iloc 6 . 0)
             (apply.gloc.of pretty-print "./boot/interaction.scm" . 197652))
           (push.iloc 6 . 0)
           (push.const . "~%  ~n")
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 198698))
           (push)
           (subr.gloc.of format 3 "./boot/interaction.scm" . 198676)
           (push.close
             (1 0)
             (push.iloc 7 . 0)
             (push.const . "~%  *  ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 200736)
             (call
               (call
                 (touch.gloc.of unrename-private-primitives)
                 (push.iloc.0 . 0)
                 (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 201774))
               (push)
               (push.iloc 7 . 0)
               (apply.gloc.of pretty-print "./boot/interaction.scm" . 201760))
             (push.iloc 7 . 0)
             (push.const . "~%  ~n")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 202784))
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 203806))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 199700))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 196628))
         (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 196628))
       (push.close
         (1 0 . output-condition)
         (call
           (touch.gloc.of dump-condition)
           (apply.gloc.of dump-condition "./boot/interaction.scm" . 207890))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . "~%~%")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 208914)
         (if.false.ret)
         (touch.gloc.of describe-condition)
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of describe-condition "./boot/interaction.scm" . 209938))
       (enclose . 4)
       (call (push.iloc 4 . 0) (apply.gloc.of syntax-violation? "./boot/interaction.scm" . 211984))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 213008))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 214039))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 217118))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 217118))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  >  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 217118)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 218156))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 218142))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 219184))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 217118))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 217118))
           (ret.const.unspec))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 220183))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223262))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223262))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  @  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 223262)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 224300))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 224286))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 225328))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223262))
             (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 223262))
           (ret.const.unspec))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 226320))
         (call
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 227360))
           (if.not.null?.ret.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 228386))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 228413))
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 229410))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 229437))
           (ret.eq? "./boot/interaction.scm" . 229405))
         (if.true.ret)
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 230420))
       (call
         (push.iloc 4 . 0)
         (apply.gloc.of undefined-violation? "./boot/interaction.scm" . 232464))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unbound variable")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 233488)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 234517))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " ~s")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 235560))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 235541))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 236565))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ", ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 237609))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 237589))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 238608))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 239632))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 240656))
       (call (push.iloc 4 . 0) (apply.gloc.of error? "./boot/interaction.scm" . 242704))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 243728))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 244752))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 245776))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 246800))
       (call (push.iloc 4 . 0) (apply.gloc.of violation? "./boot/interaction.scm" . 248848))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 249872))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 250896))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 251920))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 252944))
       (call (push.iloc 4 . 0) (apply.gloc.of warning? "./boot/interaction.scm" . 254992))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "warning")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 256016)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 257045))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " in ~s")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 258091))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 258069))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 259093))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ": ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 260137))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 260117))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 261136))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 262160))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 263184))
       (call (push.iloc 4 . 0) (apply.gloc.of condition? "./boot/interaction.scm" . 265232))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unknown type of exception caught~%~%irritants:~%~a")
         (call
           (touch.gloc.of describe-condition)
           (push.const . #f)
           (push.iloc 4 . 0)
           (apply.gloc.of describe-condition "./boot/interaction.scm" . 266329))
         (push)
         (subr.gloc.of format 3 "./boot/interaction.scm" . 266256)
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 267280))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 268304))
       (push.iloc 3 . 0)
       (push.const . "error: unknown type of exception caught, ~a")
       (push.iloc 4 . 0)
       (subr.gloc.of format 3 "./boot/interaction.scm" . 271376)
       (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 272400))
       (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 273424))
     (push.close
       (0 0)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
       (call
         (push.iloc.1 . 1)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
     (apply.gloc.of |.dynamic-wind| "./boot/interaction.scm" . 159792))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 275463)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 276506)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 276553)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 276548)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 276543))
   (push)
   (extend . 1)
   (call (push.iloc 2 . 0) (apply.gloc.of serious-condition? "./boot/interaction.scm" . 277520))
   (if.true
     (push.iloc.1 . 0)
     (subr.gloc.of display-backtrace 1 "./boot/interaction.scm" . 278544)
     (call
       (iloc.0 . 0)
       (if.true
         (subr.gloc.of current-error-port 0)
         (push)
         (push.const . "~a~!")
         (push.iloc.1 . 0)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 280632)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 280596))
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~%~a~%~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 281660)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 281620))
     (push.const . 10000)
     (subr.gloc.of usleep 1 "./boot/interaction.scm" . 282640)
     (iloc 2 . 1)
     (if.false.ret)
     (apply.iloc (2 . 1) "./boot/interaction.scm" . 283678))
   (call
     (iloc.0 . 0)
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 286776)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 286740))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc.1 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 287802)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 287764))
   (push.const . 10000)
   (ret.subr.gloc.of usleep "./boot/interaction.scm" . 288784))
 (set.gloc.of default-exception-handler)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 347186))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 347167))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 348206))
     (push)
     (apply.gloc.of add-load-path "./boot/interaction.scm" . 348191))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_LOADPATH': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 350239))
 (set.gloc.of |.fn1.1`1|)
 (close
   (1 0 . add-opt-sitelib)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 358447))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 358428))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 359470))
       (push)
       (apply.gloc.of add-library-path "./boot/interaction.scm" . 359452))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-sitelib=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 361500)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 362524))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 363569)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 363552)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 364576))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 365600))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 363539)
   (apply.gloc.of for-each "./boot/interaction.scm" . 356359))
 (set.gloc.of |add-opt-sitelib`2|)
 (close
   (0 0 . show-info)
   (call
     (touch.gloc.of |show-banner`2|)
     (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 420873))
   (call
     (push.const . "YPSILON_ACC")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 421904)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_ACC=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 422946))
     (push.const . #t)
     (push.const . ";; YPSILON_ACC unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 423957))
   (call
     (push.const . "YPSILON_SITELIB")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 424976)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_SITELIB=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 426018))
     (push.const . #t)
     (push.const . ";; YPSILON_SITELIB unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 427029))
   (call
     (push.const . "YPSILON_LOADPATH")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 428048)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_LOADPATH=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 429090))
     (push.const . #t)
     (push.const . ";; YPSILON_LOADPATH unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 430101))
   (push.const . #t)
   (push.const . ";; (auto-compile-cache) => ~s~%")
   (call (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 431158))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 431113)
   (push.const . #t)
   (push.const . ";; (scheme-library-paths) => ~s~%")
   (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 432184))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 432137)
   (push.const . #t)
   (push.const . ";; (scheme-load-paths) => ~s~%")
   (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 433205))
   (push)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 433161))
 (set.gloc.of |show-info`2|)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 450621))
 (set.gloc.of |.fn6.1`6|)
 (close
   (1 0)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 332850))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 332831))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 333873))
     (push)
     (apply.gloc.of add-library-path "./boot/interaction.scm" . 333855))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_SITELIB': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 335903))
 (set.gloc.of |.fn4.1`4|)
 (close
   (0 0 . init-sys-sitelib)
   (push.const . "~a/sitelib")
   (subr.gloc.of system-share-path 0)
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 300053)
   (extend . 1)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.iloc.0 . 0)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 301072))
   (if.false.ret)
   (push.iloc.0 . 0)
   (apply.gloc.of add-library-path "./boot/interaction.scm" . 301097))
 (set.gloc.of |init-sys-sitelib`2|)
 (close
   (1 0 . directory-exists?)
   (push.const . "~a/.")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 295959)
   (ret.subr.gloc.of file-exists? "./boot/interaction.scm" . 295945))
 (set.gloc.of |directory-exists?`2|)
 (close
   (0 0 . init-env-sitelib)
   (push.const . "YPSILON_SITELIB")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 328720)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn4.1`4|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 336948)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 336931)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 337955))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 338979))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 336918)
     (apply.gloc.of for-each "./boot/interaction.scm" . 328713))
   (ret.const.unspec))
 (set.gloc.of |init-env-sitelib`2|)
 (close
   (1 0 . add-opt-loadpath)
   (push.close
     (1 0)
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 370735))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 370716))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 371755))
       (push)
       (apply.gloc.of add-load-path "./boot/interaction.scm" . 371740))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '-loadpath=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 373788)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 374812))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 375857)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 375840)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 376864))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 377888))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 375827)
   (apply.gloc.of for-each "./boot/interaction.scm" . 368647))
 (set.gloc.of |add-opt-loadpath`2|)
 (close
   (0 0 . show-banner)
   (subr.gloc.of current-output-port 0)
   (push)
   (push.const . "Ypsilon 0.9.5-trunk Copyright (c) 2008 Y.Fujita, LittleWing Company Limited.\n")
   (ret.subr.gloc.of put-string "./boot/interaction.scm" . 416777))
 (set.gloc.of |show-banner`2|)
 (close
   (0 0 . show-usage)
   (push.const . #t)
   (push.const . "usage: ypsilon [options] [--] [file] [arguments]~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 396297)
   (push.const . #t)
   (push.const . "options:~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 397321)
   (push.const . #t)
   (push.const . "  --mute (-m)            suppresses greeting~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 398345)
   (push.const . #t)
   (push.const . "  --quiet (-q)           suppresses greeting, repl prompt, and repl output~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 399369)
   (push.const . #t)
   (push.const . "  --verbose (-v)         prints load and compile activities~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 400393)
   (push.const . #t)
   (push.const . "  --interactive (-i)     enters repl after running the script file~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 401417)
   (push.const . #t)
   (push.const . "  --r6rs (-6)            conforms r6rs lexical syntax (default)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 402441)
   (push.const . #t)
   (push.const . "  --compatible (-c)      extends lexical syntax for compatibility~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 403465)
   (push.const . #t)
   (push.const . "  --dump-condition       default exception handler dump condition~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 404489)
   (push.const . #t)
   (push.const . "  --sitelib=path         adds sitelib path (YPSILON_SITELIB)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 405513)
   (push.const . #t)
   (push.const . "  --loadpath=path        adds load search path (YPSILON_LOADPATH)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 406537)
   (push.const . #t)
   (push.const . "  --acc=dir              sets a auto-compile-cache directory (YPSILON_ACC)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 407561)
   (push.const . #t)
   (push.const . "  --disable-acc          disables auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 408585)
   (push.const . #t)
   (push.const . "  --clean-acc            cleans auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 409609)
   (push.const . #t)
   (push.const . "  --version              prints version and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 410633)
   (push.const . #t)
   (push.const . "  --help                 prints help and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 411657)
   (push.const . #t)
   (push.const . "  --                     indicates no more option to proceed~%")
   (ret.subr.gloc.of format "./boot/interaction.scm" . 412681))
 (set.gloc.of |show-usage`2|)
 (close
   (0 0 . init-sys-acc)
   (push.const . operating-system)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 305185)
   (push.const . "windows")
   (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 305168)
   (if.true
     (push.const . "TEMP")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 306199)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of |directory-exists?`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 308259))
       (if.true
         (call
           (call
             (touch.gloc.of |directory-exists?`2|)
             (push.const . "~//Ypsilon")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/interaction.scm" . 309306)
             (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 309287))
           (if.true.ret)
           (push.const . "~//Ypsilon")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/interaction.scm" . 310329)
           (ret.subr.gloc.of create-directory "./boot/interaction.scm" . 310311))
         (push.const . "~//Ypsilon")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/interaction.scm" . 311351)
         (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 311331))
       (ret.const.unspec))
     (ret.const.unspec))
   (call
     (touch.gloc.of |directory-exists?`2|)
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 313408))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 313386)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 313367))
   (if.true
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 314433))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 314411)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 314391))
   (ret.const.unspec))
 (set.gloc.of |init-sys-acc`2|)
 (close
   (0 0 . init-env-acc)
   (push.const . "YPSILON_ACC")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 318480)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of |directory-exists?`2|)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 320559))
       (push)
       (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 320540))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 321584))
       (push)
       (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 321564))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in environment variable 'YPSILON_ACC': directory ~s not exist~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/interaction.scm" . 323612)
     (push.const . #f)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 324636))
   (ret.const.unspec))
 (set.gloc.of |init-env-acc`2|)
 (close
   (1 0 . set-opt-acc)
   (call
     (touch.gloc.of |directory-exists?`2|)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 381987))
     (push)
     (apply.gloc.of |directory-exists?`2| "./boot/interaction.scm" . 381968))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 383012))
     (push)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 382992))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '-acc=~a': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of format 4 "./boot/interaction.scm" . 385040)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 386064))
 (set.gloc.of |set-opt-acc`2|)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 449557)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of |.fn6.1`6|)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 450581))
 (set.gloc.of |.fn17.1`17|)
 (close
   (0 0 . init-env-loadpath)
   (push.const . "YPSILON_LOADPATH")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 343056)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of |.fn1.1`1|)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 351284)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 351267)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 352291))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 353315))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 351254)
     (apply.gloc.of for-each "./boot/interaction.scm" . 343049))
   (ret.const.unspec))
 (set.gloc.of |init-env-loadpath`2|)
 (close
   (1 0 . bad-option)
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '~a'~%")
   (push.iloc.0 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 390153)
   (call
     (touch.gloc.of |show-usage`2|)
     (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 391177))
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 392201))
 (set.gloc.of |bad-option`2|)
 (close
   (0 0 . start-scheme-session)
   (extend.unbound . 8)
   (push.close
     (1 0 . exec-script)
     (subr.gloc.of command-line 0)
     (push)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 437280)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 437304)
     (push.subr.gloc.of - 2 "./boot/interaction.scm" . 437277)
     (subr.gloc.of command-line-shift 1 "./boot/interaction.scm" . 437257)
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 438293)
     (extend . 1)
     (iloc 2 . 4)
     (if.true
       (push.close
         (1 0)
         (subr.gloc.of current-output-port 0)
         (push)
         (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 442389)
         (touch.gloc.of default-exception-handler)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 443413))
       (push.close (0 0) (push.iloc.1 . 0) (apply.gloc.of load "./boot/interaction.scm" . 445461))
       (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 440338))
     (push.gloc.of |.fn17.1`17|)
     (push.close
       (0 0)
       (call
         (call
           (touch.gloc.of load-file-has-r6rs-comment?)
           (push.iloc.1 . 0)
           (apply.gloc.of load-file-has-r6rs-comment? "./boot/interaction.scm" . 452633))
         (if.true
           (touch.gloc.of load-r6rs)
           (push.iloc.1 . 0)
           (apply.gloc.of load-r6rs "./boot/interaction.scm" . 453657))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 454681))
       (subr.gloc.of current-error-port 0)
       (push)
       (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 455701)
       (subr.gloc.of current-output-port 0)
       (push)
       (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 456725))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 447506))
   (push.close
     (0 0 . exec-repl)
     (call
       (iloc.1 . 6)
       (if.true.ret)
       (iloc.1 . 2)
       (if.true
         (touch.gloc.of |show-info`2|)
         (apply.gloc.of |show-info`2| "./boot/interaction.scm" . 461848))
       (touch.gloc.of |show-banner`2|)
       (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 462869))
     (call
       (iloc.1 . 5)
       (if.true.ret)
       (touch.gloc.of interpret)
       (push.const import (core) (rnrs))
       (apply.gloc.of interpret "./boot/interaction.scm" . 463892))
     (iloc.1 . 3)
     (if.true
       (touch.gloc.of quiet-read-eval-print-loop)
       (apply.gloc.of quiet-read-eval-print-loop "./boot/interaction.scm" . 465933))
     (touch.gloc.of read-eval-print-loop)
     (apply.gloc.of read-eval-print-loop "./boot/interaction.scm" . 466957))
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (enclose . 7)
   (subr.gloc.of command-line 0 "./boot/interaction.scm" . 474146)
   (set.iloc 0 . 7)
   (call
     (touch.gloc.of |init-sys-acc`2|)
     (apply.gloc.of |init-sys-acc`2| "./boot/interaction.scm" . 476165))
   (call
     (touch.gloc.of |init-env-acc`2|)
     (apply.gloc.of |init-env-acc`2| "./boot/interaction.scm" . 477189))
   (call
     (touch.gloc.of |init-sys-sitelib`2|)
     (apply.gloc.of |init-sys-sitelib`2| "./boot/interaction.scm" . 478213))
   (call
     (touch.gloc.of |init-env-sitelib`2|)
     (apply.gloc.of |init-env-sitelib`2| "./boot/interaction.scm" . 479237))
   (call
     (touch.gloc.of |init-env-loadpath`2|)
     (apply.gloc.of |init-env-loadpath`2| "./boot/interaction.scm" . 480261))
   (iloc.0 . 7)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 4)
       (if.true (apply.iloc (2 . 1) "./boot/interaction.scm" . 487449))
       (iloc 2 . 5)
       (if.true.ret)
       (apply.iloc (2 . 1) "./boot/interaction.scm" . 488484))
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 490528)
     (extend . 1)
     (extend.enclose
       (2 0 . opt?)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of string-contains 2 "./boot/interaction.scm" . 494628)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (=n.iloc (0 . 0) 0 "./boot/interaction.scm" . 496681)
         (if.true
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (subr.gloc.of string=? 2 "./boot/interaction.scm" . 497700)
           (if.true.ret.const . "")
           (iloc.1 . 1)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 498758)
           (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 498742)
           (push.const . #\=)
           (subr.gloc.of char=? 2 "./boot/interaction.scm" . 498734)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 499766)
           (push.const . 1)
           (push.subr.gloc.of + 2 "./boot/interaction.scm" . 499763)
           (push.iloc 3 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 499790)
           (ret.subr.gloc.of substring "./boot/interaction.scm" . 499748))
         (ret.const . #f))
       (ret.const . #f))
     (call
       (push.const . "--version")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 502814))
     (if.true
       (call
         (touch.gloc.of |show-banner`2|)
         (apply.gloc.of |show-banner`2| "./boot/interaction.scm" . 503838))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 504862))
     (call
       (push.const . "--help")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 505886))
     (if.true
       (call
         (touch.gloc.of |show-usage`2|)
         (apply.gloc.of |show-usage`2| "./boot/interaction.scm" . 506910))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 507934))
     (call
       (call
         (push.const . "--r6rs")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 508962))
       (if.true.ret)
       (push.const . "-6")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 508981))
     (if.true
       (push.const . #f)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 509982)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 511012)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 511006))
     (call
       (call
         (push.const . "--compatible")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 512034))
       (if.true.ret)
       (push.const . "-c")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 512059))
     (if.true
       (push.const . #t)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 513054)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 514084)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 514078))
     (call
       (call
         (push.const . "--verbose")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 515106))
       (if.true.ret)
       (push.const . "-v")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 515128))
     (if.true
       (call
         (push.const . #t)
         (apply.gloc.of scheme-load-verbose "./boot/interaction.scm" . 516126))
       (call
         (push.const . #t)
         (apply.gloc.of auto-compile-verbose "./boot/interaction.scm" . 517150))
       (const . #t)
       (set.iloc 4 . 2)
       (const . #f)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 520228)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 520222))
     (call
       (call
         (push.const . "--mute")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 521250))
       (if.true.ret)
       (push.const . "-m")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 521269))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 524324)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 524318))
     (call
       (call
         (push.const . "--quiet")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 525346))
       (if.true.ret)
       (push.const . "-q")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 525366))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (const . #t)
       (set.iloc 4 . 3)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 529444)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 529438))
     (call
       (call
         (push.const . "--interactive")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 530466))
       (if.true.ret)
       (push.const . "-i")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 530492))
     (if.true
       (const . #t)
       (set.iloc 4 . 4)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 532516)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 532510))
     (call
       (push.const . "--dump-condition")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 533534))
     (if.true
       (call
         (touch.gloc.of dump-condition)
         (push.const . #t)
         (apply.gloc.of dump-condition "./boot/interaction.scm" . 534558))
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 535588)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 535582))
     (call
       (push.const . "--acc")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 536606))
     (if.true
       (call
         (cdr.iloc (2 . 0) "./boot/interaction.scm" . 537641)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc.1 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 537652))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.cadr.iloc (2 . 0) "./boot/interaction.scm" . 538667)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 538654))
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 539684)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 539678))
     (call
       (push.const . "--acc")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 540702))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 542762)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 543786))
       (call
         (touch.gloc.of |set-opt-acc`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |set-opt-acc`2| "./boot/interaction.scm" . 545834))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 546864)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 546858))
     (call
       (push.const . "--disable-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 547870))
     (if.true
       (call (push.const . #f) (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 548894))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 549924)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 549918))
     (call
       (push.const . "--clean-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 550942))
     (if.true
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/interaction.scm" . 551966))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 552996)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 552990))
     (call
       (push.const . "--sitelib")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 554014))
     (if.true
       (call
         (cdr.iloc (3 . 0) "./boot/interaction.scm" . 555049)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 2 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 555060))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.cadr.iloc (3 . 0) "./boot/interaction.scm" . 556079)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 556062))
       (push.cddr.iloc (3 . 0) "./boot/interaction.scm" . 557092)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 557086))
     (call
       (push.const . "--sitelib")
       (push.const . #t)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 558110))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 560170)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 561194))
       (call
         (touch.gloc.of |add-opt-sitelib`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-sitelib`2| "./boot/interaction.scm" . 563242))
       (push.cdr.iloc (4 . 0) "./boot/interaction.scm" . 564272)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 564266))
     (call
       (push.const . "--loadpath")
       (push.const . #f)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 565278))
     (if.true
       (call
         (cdr.iloc (4 . 0) "./boot/interaction.scm" . 566313)
         (if.pair?.ret.const . #t)
         (touch.gloc.of |bad-option`2|)
         (push.iloc 3 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 566324))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.cadr.iloc (4 . 0) "./boot/interaction.scm" . 567344)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 567326))
       (push.cddr.iloc (4 . 0) "./boot/interaction.scm" . 568356)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 568350))
     (call
       (push.const . "--loadpath")
       (push.const . #t)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 569374))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 571434)
       (if.true
         (touch.gloc.of |bad-option`2|)
         (push.iloc 4 . 0)
         (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 572458))
       (call
         (touch.gloc.of |add-opt-loadpath`2|)
         (push.iloc.0 . 0)
         (apply.gloc.of |add-opt-loadpath`2| "./boot/interaction.scm" . 574506))
       (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 575536)
       (apply.iloc+ (6 . 0) "./boot/interaction.scm" . 575530))
     (call
       (push.const . "--")
       (push.const . #f)
       (apply.iloc (3 . 0) "./boot/interaction.scm" . 576542))
     (if.true
       (const . #t)
       (set.iloc 7 . 5)
       (call
         (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 578603)
         (apply.iloc (7 . 0) "./boot/interaction.scm" . 578590))
       (iloc 7 . 4)
       (if.false.ret)
       (apply.iloc (7 . 1) "./boot/interaction.scm" . 579631))
     (push.iloc 4 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 580646)
     (push.const . #\-)
     (subr.gloc.of char=? 2 "./boot/interaction.scm" . 580638)
     (if.true
       (touch.gloc.of |bad-option`2|)
       (push.iloc 4 . 0)
       (apply.gloc.of |bad-option`2| "./boot/interaction.scm" . 581662))
     (const . #t)
     (set.iloc 7 . 5)
     (call (push.iloc 5 . 0) (apply.iloc (7 . 0) "./boot/interaction.scm" . 584734))
     (iloc 7 . 4)
     (if.false.ret)
     (apply.iloc (7 . 1) "./boot/interaction.scm" . 585775))
   (push.cdr.iloc (1 . 7) "./boot/interaction.scm" . 484380)
   (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 484364))
 (set.gloc.of start-scheme-session)
 (ret.const.unspec))

;
((subr.gloc.of make-core-hashtable 0 "./boot/libraries.scm" . 5150)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))
((const begin quote define set! lambda let letrec* if or and)
 (set.gloc.of coreform-primitives)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 17453)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 17429)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 18453))
 (set.gloc.of |.fn10.1`10|)
 (close
   (2 0 . setup-intrinsic-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 27665))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 28689))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 29718))
   (push)
   (extend . 3)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 30729)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 31753)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn6.1`6|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 33837))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 34861)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 33829)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 32804))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 32777))
 (set.gloc.of |setup-intrinsic-macros`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 22600))
   (ret.cons "./boot/libraries.scm" . 22592))
 (set.gloc.of |.fn12.1`12|)
 (close
   (2 0 . setup-core-primitive-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 53265))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 54289))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 55318))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn7.1`7|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 53255))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 61449)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn9.1`9|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 63533))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 64557)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 63525)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 62500))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 62473))
 (set.gloc.of |setup-core-primitive-macros`1|)
 (close
   (2 0 . setup-core-primitive-procs)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 38929))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 39953))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 40982))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn11.1`11|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 41993))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 46089)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn5.1`5|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 48173))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 49197)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 48165)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 47140))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 47113))
 (set.gloc.of |setup-core-primitive-procs`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 48200))
   (ret.cons "./boot/libraries.scm" . 48192))
 (set.gloc.of |.fn5.1`5|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 33864))
   (ret.cons "./boot/libraries.scm" . 33856))
 (set.gloc.of |.fn6.1`6|)
 (close
   (2 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 57372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 59425))
   (ret.const.unspec))
 (set.gloc.of |.fn7.1`7|)
 (close
   (2 0 . setup-intrinsic-procs)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 1)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 12295)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 13329))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 14353))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 15382))
   (push)
   (extend . 3)
   (call
     (push.gloc.of |.fn10.1`10|)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 16393))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 20489)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of |.fn12.1`12|)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 22573))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 23597)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 22565)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 21540))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 21513))
 (set.gloc.of |setup-intrinsic-procs`1|)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 63560))
   (ret.cons "./boot/libraries.scm" . 63552))
 (set.gloc.of |.fn9.1`9|)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 43053)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 43029)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 44053))
 (set.gloc.of |.fn11.1`11|)
 (close
   (2 0 . compound-exports)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 68625))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68655))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 69676)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.1 . 1)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68691))
   (push)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 70700)
   (push.subr.gloc.of append 2 "./boot/libraries.scm" . 69668)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 69641))
 (set.gloc.of |compound-exports`1|)
 (call
   (touch.gloc.of |setup-intrinsic-macros`1|)
   (push.const core intrinsics)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (apply.gloc.of |setup-intrinsic-macros`1| "./boot/libraries.scm" . 72707))
 (call
   (touch.gloc.of |setup-intrinsic-procs`1|)
   (push.const core intrinsics)
   (push.const
     eq?
     eqv?
     equal?
     procedure?
     number?
     complex?
     real?
     rational?
     integer?
     real-valued?
     rational-valued?
     integer-valued?
     exact?
     inexact?
     inexact
     exact
     =
     <
     >
     <=
     >=
     zero?
     positive?
     negative?
     odd?
     even?
     finite?
     infinite?
     nan?
     max
     min
     +
     *
     -
     /
     abs
     div-and-mod
     div
     mod
     div0-and-mod0
     div0
     mod0
     gcd
     lcm
     numerator
     denominator
     floor
     ceiling
     truncate
     round
     rationalize
     exp
     log
     sin
     cos
     tan
     asin
     acos
     atan
     sqrt
     exact-integer-sqrt
     expt
     make-rectangular
     make-polar
     real-part
     imag-part
     magnitude
     angle
     number->string
     string->number
     not
     boolean?
     boolean=?
     pair?
     cons
     car
     cdr
     caar
     cadr
     cdar
     cddr
     caaar
     caadr
     cadar
     caddr
     cdaar
     cdadr
     cddar
     cdddr
     caaaar
     caaadr
     caadar
     caaddr
     cadaar
     cadadr
     caddar
     cadddr
     cdaaar
     cdaadr
     cdadar
     cdaddr
     cddaar
     cddadr
     cdddar
     cddddr
     null?
     list?
     list
     length
     append
     reverse
     list-tail
     list-ref
     map
     for-each
     symbol?
     symbol=?
     symbol->string
     string->symbol
     char?
     char->integer
     integer->char
     char=?
     char<?
     char>?
     char<=?
     char>=?
     string?
     make-string
     string
     string-length
     string-ref
     string=?
     string<?
     string>?
     string<=?
     string>=?
     substring
     string-append
     string->list
     list->string
     string-copy
     string-for-each
     vector?
     make-vector
     vector
     vector-length
     vector-ref
     vector-set!
     vector->list
     list->vector
     vector-fill!
     vector-map
     vector-for-each
     error
     assertion-violation
     apply
     call-with-current-continuation
     call/cc
     values
     call-with-values
     dynamic-wind)
   (apply.gloc.of |setup-intrinsic-procs`1| "./boot/libraries.scm" . 84995))
 (call
   (touch.gloc.of |setup-core-primitive-macros`1|)
   (push.const core primitives)
   (push.const do syntax-case syntax define-macro)
   (apply.gloc.of |setup-core-primitive-macros`1| "./boot/libraries.scm" . 131075))
 (call
   (touch.gloc.of |setup-core-primitive-procs`1|)
   (push.const core primitives)
   (push.const
     environment
     eval
     flonum?
     real->flonum
     fl=?
     fl<?
     fl>?
     fl<=?
     fl>=?
     flinteger?
     flzero?
     flpositive?
     flnegative?
     flodd?
     fleven?
     flfinite?
     flinfinite?
     flnan?
     flmax
     flmin
     fl+
     fl*
     fl-
     fl/
     fldiv
     fldiv0
     flnumerator
     fldenominator
     flfloor
     flceiling
     fltruncate
     flround
     flexp
     flexpt
     fllog
     flsin
     flcos
     fltan
     flasin
     flacos
     flatan
     flabs
     flsqrt
     fixnum->flonum
     fixnum?
     fixnum-width
     least-fixnum
     greatest-fixnum
     fx=?
     fx<?
     fx>?
     fx<=?
     fx>=?
     fxzero?
     fxpositive?
     fxnegative?
     fxodd?
     fxeven?
     fxmax
     fxmin
     fx+
     fx*
     fx-
     fxdiv
     fxdiv0
     fxnot
     fxand
     fxior
     fxxor
     fxif
     fxbit-count
     fxlength
     fxfirst-bit-set
     fxbit-set?
     fxcopy-bit
     fxarithmetic-shift
     fxarithmetic-shift-left
     fxarithmetic-shift-right
     fxbit-field
     fxcopy-bit-field
     &no-infinities
     make-no-infinities-violation
     no-infinities-violation?
     &no-nans
     make-no-nans-violation
     no-nans-violation?
     bitwise-not
     bitwise-and
     bitwise-ior
     bitwise-xor
     bitwise-arithmetic-shift
     bitwise-first-bit-set
     bitwise-length
     bitwise-bit-count
     make-variable-transformer
     identifier?
     bound-identifier=?
     free-identifier=?
     datum->syntax
     syntax->datum
     generate-temporaries
     syntax-violation
     memq
     memv
     member
     assq
     assv
     assoc
     cons*
     list-head
     raise
     raise-continuable
     with-exception-handler
     record?
     record-rtd
     record-type-name
     record-type-parent
     record-type-uid
     record-type-generative?
     record-type-sealed?
     record-type-opaque?
     record-type-field-names
     record-field-mutable?
     make-record-type-descriptor
     record-type-descriptor?
     make-record-constructor-descriptor
     record-constructor
     record-predicate
     record-accessor
     record-mutator
     make-record-type
     record-type?
     record-type-rtd
     record-type-rcd
     condition
     simple-conditions
     condition?
     condition-predicate
     condition-accessor
     &condition
     &message
     make-message-condition
     message-condition?
     condition-message
     &warning
     make-warning
     warning?
     &serious
     make-serious-condition
     serious-condition?
     &error
     make-error
     error?
     &violation
     make-violation
     violation?
     &assertion
     make-assertion-violation
     assertion-violation?
     &irritants
     make-irritants-condition
     irritants-condition?
     condition-irritants
     &who
     make-who-condition
     who-condition?
     condition-who
     &non-continuable
     make-non-continuable-violation
     non-continuable-violation?
     &implementation-restriction
     make-implementation-restriction-violation
     implementation-restriction-violation?
     &lexical
     make-lexical-violation
     lexical-violation?
     &syntax
     make-syntax-violation
     syntax-violation?
     syntax-violation-form
     syntax-violation-subform
     &undefined
     make-undefined-violation
     undefined-violation?
     set-car!
     set-cdr!
     string-set!
     string-fill!
     quotient
     remainder
     modulo
     char-whitespace?
     display
     write
     newline
     read-char
     write-char
     call-with-port
     eof-object
     eof-object?
     standard-input-port
     standard-output-port
     standard-error-port
     current-input-port
     current-output-port
     current-error-port
     input-port?
     output-port?
     port?
     flush-output-port
     output-port-buffer-mode
     close-port
     native-transcoder-descriptor
     port-transcoder-descriptor
     extract-accumulated-bytevector
     extract-accumulated-string
     get-accumulated-string
     open-port
     nonblock-byte-ready?
     lookahead-char
     get-char
     port-has-port-position?
     port-position
     port-has-set-port-position!?
     set-port-position!
     port-eof?
     get-u8
     lookahead-u8
     get-bytevector-n
     get-bytevector-n!
     get-bytevector-all
     get-bytevector-some
     get-string-n
     get-string-n!
     get-string-all
     get-line
     get-datum
     put-u8
     put-bytevector
     put-char
     put-string
     put-datum
     &i/o
     make-i/o-error
     i/o-error?
     &i/o-read
     make-i/o-read-error
     i/o-read-error?
     &i/o-write
     make-i/o-write-error
     i/o-write-error?
     &i/o-invalid-position
     make-i/o-invalid-position-error
     i/o-invalid-position-error?
     i/o-error-position
     &i/o-filename
     make-i/o-filename-error
     i/o-filename-error?
     i/o-error-filename
     &i/o-file-protection
     make-i/o-file-protection-error
     i/o-file-protection-error?
     &i/o-file-is-read-only
     make-i/o-file-is-read-only-error
     i/o-file-is-read-only-error?
     &i/o-file-already-exists
     make-i/o-file-already-exists-error
     i/o-file-already-exists-error?
     &i/o-file-does-not-exist
     make-i/o-file-does-not-exist-error
     i/o-file-does-not-exist-error?
     &i/o-port
     make-i/o-port-error
     i/o-port-error?
     i/o-error-port
     &i/o-decoding
     make-i/o-decoding-error
     i/o-decoding-error?
     &i/o-encoding
     make-i/o-encoding-error
     i/o-encoding-error?
     i/o-encoding-error-char
     file-exists?
     delete-file
     string-hash
     symbol-hash
     equal-hash
     command-line
     exit
     native-endianness
     bytevector?
     make-bytevector
     bytevector-length
     bytevector=?
     bytevector-fill!
     bytevector-copy!
     bytevector-copy
     bytevector-u8-ref
     bytevector-s8-ref
     bytevector-u8-set!
     bytevector-s8-set!
     bytevector->u8-list
     u8-list->bytevector
     bytevector-u16-ref
     bytevector-s16-ref
     bytevector-u16-native-ref
     bytevector-s16-native-ref
     bytevector-u16-set!
     bytevector-s16-set!
     bytevector-u16-native-set!
     bytevector-s16-native-set!
     bytevector-u32-ref
     bytevector-s32-ref
     bytevector-u32-native-ref
     bytevector-s32-native-ref
     bytevector-u32-set!
     bytevector-s32-set!
     bytevector-u32-native-set!
     bytevector-s32-native-set!
     bytevector-u64-ref
     bytevector-s64-ref
     bytevector-u64-native-ref
     bytevector-s64-native-ref
     bytevector-u64-set!
     bytevector-s64-set!
     bytevector-u64-native-set!
     bytevector-s64-native-set!
     bytevector-ieee-single-ref
     bytevector-ieee-single-native-ref
     bytevector-ieee-single-set!
     bytevector-ieee-single-native-set!
     bytevector-ieee-double-ref
     bytevector-ieee-double-native-ref
     bytevector-ieee-double-set!
     bytevector-ieee-double-native-set!
     string->utf8
     utf8->string
     put-fasl
     put-byte
     make-string-output-port
     make-string-input-port
     make-transcoded-port
     make-temporary-file-port
     port-device-subtype
     core-eval
     command-line-shift
     unspecified
     unspecified?
     generate-temporary-symbol
     circular-list?
     circular-tree?
     list-transpose
     list-transpose+
     list-transpose*
     make-parameter
     gensym
     format
     pretty-print
     pretty-print-line-length
     pretty-print-initial-indent
     pretty-print-maximum-lines
     pretty-print-unwrap-syntax
     peek-char
     read
     write-with-shared-structure
     tuple
     tuple?
     make-tuple
     tuple-ref
     tuple-set!
     tuple-length
     tuple-index
     tuple->list
     make-weak-mapping
     weak-mapping?
     weak-mapping-key
     weak-mapping-value
     make-core-hashtable
     core-hashtable?
     make-weak-core-hashtable
     weak-core-hashtable?
     core-hashtable-contains?
     core-hashtable-ref
     core-hashtable-set!
     core-hashtable-delete!
     core-hashtable-clear!
     core-hashtable->alist
     core-hashtable-size
     core-hashtable-copy
     core-hashtable-mutable?
     core-hashtable-equivalence-function
     core-hashtable-hash-function
     usleep
     microsecond
     microsecond->utc
     scheme-error
     architecture-feature
     load-shared-object
     lookup-shared-object
     call-shared-object->void
     call-shared-object->int
     call-shared-object->intptr
     call-shared-object->double
     stdcall-shared-object->void
     stdcall-shared-object->int
     stdcall-shared-object->intptr
     stdcall-shared-object->double
     make-callback
     flonum->float
     string->cstring
     cstring->string
     collect
     collect-notify
     collect-stack-notify
     collect-trip-bytes
     display-heap-statistics
     display-object-statistics
     backtrace
     expansion-backtrace
     backtrace-line-length
     display-backtrace
     restricted-print-line-length
     record-print-nesting-limit
     extend-lexical-syntax
     macro-expand
     compile
     compile-coreform
     closure-code
     current-environment
     current-macro-environment
     current-variable-environment
     current-dynamic-environment
     system-environment
     interaction-environment
     make-environment
     copy-environment-variables!
     copy-environment-macros!
     top-level-bound?
     top-level-value
     set-top-level-value!
     core-read
     current-source-comments
     current-after-expansion-hook
     string-contains
     subr?
     make-bytevector-mapping
     scheme-library-exports
     scheme-library-paths
     scheme-load-paths
     scheme-load-verbose
     add-load-path
     add-library-path
     library-extensions
     auto-compile-verbose
     auto-compile-cache
     directory-list
     current-directory
     create-directory
     home-directory
     time-usage
     decode-flonum
     load
     system-share-path
     system
     process
     process-wait
     lookup-process-environment
     set-current-input-port!
     set-current-output-port!
     set-current-error-port!
     open-builtin-data-input-port)
   (apply.gloc.of |setup-core-primitive-procs`1| "./boot/libraries.scm" . 137219))
 (touch.gloc.of |compound-exports`1|)
 (push.const core primitives)
 (push.const core intrinsics)
 (apply.gloc.of |compound-exports`1| "./boot/libraries.scm" . 491523))
((gloc.of assertion-violation) (set.gloc.of |.@assertion-violation|) (ret.const.unspec))
((gloc.of undefined-violation) (set.gloc.of |.@undefined-violation|) (ret.const.unspec))
((gloc.of lexical-violation) (set.gloc.of |.@lexical-violation|) (ret.const.unspec))
((gloc.of error) (set.gloc.of |.@error|) (ret.const.unspec))
((gloc.of implementation-restriction-violation)
 (set.gloc.of |.@implementation-restriction-violation|)
 (ret.const.unspec))
((gloc.of raise-i/o-read-error) (set.gloc.of |.@raise-i/o-read-error|) (ret.const.unspec))
((gloc.of raise-i/o-write-error) (set.gloc.of |.@raise-i/o-write-error|) (ret.const.unspec))
((gloc.of raise-i/o-file-protection-error)
 (set.gloc.of |.@raise-i/o-file-protection-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-is-read-only-error)
 (set.gloc.of |.@raise-i/o-file-is-read-only-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-already-exists-error)
 (set.gloc.of |.@raise-i/o-file-already-exists-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-file-does-not-exist-error)
 (set.gloc.of |.@raise-i/o-file-does-not-exist-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-decoding-error) (set.gloc.of |.@raise-i/o-decoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-encoding-error) (set.gloc.of |.@raise-i/o-encoding-error|) (ret.const.unspec))
((gloc.of raise-i/o-invalid-position-error)
 (set.gloc.of |.@raise-i/o-invalid-position-error|)
 (ret.const.unspec))
((gloc.of raise-i/o-filename-error) (set.gloc.of |.@raise-i/o-filename-error|) (ret.const.unspec))
((gloc.of raise-i/o-error) (set.gloc.of |.@raise-i/o-error|) (ret.const.unspec))
((gloc.of perform-dynamic-wind) (set.gloc.of |.@perform-dynamic-wind|) (ret.const.unspec))
((gloc.of start-scheme-session) (set.gloc.of |.@start-scheme-session|) (ret.const.unspec))
((gloc.of apply-scheme-proc-assistant)
 (set.gloc.of |.@apply-scheme-proc-assistant|)
 (ret.const.unspec))
((gloc.of pretty-print) (set.gloc.of |.@pretty-print|) (ret.const.unspec))
((push.const . |.run-vmi|)
 (push.gloc.of run-vmi)
 (ret.subr.gloc.of set-top-level-value! "./boot/libraries.scm" . 517121))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 527385))
 (set.gloc.of |.fn1.1`1|)
 (push.const
   |.set-top-level-macro!|
   |.require-scheme-library|
   |.intern-scheme-library|
   |.unintern-scheme-library|
   |.patvars|
   |.syntax-dispatch|
   |.flatten-syntax|
   |.transformer-thunk|
   |.syntax/i0|
   |.syntax/i1|
   |.syntax/i2|
   |.syntax/i3|
   |.syntax/c0|
   |.syntax/c1|
   |.syntax/c2|
   |.syntax/c3|
   |.run-vmi|)
 (extend . 1)
 (call
   (push.gloc.of |.fn1.1`1|)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/libraries.scm" . 527363))
 (subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.iloc.0 . 0)
 (ret.subr.gloc.of copy-environment-variables! "./boot/libraries.scm" . 528387))
((subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.const import)
 (ret.subr.gloc.of copy-environment-macros! "./boot/libraries.scm" . 531457))
((push.gloc.of immutable-primitives)
 (push.const . #f)
 (subr.gloc.of core-hashtable-copy 2 "./boot/libraries.scm" . 532508)
 (touch.gloc.of immutable-primitives)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))

;
