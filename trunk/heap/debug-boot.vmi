((push.const . \x2E;list?)
 (push.gloc.of list?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 7171)
 (push.const . \x2E;null?)
 (push.gloc.of null?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 8195)
 (push.const . \x2E;pair?)
 (push.gloc.of pair?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 9219)
 (push.const . \x2E;car)
 (push.gloc.of car)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 10243)
 (push.const . \x2E;cdr)
 (push.gloc.of cdr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 11267)
 (push.const . \x2E;caar)
 (push.gloc.of caar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 12291)
 (push.const . \x2E;cadr)
 (push.gloc.of cadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 13315)
 (push.const . \x2E;cdar)
 (push.gloc.of cdar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 14339)
 (push.const . \x2E;cddr)
 (push.gloc.of cddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 15363)
 (push.const . \x2E;caaar)
 (push.gloc.of caaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 16387)
 (push.const . \x2E;caadr)
 (push.gloc.of caadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 17411)
 (push.const . \x2E;cadar)
 (push.gloc.of cadar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 18435)
 (push.const . \x2E;caddr)
 (push.gloc.of caddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 19459)
 (push.const . \x2E;cdaar)
 (push.gloc.of cdaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 20483)
 (push.const . \x2E;cdadr)
 (push.gloc.of cdadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 21507)
 (push.const . \x2E;cddar)
 (push.gloc.of cddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 22531)
 (push.const . \x2E;cdddr)
 (push.gloc.of cdddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 23555)
 (push.const . \x2E;cdddar)
 (push.gloc.of cdddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 24579)
 (push.const . \x2E;caddar)
 (push.gloc.of caddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 25603)
 (push.const . \x2E;cddadr)
 (push.gloc.of cddadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 26627)
 (push.const . \x2E;cadadr)
 (push.gloc.of cadadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 27651)
 (push.const . \x2E;caaadr)
 (push.gloc.of caaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 28675)
 (push.const . \x2E;cddddr)
 (push.gloc.of cddddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 29699)
 (push.const . \x2E;cadddr)
 (push.gloc.of cadddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 30723)
 (push.const . \x2E;cdaadr)
 (push.gloc.of cdaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 31747)
 (push.const . \x2E;cdaddr)
 (push.gloc.of cdaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 32771)
 (push.const . \x2E;caaddr)
 (push.gloc.of caaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 33795)
 (push.const . \x2E;list)
 (push.gloc.of list)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 34819)
 (push.const . \x2E;cons*)
 (push.gloc.of cons*)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 35843)
 (push.const . \x2E;memq)
 (push.gloc.of memq)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 36867)
 (push.const . \x2E;append)
 (push.gloc.of append)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 37891)
 (push.const . \x2E;apply)
 (push.gloc.of apply)
 (ret.subr.gloc.of set-top-level-value! "./boot/first-load.scm" . 38915))

;
((close
   (0 1 . max)
   (iloc.0 . 0)
   (if.null?
     (push.const . max)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 8204))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 9242)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 9228)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 12316))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 13347)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 13333)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 14370)
           (>.iloc (0 . 0) "./boot/r6rs-aux.scm" . 14367)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 14387))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 15404)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 15394))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 16411)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 14357))
       (push.const . max)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 18515)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 18479)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 18453))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10270)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10296)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 10286)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10314)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 10252))
   (push.const . max)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 20554)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 20518)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 20492))
 (set.gloc.of max)
 (ret.const.unspec))
((close
   (0 1 . min)
   (iloc.0 . 0)
   (if.null?
     (push.const . min)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 25612))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 26650)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 26636)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 29724))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 30755)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 30741)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 31778)
           (<.iloc (0 . 0) "./boot/r6rs-aux.scm" . 31775)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 31795))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 32812)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 32802))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 33819)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 31765))
       (push.const . min)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 35923)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 35887)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 35861))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27678)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27704)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 27694)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27722)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 27660))
   (push.const . min)
   (push.const . "expected real, but got ~s")
   (push.gloc.of lst)
   (push.subr.gloc.of car 1 "./boot/r6rs-aux.scm" . 37962)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 37926)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 37900))
 (set.gloc.of min)
 (ret.const.unspec))
((close
   (2 0 . gcd2)
   (=n.iloc (0 . 1) 0 "./boot/r6rs-aux.scm" . 41993)
   (if.true
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 43026)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 43039))
       (ret.iloc 0 . 0))
     (push)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 43017))
   (touch.gloc.of gcd2)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of remainder 2 "./boot/r6rs-aux.scm" . 44049)
   (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 44041))
 (set.gloc.of gcd2)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 53261)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54292)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54302)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 54286))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 55315)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 55310))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 0)
   (touch.gloc.of loop\x60;7)
   (call
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57377)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57387)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 57371))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57399)
   (push.cons)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 57359))
 (set.gloc.of loop\x60;7)
 (close
   (0 1 . gcd)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 49173)
       (if.true.ret)
       (push.const . gcd)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 50223)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 50197))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 48133))
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 52229))
 (set.gloc.of gcd)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 73741)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of lcm2\x60;2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74772)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74782)
     (apply.gloc.of lcm2\x60;2 "./boot/r6rs-aux.scm" . 74766))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 75795)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 75790))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 1)
   (touch.gloc.of loop\x60;9)
   (call
     (touch.gloc.of lcm2\x60;2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77857)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77867)
     (apply.gloc.of lcm2\x60;2 "./boot/r6rs-aux.scm" . 77851))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77879)
   (push.cons)
   (apply.gloc.of loop\x60;9 "./boot/r6rs-aux.scm" . 77839))
 (set.gloc.of loop\x60;9)
 (close
   (2 0 . lcm2)
   (call
     (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 64529)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 0)
     (ret.subr.gloc.of = "./boot/r6rs-aux.scm" . 64537))
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of exact? 1 "./boot/r6rs-aux.scm" . 65558)
       (if.false.ret)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of exact? "./boot/r6rs-aux.scm" . 65569))
     (if.true.ret.const . 0)
     (ret.const . 0.0))
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of gcd2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 66593))
   (push)
   (push.subr.gloc.of quotient 2 "./boot/r6rs-aux.scm" . 66581)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 66578)
   (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 66573))
 (set.gloc.of lcm2\x60;2)
 (close
   (0 1 . lcm)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 69653)
       (if.true.ret)
       (push.const . lcm)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 70703)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 70677))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 68613))
   (touch.gloc.of loop\x60;9)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;9 "./boot/r6rs-aux.scm" . 72709))
 (set.gloc.of lcm)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 92183)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.subr.gloc.of ceiling 1 "./boot/r6rs-aux.scm" . 94240)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 1) "./boot/r6rs-aux.scm" . 95264)
   (if.true (ret.iloc 0 . 0))
   (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 97321)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1)
   (call
     (touch.gloc.of loop\x60;7)
     (push.const . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98359)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98354)
     (push.const . 1)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 98375)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98370)
     (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 98348))
   (push)
   (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 98343)
   (ret.subr.gloc.of + "./boot/r6rs-aux.scm" . 98338))
 (set.gloc.of loop\x60;7)
 (close
   (2 0 . rationalize)
   (push.iloc.0 . 0)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 81929)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 81973)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 82026)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 81939))
   (push.iloc.0 . 1)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 82953)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 82997)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 83050)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 82963))
   (push.iloc.0 . 1)
   (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 83980)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 85008)
     (if.true.ret.const . +nan.0)
     (ret.const . 0.0))
   (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 86028)
   (if.true.ret.const . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of negative? 1 "./boot/r6rs-aux.scm" . 87052)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 1 "./boot/r6rs-aux.scm" . 88092)
       (push.iloc.0 . 1)
       (apply.gloc.of rationalize "./boot/r6rs-aux.scm" . 88079))
     (push)
     (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 88076))
   (push.iloc.0 . 1)
   (push.subr.gloc.of abs 1 "./boot/r6rs-aux.scm" . 90133)
   (extend . 1)
   (touch.gloc.of loop\x60;7)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 91169)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of + 2 "./boot/r6rs-aux.scm" . 91183)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 91150))
 (set.gloc.of rationalize)
 (ret.const.unspec))
((close
   (1 0 . string->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/r6rs-aux.scm" . 115729)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (push.subr.gloc.of get-char 1 "./boot/r6rs-aux.scm" . 117779)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/r6rs-aux.scm" . 118799)
     (if.true (push.iloc.1 . 0) (ret.subr.gloc.of reverse "./boot/r6rs-aux.scm" . 119823))
     (push.iloc.0 . 0)
     (iloc.1 . 0)
     (push.cons)
     (apply.iloc+ (2 . 0) "./boot/r6rs-aux.scm" . 120847))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 116743))
 (set.gloc.of string->list)
 (ret.const.unspec))
((close
   (2 0 . map-1)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 130076)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 130070))
   (push)
   (call
     (touch.gloc.of map-1\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 131106)
     (apply.gloc.of map-1\x60;2 "./boot/r6rs-aux.scm" . 131094))
   (ret.cons "./boot/r6rs-aux.scm" . 130064))
 (set.gloc.of map-1\x60;2)
 (close
   (2 0 . map-n)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 137250)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 137238))
   (push)
   (call
     (touch.gloc.of map-n\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 138274)
     (apply.gloc.of map-n\x60;2 "./boot/r6rs-aux.scm" . 138262))
   (ret.cons "./boot/r6rs-aux.scm" . 137232))
 (set.gloc.of map-n\x60;2)
 (close
   (2 1 . map)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 141325)
     (if.true
       (touch.gloc.of map-1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of map-1\x60;2 "./boot/r6rs-aux.scm" . 142349))
     (push.const . map)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 143399))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 143450)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 143373))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 144400))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of map-n\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of map-n\x60;2 "./boot/r6rs-aux.scm" . 145441))
   (push.const . map)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 147534)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 147472))
 (set.gloc.of map)
 (ret.const.unspec))
((close
   (2 0 . for-each-1)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 155686)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 155680))
   (touch.gloc.of for-each-1\x60;2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 156721)
   (apply.gloc.of for-each-1\x60;2 "./boot/r6rs-aux.scm" . 156704))
 (set.gloc.of for-each-1\x60;2)
 (close
   (2 0 . for-each-n)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 160813)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 160801))
   (touch.gloc.of for-each-n\x60;2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 161842)
   (apply.gloc.of for-each-n\x60;2 "./boot/r6rs-aux.scm" . 161825))
 (set.gloc.of for-each-n\x60;2)
 (close
   (2 1 . for-each)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 163853)
     (if.true
       (touch.gloc.of for-each-1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of for-each-1\x60;2 "./boot/r6rs-aux.scm" . 164877))
     (push.const . for-each)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 165932))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 165983)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 165901))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 166928))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of for-each-n\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each-n\x60;2 "./boot/r6rs-aux.scm" . 167969))
   (push.const . for-each)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 170067)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 170000))
 (set.gloc.of for-each)
 (ret.const.unspec))
((close
   (2 1 . vector-map)
   (call
     (push.gloc.of map)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 175126)
     (call
       (push.gloc.of vector->list)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/r6rs-aux.scm" . 176141))
     (push)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 175110))
   (push)
   (ret.subr.gloc.of list->vector "./boot/r6rs-aux.scm" . 174085))
 (set.gloc.of vector-map)
 (ret.const.unspec))
((close
   (2 1 . vector-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 180250)
   (call
     (push.gloc.of vector->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 181260))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 180229))
 (set.gloc.of vector-for-each)
 (ret.const.unspec))
((close
   (2 1 . string-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/r6rs-aux.scm" . 185370))
   (push)
   (call
     (push.gloc.of string->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 186380))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 185349))
 (set.gloc.of string-for-each)
 (ret.const.unspec))
((close
   (2 0 . call-with-values)
   (touch.gloc.of apply-values)
   (push.iloc.0 . 1)
   (call (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 190492))
   (push)
   (apply.gloc.of apply-values "./boot/r6rs-aux.scm" . 190469))
 (set.gloc.of call-with-values)
 (ret.const.unspec))
((close
   (2 0 . mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 194573)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 194570)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 194565))
 (set.gloc.of mod)
 (ret.const.unspec))
((close
   (2 0 . div-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 198670)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 199702)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 199697)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 199687))
 (set.gloc.of div-and-mod)
 (ret.const.unspec))
((close
   (2 0 . mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 203789)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 203786)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 203781))
 (set.gloc.of mod0)
 (ret.const.unspec))
((close
   (2 0 . div0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 207887)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 208919)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 208914)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 208903))
 (set.gloc.of div0-and-mod0)
 (ret.const.unspec))

;
((close
   (1 0 . top-level-unbound?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-bound? 1 "./boot/common.scm" . 7178)
   (ret.subr.gloc.of not "./boot/common.scm" . 7173))
 (set.gloc.of top-level-unbound?)
 (ret.const.unspec))
((close
   (3 0 . acons)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (ret.cons "./boot/common.scm" . 11269))
 (set.gloc.of acons)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 16413)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 16423)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 16407))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . count-pair)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 15365))
 (set.gloc.of count-pair)
 (ret.const.unspec))
((close
   (1 0 . circular-tree?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (2 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/common.scm" . 22546)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/common.scm" . 23570))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 25625)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/common.scm" . 27685)
           (push.iloc.0 . 0)
           (apply.iloc (2 . 0) "./boot/common.scm" . 27679))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/common.scm" . 28709)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/common.scm" . 28703))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/common.scm" . 29721)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 30745)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 32813))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/common.scm" . 32832)
         (apply.gloc.of any1 "./boot/common.scm" . 32795))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/common.scm" . 33817)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 34841)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 36909))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/common.scm" . 36928)
         (apply.gloc.of any1 "./boot/common.scm" . 36891))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc (0 . 0) "./boot/common.scm" . 21516))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of circular-tree?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 45073)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 45083)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 45067))
   (call (iloc.0 . 0) (if.not.null?.ret.const . #f) (ret.iloc 0 . 1))
   (if.true.ret)
   (ret.const . -1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . safe-length)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 43013))
 (set.gloc.of safe-length)
 (ret.const.unspec))
((close
   (2 0 . split-at)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-head 2 "./boot/common.scm" . 50191)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-tail 2 "./boot/common.scm" . 50209)
   (ret.subr.gloc.of values "./boot/common.scm" . 50183))
 (set.gloc.of split-at)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/common.scm" . 57384)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 58400)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 58410)
   (subr.gloc.of memq 2 "./boot/common.scm" . 58394)
   (if.true.ret)
   (touch.gloc.of loop\x60;5)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 59424)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 59418))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . unique-id-list?)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 54282)
   (if.false.ret)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 55311))
   (push)
   (ret.subr.gloc.of not "./boot/common.scm" . 54277))
 (set.gloc.of unique-id-list?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 66587)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 66597)
   (subr.gloc.of memq 2 "./boot/common.scm" . 66581)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/common.scm" . 67605))
   (touch.gloc.of loop\x60;5)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 68635)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 68629))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . find-duplicates)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 63498)
   (if.false.ret)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 64522))
 (set.gloc.of find-duplicates)
 (ret.const.unspec))
((close
   (2 0 . every1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/common.scm" . 74768))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 76826)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 76837)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 76820))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 73754)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 73771)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 73737))
 (set.gloc.of every1)
 (ret.const.unspec))
((close
   (3 0 . every2)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 2)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (4 0 . loop)
     (call (push.iloc.0 . 0) (push.iloc.0 . 2) (apply.iloc (2 . 0) "./boot/common.scm" . 83984))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 3)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 87066)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 87078)
     (push.car.iloc (0 . 3) "./boot/common.scm" . 87090)
     (push.cdr.iloc (0 . 3) "./boot/common.scm" . 87102)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 87060))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 82971)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 82990)
   (push.car.iloc (1 . 2) "./boot/common.scm" . 83009)
   (push.cdr.iloc (1 . 2) "./boot/common.scm" . 83028)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 82953))
 (set.gloc.of every2)
 (ret.const.unspec))
((close
   (2 0 . any1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 92180)
     (apply.iloc (0 . 0) "./boot/common.scm" . 92174))
   (if.true.ret)
   (touch.gloc.of any1)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 92202)
   (apply.gloc.of any1 "./boot/common.scm" . 92191))
 (set.gloc.of any1)
 (ret.const.unspec))
((close
   (3 0 . any2)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 2)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 98324)
     (push.car.iloc (0 . 2) "./boot/common.scm" . 98335)
     (apply.iloc (0 . 0) "./boot/common.scm" . 98318))
   (if.true.ret)
   (touch.gloc.of any2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 99353)
   (push.cdr.iloc (0 . 2) "./boot/common.scm" . 99364)
   (apply.gloc.of any2 "./boot/common.scm" . 99342))
 (set.gloc.of any2)
 (ret.const.unspec))
((close
   (2 0 . filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105492)
       (apply.iloc (2 . 0) "./boot/common.scm" . 105486))
     (if.true
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105509)
       (call
         (push.cdr.iloc (0 . 0) "./boot/common.scm" . 105525)
         (apply.iloc+ (1 . 0) "./boot/common.scm" . 105519))
       (ret.cons "./boot/common.scm" . 105503))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 106521)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 106515))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 103429))
 (set.gloc.of filter)
 (ret.const.unspec))
((close
   (2 0 . partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111650)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111665)
       (ret.subr.gloc.of values "./boot/common.scm" . 111642))
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112660)
       (apply.iloc (2 . 0) "./boot/common.scm" . 112654))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/common.scm" . 112677)
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112693)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 112671))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 113689)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/common.scm" . 113710)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 113683))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 110597))
 (set.gloc.of partition)
 (ret.const.unspec))
((close
   (2 0 . split->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/common.scm" . 120851)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop1)
     (extend.enclose+
       (1 0 . loop2)
       (push.iloc.0 . 0)
       (subr.gloc.of eof-object? 1 "./boot/common.scm" . 124950)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 125983)
         (extend . 1)
         (push.iloc.0 . 0)
         (push.const . "")
         (subr.gloc.of string=? 2 "./boot/common.scm" . 127004)
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of reverse "./boot/common.scm" . 128028))
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (push.cons)
         (ret.subr.gloc.of reverse "./boot/common.scm" . 129052))
       (call (push.iloc.0 . 0) (apply.iloc (5 . 1) "./boot/common.scm" . 130070))
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 131107)
         (iloc 2 . 0)
         (push.cons)
         (apply.iloc+ (3 . 0) "./boot/common.scm" . 131094))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of put-char 2 "./boot/common.scm" . 133142)
       (push.iloc 4 . 0)
       (push.subr.gloc.of get-char 1 "./boot/common.scm" . 134173)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 134166))
     (push.iloc 3 . 0)
     (push.subr.gloc.of get-char 1 "./boot/common.scm" . 123932)
     (apply.iloc+ (0 . 0) "./boot/common.scm" . 123917))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 122891))
 (set.gloc.of split->list\x60;2)
 (close
   (2 0 . string-split)
   (push.iloc.0 . 1)
   (subr.gloc.of char? 1 "./boot/common.scm" . 136204)
   (if.true
     (touch.gloc.of split->list\x60;2)
     (push.iloc.0 . 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of char=? "./boot/common.scm" . 137257))
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 137228))
   (push.iloc.0 . 1)
   (subr.gloc.of string? 1 "./boot/common.scm" . 138252)
   (if.true
     (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/common.scm" . 139287))
     (push)
     (extend . 1)
     (touch.gloc.of split->list\x60;2)
     (push.iloc.1 . 0)
     (push.close
       (1 0)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of char=? "./boot/common.scm" . 140349))
       (push.iloc.1 . 0)
       (apply.gloc.of any1 "./boot/common.scm" . 140331))
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 140302))
   (push.iloc.0 . 1)
   (subr.gloc.of procedure? 1 "./boot/common.scm" . 141324)
   (if.true
     (touch.gloc.of split->list\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 142348))
   (ret.const.unspec))
 (set.gloc.of string-split)
 (ret.const.unspec))
((close
   (2 1 . wrong-type-argument-message)
   (iloc.0 . 2)
   (if.null?
     (push.const . "expected ~a, but got ~a")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of format "./boot/common.scm" . 147465))
   (push.const . "expected ~a, but got ~a, as argument ~a")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.car.iloc (0 . 2) "./boot/common.scm" . 148550)
   (ret.subr.gloc.of format "./boot/common.scm" . 148489))
 (set.gloc.of wrong-type-argument-message)
 (ret.const.unspec))

;
((close
   (1 1 . make-parameter)
   (call
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of parameter-proc-0)
       (subr.gloc.of gensym 0)
       (push)
       (apply.gloc.of parameter-proc-0 "./boot/parameter.scm" . 8218))
     (touch.gloc.of parameter-proc-1)
     (subr.gloc.of gensym 0)
     (push)
     (push.car.iloc (0 . 1) "./boot/parameter.scm" . 9269)
     (apply.gloc.of parameter-proc-1 "./boot/parameter.scm" . 9242))
   (push)
   (extend . 1)
   (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/parameter.scm" . 10254))
   (ret.iloc 0 . 0))
 (set.gloc.of make-parameter)
 (ret.const.unspec))
((close
   (1 0 . parameter-proc-0)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 16395))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (0 . 0) "./boot/parameter.scm" . 17474)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 17419)))
 (set.gloc.of parameter-proc-0)
 (ret.const.unspec))
((close
   (2 0 . parameter-proc-1)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 23563))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (call
       (push.car.iloc (0 . 0) "./boot/parameter.scm" . 24648)
       (apply.iloc (1 . 1) "./boot/parameter.scm" . 24642))
     (push)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 24587)))
 (set.gloc.of parameter-proc-1)
 (ret.const.unspec))

;
((call (push.const . "") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 5152))
 (set.gloc.of current-library-prefix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 6175))
 (set.gloc.of current-library-infix)
 (ret.const.unspec))
((call (push.const . "'") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 7200))
 (set.gloc.of current-library-suffix)
 (ret.const.unspec))
((call (push.const . ".") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 8226))
 (set.gloc.of current-primitive-prefix)
 (ret.const.unspec))
((call (push.const . "`") (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 9250))
 (set.gloc.of current-rename-delimiter)
 (ret.const.unspec))
((call (push.const . 5) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 10269))
 (set.gloc.of expansion-backtrace)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 11295))
 (set.gloc.of expansion-trace-stack)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 12319))
 (set.gloc.of expansion-trace-level)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 13351))
 (set.gloc.of current-immutable-identifiers)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 14368))
 (set.gloc.of current-expansion-mode)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 15399))
 (set.gloc.of current-expansion-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 16418))
 (set.gloc.of current-macro-expression)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 17449))
 (set.gloc.of current-transformer-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 18465))
 (set.gloc.of unexpect-top-level-form)
 (ret.const.unspec))
((close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 19494))
 (set.gloc.of current-after-expansion-hook)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 20513))
 (set.gloc.of current-temporary-count)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 21534))
 (set.gloc.of current-rename-count)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 22562))
 (set.gloc.of current-closure-comments)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 23588))
 (set.gloc.of current-top-level-exterior)
 (ret.const.unspec))
((close
   (4 0)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/initial.scm" . 27658)
     (if.false.ret)
     (push.iloc.0 . 1)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 28682))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (const . syntax)
     (if.eq?
       (touch.gloc.of make-macro)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of make-macro "./boot/macro/initial.scm" . 33821))
     (push.iloc.0 . 0)
     (const . variable)
     (if.eq?
       (push.iloc.0 . 2)
       (subr.gloc.of procedure? 1 "./boot/macro/initial.scm" . 35876)
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 36900))
       (call
         (touch.gloc.of variable-transformer-token?)
         (push.iloc.0 . 2)
         (apply.gloc.of variable-transformer-token? "./boot/macro/initial.scm" . 37924))
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/initial.scm" . 38969)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 38948))
       (push.const
         .
         "internal error in .set-top-level-macro!: bad transformer type:~s keyword:~s datum:~s")
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 40996))
     (ret.const.unspec))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 26627))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;set-top-level-macro!)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 26627))
((close
   (1 0 . core-primitive-name)
   (push.const . "~a~a")
   (call
     (touch.gloc.of current-primitive-prefix)
     (apply.gloc.of current-primitive-prefix "./boot/macro/initial.scm" . 45092))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 3 "./boot/macro/initial.scm" . 45077)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 45061))
 (set.gloc.of core-primitive-name)
 (ret.const.unspec))
((close
   (2 0 . generate-global-id)
   (push.const . "~a~a~a~a")
   (call
     (touch.gloc.of current-library-prefix)
     (apply.gloc.of current-library-prefix "./boot/macro/initial.scm" . 49192))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-library-suffix)
     (apply.gloc.of current-library-suffix "./boot/macro/initial.scm" . 49228))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 49173)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 49157))
 (set.gloc.of generate-global-id)
 (ret.const.unspec))
((close
   (0 0 . generate-temporary-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 53266))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 54304)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 54279))
   (push.const . ".L~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/initial.scm" . 55319)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 55303))
 (set.gloc.of generate-temporary-symbol)
 (ret.const.unspec))
((close
   (1 0 . generate-local-macro-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 59410))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 60448)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 60423))
   (push.const . ".local-macro-~a.~a~a~a")
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 61505))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 61532))
   (push)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 61463)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 61447))
 (set.gloc.of generate-local-macro-symbol)
 (ret.const.unspec))
((close
   (0 0 . fresh-rename-count)
   (call
     (touch.gloc.of current-rename-count)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65566))
     (push)
     (push.const . 1)
     (push.subr.gloc.of + 2 "./boot/macro/initial.scm" . 65563)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65541))
   (touch.gloc.of current-rename-count)
   (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 66565))
 (set.gloc.of fresh-rename-count)
 (ret.const.unspec))
((close
   (2 0 . rename-id)
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 70697))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 70677)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 70661))
 (set.gloc.of rename-id)
 (ret.const.unspec))
((close
   (1 0 . renamed-id?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of symbol-contains)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of current-rename-delimiter)
     (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 75806))
   (push)
   (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 75786))
 (set.gloc.of renamed-id?)
 (ret.const.unspec))
((close
   (1 0 . original-id)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 79904))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 79884))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 80953)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of substring 3 "./boot/macro/initial.scm" . 80942)
     (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 80926))
   (ret.iloc 1 . 0))
 (set.gloc.of original-id)
 (ret.const.unspec))
((close
   (1 0 . strip-rename-suffix)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 87082)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 87061))
     (push)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 88106)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 88085))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/initial.scm" . 89121)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/initial.scm" . 89139)
       (ret.eq? "./boot/macro/initial.scm" . 89132))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/initial.scm" . 90138))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of original-id)
     (push.iloc.0 . 0)
     (apply.gloc.of original-id "./boot/macro/initial.scm" . 91162))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/initial.scm" . 92172)
   (if.true
     (call
       (push.gloc.of strip-rename-suffix)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/initial.scm" . 92225)
       (apply.gloc.of map "./boot/macro/initial.scm" . 92200))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/initial.scm" . 92186))
   (ret.iloc 0 . 0))
 (set.gloc.of strip-rename-suffix)
 (ret.const.unspec))
((close
   (1 0 . retrieve-rename-suffix)
   (call
     (touch.gloc.of symbol-contains)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of current-rename-delimiter)
       (apply.gloc.of current-rename-delimiter "./boot/macro/initial.scm" . 97312))
     (push)
     (apply.gloc.of symbol-contains "./boot/macro/initial.scm" . 97292))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 99357)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/macro/initial.scm" . 100392)
     (ret.subr.gloc.of substring "./boot/macro/initial.scm" . 100371))
   (ret.const . ""))
 (set.gloc.of retrieve-rename-suffix)
 (ret.const.unspec))
((close
   (2 0 . set-closure-comment!)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 105482))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 106527))
   (push)
   (push.iloc.0 . 0)
   (push.const . heap)
   (iloc.0 . 1)
   (push.cons)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 106506))
 (set.gloc.of set-closure-comment!)
 (ret.const.unspec))
((close
   (2 1 . annotate-closure)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 110602))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 111653))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 111633)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.1 . 2)
     (if.null?
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 114735))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 114714))
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 115759))
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (1 . 2) "./boot/macro/initial.scm" . 115797)
     (cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 115808)
     (push.cons)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 115738))
   (ret.const.unspec))
 (set.gloc.of annotate-closure)
 (ret.const.unspec))
((close
   (1 0 . annotated?)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 119818)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 120842)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of annotated?)
 (ret.const.unspec))
((close
   (1 0 . get-annotation)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 126986)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 128010))
 (set.gloc.of get-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-annotation)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 133130)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 134154))
   (ret.iloc 0 . 0))
 (set.gloc.of put-annotation)
 (ret.const.unspec))
((close
   (1 0 . get-note)
   (touch.gloc.of loop\x60;15)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 152585))
 (set.gloc.of get-note\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 154644)
   (if.true.ret)
   (call
     (touch.gloc.of loop\x60;15)
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 155674)
     (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 155668))
   (if.true.ret)
   (touch.gloc.of loop\x60;15)
   (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 156698)
   (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 156692))
 (set.gloc.of loop\x60;15)
 (close
   (2 0 . put-note!)
   (iloc.0 . 1)
   (if.false.ret)
   (extend.enclose
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/initial.scm" . 144405)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 145433)
     (if.true.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (subr.gloc.of core-hashtable-set! 3 "./boot/macro/initial.scm" . 147483)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/macro/initial.scm" . 148507))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/initial.scm" . 143374))
 (set.gloc.of put-note!\x60;2)
 (close
   (2 0 . annotate)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #f)
     (call
       (call
         (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 162840)
         (if.false.ret)
         (touch.gloc.of get-note\x60;2)
         (push.iloc.0 . 1)
         (apply.gloc.of get-note\x60;2 "./boot/macro/initial.scm" . 162866))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of put-note!\x60;2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of put-note!\x60;2 "./boot/macro/initial.scm" . 163874))
       (ret.const.unspec))
     (call
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164888))
       (if.false.ret)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164935))
       (push)
       (push.iloc.0 . 1)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 164915))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 165943))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 165922))
     (ret.const.unspec))
   (ret.iloc 0 . 0))
 (set.gloc.of annotate)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 174095)
     (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 174104))
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 175130)
     (call
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 175146)
       (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 175156)
       (apply.gloc.of loop\x60;5 "./boot/macro/initial.scm" . 175140))
     (ret.cons "./boot/macro/initial.scm" . 175124))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;5)
 (close
   (2 0 . abbreviated-take)
   (touch.gloc.of annotate)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;5 "./boot/macro/initial.scm" . 172038))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 172038))
 (set.gloc.of abbreviated-take)
 (ret.const.unspec))
((close
   (3 0 . abbreviated-take-form)
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 183315)
           (if.true.ret)
           (push.iloc.0 . 2)
           (push.const . 0)
           (ret.subr.gloc.of <= "./boot/macro/initial.scm" . 183325))
         (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 183336))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 184352)
           (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 184362)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184346))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 184381)
           (push.iloc 2 . 1)
           (push.n+.iloc (0 . 2) -1 "./boot/macro/initial.scm" . 184396)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 184375))
         (ret.cons "./boot/macro/initial.scm" . 184340))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.iloc+ (0 . 0) "./boot/macro/initial.scm" . 181254))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 179203))
 (set.gloc.of abbreviated-take-form)
 (ret.const.unspec))

;
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 9234)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 9259)
       (apply.gloc.of formals->list "./boot/macro/expand.scm" . 9244))
     (ret.cons "./boot/macro/expand.scm" . 9228))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/macro/expand.scm" . 11276))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . collect-lambda-formals)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/macro/expand.scm" . 15377))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/expand.scm" . 16395))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 17437)
     (push.const . "malformed formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 17419))
   (call
     (call
       (touch.gloc.of unique-id-list?)
       (push.iloc.0 . 0)
       (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 18443))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 19485)
     (push.const . "duplicate formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 19467))
   (ret.iloc 0 . 0))
 (set.gloc.of collect-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . rename-lambda-formals)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 26653)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 26647)
     (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 26642)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 27689)
       (push.iloc.0 . 1)
       (apply.gloc.of rename-lambda-formals "./boot/macro/expand.scm" . 27666))
     (ret.cons "./boot/macro/expand.scm" . 26636))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 29713)
   (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 29708))
 (set.gloc.of rename-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . check-let*-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 33801)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 34843)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 34825))
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.0 . 0)
         (apply.gloc.of safe-length "./boot/macro/expand.scm" . 36893))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/expand.scm" . 36890)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 36927)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 36918))
     (if.true.ret)
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 37927)
     (push.const . "expected each binding consist of symbol and expression")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 37909))
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/expand.scm" . 35845))
 (set.gloc.of check-let*-bindings)
 (ret.const.unspec))
((close
   (2 0 . check-let-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 43017)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 44059)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 44041))
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.close
         (1 0)
         (call
           (call
             (touch.gloc.of safe-length)
             (push.iloc.0 . 0)
             (apply.gloc.of safe-length "./boot/macro/expand.scm" . 47133))
           (push)
           (push.const . 2)
           (subr.gloc.of = 2 "./boot/macro/expand.scm" . 47130)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 47167)
           (if.not.symbol?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 47182))
         (if.true.ret)
         (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 48167)
         (push.const . "expected each binding consist of symbol and expression")
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 48149))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 46090))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 45065))
   (if.true.ret)
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 50203)
   (push.const . "duplicate bindings")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 50185))
 (set.gloc.of check-let-bindings)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 57353))
 (set.gloc.of filter-unique-ids\x60;2)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 59416)
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 60446)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 60440))
     (push)
     (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 59410))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 62489)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 63518))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;7)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 72738)
     (push.const . quote)
     (push.subr.gloc.of eq? 2 "./boot/macro/expand.scm" . 72733)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 72728))
   (if.true
     (push.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 73747))
   (ret.const))
 (set.gloc.of loop\x60;15)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of filter-unique-ids\x60;2)
   (call
     (touch.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;15 "./boot/macro/expand.scm" . 69642))
   (push)
   (apply.gloc.of filter-unique-ids\x60;2 "./boot/macro/expand.scm" . 56327))
 (set.gloc.of collect-ids\x60;2)
 (close
   (2 0 . check-internal-def-contract-violation)
   (call
     (touch.gloc.of collect-ids\x60;2)
     (push.iloc.0 . 1)
     (apply.gloc.of collect-ids\x60;2 "./boot/macro/expand.scm" . 76816))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 77855)
     (if.false.ret)
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 77831))
 (set.gloc.of check-internal-def-contract-violation)
 (ret.const.unspec))
((close
   (1 0 . filter-unique-ids)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 85001))
 (set.gloc.of filter-unique-ids\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 100387)
     (push.const lambda quote)
     (push.subr.gloc.of memq 2 "./boot/macro/expand.scm" . 100381)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 100376))
   (if.true
     (push.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 101395))
   (ret.const))
 (set.gloc.of loop\x60;15)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 87064)
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 88094)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 88088))
     (push)
     (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 87058))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 90137)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 91166))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;7)
 (close
   (1 0 . collect-ids)
   (touch.gloc.of filter-unique-ids\x60;2)
   (call
     (touch.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;15 "./boot/macro/expand.scm" . 97290))
   (push)
   (apply.gloc.of filter-unique-ids\x60;2 "./boot/macro/expand.scm" . 83975))
 (set.gloc.of collect-ids\x60;2)
 (close
   (2 0 . check-rec-contract-violation)
   (call
     (touch.gloc.of collect-ids\x60;2)
     (push.iloc.0 . 1)
     (apply.gloc.of collect-ids\x60;2 "./boot/macro/expand.scm" . 104464))
   (push)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 107543)
       (push.iloc 2 . 0)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 107537)
       (if.true
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 108567)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 108584)
         (iloc.0 . 1)
         (push.cons)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 108561))
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 109591)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 109585))
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of reverse "./boot/macro/expand.scm" . 110622))
   (push.iloc 2 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 105479))
 (set.gloc.of check-rec-contract-violation)
 (ret.const.unspec))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc.0 . 0)
       (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 116786)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 116751))
     (if.true
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 117781)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 117792)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 117810)
       (iloc.0 . 2)
       (push.cons)
       (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 117775))
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 118805)
     (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 118816)
     (push.iloc.0 . 2)
     (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 118799))
   (iloc.0 . 2)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of reverse "./boot/macro/expand.scm" . 119836))
 (set.gloc.of loop\x60;5)
 (close
   (2 0 . check-rec*-contract-violation)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 114693))
 (set.gloc.of check-rec*-contract-violation)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/expand.scm" . 132103))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . rewrite-letrec*-bindings)
   (push.close
     (0 0)
     (touch.gloc.of partition)
     (push.close
       (1 0)
       (cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 126003)
       (if.not.pair?.ret.const . #t)
       (call
         (touch.gloc.of denote-quote?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 127034)
         (apply.gloc.of denote-quote? "./boot/macro/expand.scm" . 127015))
       (if.true.ret)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 128059)
         (apply.gloc.of denote-lambda? "./boot/macro/expand.scm" . 128039))
       (if.true
         (call
           (touch.gloc.of set-closure-comment!)
           (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 129092)
           (call
             (touch.gloc.of original-id)
             (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 129120)
             (apply.gloc.of original-id "./boot/macro/expand.scm" . 129107))
           (push)
           (apply.gloc.of set-closure-comment! "./boot/macro/expand.scm" . 129070))
         (ret.const . #t))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (apply.gloc.of partition "./boot/macro/expand.scm" . 123909))
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 122883))
 (set.gloc.of rewrite-letrec*-bindings)
 (ret.const.unspec))
((close
   (2 0 . flatten-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 139285)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 140309)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 140302)
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 141345)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 141326))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 146447))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 147477)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 148507)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 148501))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 147471))
       (iloc.0 . 1)
       (if.null? (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of append "./boot/macro/expand.scm" . 152598))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 144390))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 137221))
 (set.gloc.of flatten-begin)
 (ret.const.unspec))
((close
   (2 0 . flatten-top-level-begin)
   (extend.enclose+
     (1 0 . concatenate?)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 160789)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 161813)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 161806)
     (if.false.ret)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 162849)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 162830))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 0) "./boot/macro/expand.scm" . 167951))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 168981)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 170011)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 170005))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 168975))
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 172053)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 173083)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 173077))
       (ret.cons "./boot/macro/expand.scm" . 172047))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 165894))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 158725))
 (set.gloc.of flatten-top-level-begin)
 (ret.const.unspec))
((close
   (3 0 . compile-macro)
   (extend.unbound . 2)
   (push.close+
     (2 0 . compile-transformer)
     (push.const . \x2E;transformer-thunk)
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (call
             (touch.gloc.of make-out-of-context)
             (push.const . #f)
             (apply.gloc.of make-out-of-context "./boot/macro/expand.scm" . 182327))
           (push)
           (extend . 2)
           (call
             (push.close
               (1 0)
               (car.iloc (0 . 0) "./boot/macro/expand.scm" . 184364)
               (if.not.symbol?.ret.const . #f)
               (call
                 (touch.gloc.of renamed-id?)
                 (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 185392)
                 (apply.gloc.of renamed-id? "./boot/macro/expand.scm" . 185379))
               (if.false.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 186430)
               (push.const . #f)
               (subr.gloc.of core-hashtable-ref 3 "./boot/macro/expand.scm" . 186407)
               (if.true.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 187455)
               (push.iloc.1 . 1)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/expand.scm" . 187431))
             (push.iloc.1 . 1)
             (apply.gloc.of for-each "./boot/macro/expand.scm" . 183314))
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable->alist "./boot/macro/expand.scm" . 189458))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 190534))
       (push)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 190509))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/expand.scm" . 190481)
     (extend . 1)
     (call
       (touch.gloc.of interpret-coreform)
       (push.iloc.0 . 0)
       (apply.gloc.of interpret-coreform "./boot/macro/expand.scm" . 191513))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 192534)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 192552))
     (call
       (touch.gloc.of variable-transformer-token?)
       (push.iloc.0 . 0)
       (apply.gloc.of variable-transformer-token? "./boot/macro/expand.scm" . 193558))
     (if.true
       (call
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/expand.scm" . 194611)
         (push.iloc 2 . 1)
         (apply.gloc.of make-macro-variable "./boot/macro/expand.scm" . 194590))
       (push)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 194582))
     (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 196648)
     (push.const . "invalid transformer expression")
     (push.iloc 4 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 196630))
   (push.close
     (1 0 . syntax-rules?)
     (touch.gloc.of denote-syntax-rules?)
     (push.iloc 2 . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-syntax-rules? "./boot/macro/expand.scm" . 200713))
   (enclose . 2)
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (if.not.null?.ret.const . #f)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 179205))
   (if.true
     (push.const . syntax-rules)
     (push.const . "expected literals and rules")
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/expand.scm" . 179205)
     (if.false.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 179205))
   (if.true
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (push.cadr.iloc (1 . 1) "./boot/macro/expand.scm" . 179205)
     (extend . 2)
     (call
       (call
         (push.iloc.0 . 1)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 179205)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 1)
         (apply.gloc.of every1 "./boot/macro/expand.scm" . 179205))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "invalid literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 1)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 179205))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "duplicate literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
     (call
       (push.const . _)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 179205)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "_ in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
     (call
       (push.const . ...)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 179205)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "... in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 179205)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 179205)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 179205)
           (ret.null? "./boot/macro/expand.scm" . 179205))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;caar 1 "./boot/macro/expand.scm" . 179205)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 179205))
         (if.true.ret.const . #t)
         (iloc.0 . 0)
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected identifer for first subform of pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 179205)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 179205)
           (ret.null? "./boot/macro/expand.scm" . 179205))
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected list for pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
         (push.const . syntax-rules)
         (push.const . "expected (pattern template) for each rule")
         (push.iloc 4 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 179205))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/expand.scm" . 179205))
     (touch.gloc.of compile-syntax-rules)
     (push.iloc 2 . 1)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 2 . 2)
     (apply.gloc.of compile-syntax-rules "./boot/macro/expand.scm" . 179205))
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 179205))
 (set.gloc.of compile-macro)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 240695))
   (ret.cons "./boot/macro/expand.scm" . 240683))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (3 0 . expand-let-syntax-bindings)
   (call
     (push.gloc.of car)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 232465))
   (push)
   (extend . 1)
   (touch.gloc.of extend-env)
   (call
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 236598))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 237606))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 238635))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 235547))
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 233490))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 235528))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 240658))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 241682))
     (push)
     (ret.subr.gloc.of append "./boot/macro/expand.scm" . 240650))
   (push)
   (push.iloc.1 . 2)
   (apply.gloc.of extend-env "./boot/macro/expand.scm" . 232453))
 (set.gloc.of expand-let-syntax-bindings)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 256082))
   (ret.cons "./boot/macro/expand.scm" . 256062))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (3 0 . expand-letrec-syntax-bindings)
   (extend.enclose
     (1 0 . undefined-macro)
     (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 249883)
     (push.const . "attempt to reference uninitialized syntactic keyword")
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 249865))
   (call
     (push.gloc.of car)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 251921))
   (push)
   (call
     (push.gloc.of cadr)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 252946))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of make-macro)
       (push.iloc 2 . 0)
       (push.const)
       (apply.gloc.of make-macro "./boot/macro/expand.scm" . 254001))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 253981))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 256029))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 257053))
     (push)
     (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 256021)
     (push.iloc 3 . 2)
     (apply.gloc.of extend-env "./boot/macro/expand.scm" . 254996))
   (push)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 264245))
       (push)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 264266)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 264235))
     (push.iloc 2 . 0)
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 6 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 260153))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 261161))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 262190))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 259102))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 259083))
     (push)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 264205))
   (ret.iloc 0 . 0))
 (set.gloc.of expand-letrec-syntax-bindings)
 (ret.const.unspec))
((close
   (3 0 . expand-macro-use)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 270341))
   (call
     (touch.gloc.of current-macro-expression)
     (push.iloc.0 . 0)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 271365))
   (push.const . #f)
   (push.const . #f)
   (push.cddr.iloc (0 . 2) "./boot/macro/expand.scm" . 272473)
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 273415))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-transformer-environment)
       (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 273415))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 273415))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 2)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 273415))
   (push.close
     (0 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 273431)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 273419)
     (if.true (push.iloc 2 . 0) (cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 274444) (apply))
     (touch.gloc.of transcribe-syntax-rules)
     (push.iloc 2 . 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 275497)
     (apply.gloc.of transcribe-syntax-rules "./boot/macro/expand.scm" . 275467))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc.1 . 0)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 273415))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 1)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 273415))
   (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 273415))
 (set.gloc.of expand-macro-use)
 (ret.const.unspec))
((close
   (2 0 . rewrite-form)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 295959)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 295952))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 298000)
   (if.true
     (touch.gloc.of annotate)
     (call
       (touch.gloc.of rewrite-form-each\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form-each\x60;2 "./boot/macro/expand.scm" . 299034))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 299024))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/expand.scm" . 300048)
   (if.true
     (call
       (touch.gloc.of rewrite-form-each\x60;2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/expand.scm" . 301105)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form-each\x60;2 "./boot/macro/expand.scm" . 301086))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/expand.scm" . 301072))
   (ret.iloc 0 . 0))
 (set.gloc.of rewrite-form\x60;2)
 (close
   (2 0 . rewrite-form-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 285738)
       (push.iloc 2 . 1)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 285724))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 286754)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 286748))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/expand.scm" . 287781)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 287800)
       (ret.eq? "./boot/macro/expand.scm" . 287792))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 289816))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 282633))
 (set.gloc.of rewrite-form-each\x60;2)
 (close
   (2 0 . rewrite-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 306185)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 306185)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/expand.scm" . 306185))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 306185)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 306185)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 306185))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 306185))
     (push)
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 306185))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 306185))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/expand.scm" . 306185))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 306185))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of list)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 306185))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/expand.scm" . 306185))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of cons)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/expand.scm" . 306185))
       (push)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 306185))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 306185))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 306185)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 306185))
 (set.gloc.of rewrite-let-syntax\x60;2)
 (close
   (2 0 . rewrite-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/expand.scm" . 321545)
     (if.false.ret)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 321545))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 321545))
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 321545))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 321545))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 321545))
         (ret.cons "./boot/macro/expand.scm" . 321545))
       (call
         (push.gloc.of car)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 321545))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 321545))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (touch.gloc.of rewrite-form\x60;2)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 321545))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/expand.scm" . 321545))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 321545))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 321545))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 321545)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 321545))
 (set.gloc.of rewrite-letrec-syntax\x60;2)
 (close
   (2 0 . expand-initial-forms)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 333863)
     (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 333854))
   (if.true
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 334888)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 334872))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (gloc.of denote-let-syntax)
     (if.eq?
       (touch.gloc.of rewrite-let-syntax\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rewrite-let-syntax\x60;2 "./boot/macro/expand.scm" . 336917))
     (push.iloc.0 . 0)
     (gloc.of denote-letrec-syntax)
     (if.eq?
       (touch.gloc.of rewrite-letrec-syntax\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rewrite-letrec-syntax\x60;2 "./boot/macro/expand.scm" . 338965))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 339989))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 341042))
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 342052))
         (push)
         (ret.subr.gloc.of values "./boot/macro/expand.scm" . 342039))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 334860))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 344085))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of values "./boot/macro/expand.scm" . 346124))
 (set.gloc.of expand-initial-forms)
 (ret.const.unspec))
((close
   (3 0 . expand-body)
   (extend.unbound . 6)
   (push.const)
   (push.const)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 357407)
       (push.iloc 2 . 2)
       (apply.gloc.of extend-env "./boot/macro/expand.scm" . 357395))
     (set.iloc 2 . 2)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 358414))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/expand.scm" . 360481))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 1)
         (call
           (touch.gloc.of generate-local-macro-symbol)
           (push.iloc.0 . 0)
           (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 361529))
         (push.cons)
         (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 361510)
         (push.iloc 2 . 2)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 361498))
       (set.iloc 2 . 2)
       (ret.const.unspec))
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 362537)
       (push.iloc 3 . 2)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 362527))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 362505))
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 367637)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/expand.scm" . 368663)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 369706)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 369690))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 370708))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/expand.scm" . 374804))
   (push.close
     (3 0 . rewrite-body)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of annotate)
       (call
         (touch.gloc.of expand-each)
         (push.iloc.0 . 0)
         (push.iloc 2 . 2)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 380954))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of annotate "./boot/macro/expand.scm" . 380944))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 383013))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 382996))
       (if.true.ret)
       (call
         (touch.gloc.of find-duplicates)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 384047))
         (push)
         (apply.gloc.of find-duplicates "./boot/macro/expand.scm" . 384030))
       (push)
       (extend . 1)
       (push.const . define)
       (push.const . "duplicate definitions")
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 387121)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 387138))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 388154)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 388145)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 388172))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 385046))
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 389177)
         (push.iloc.1 . 2)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 389171)
         (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 389166))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 389147))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 390203)
         (push.iloc 3 . 2)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 390190))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 390171))
     (push)
     (extend . 2)
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/expand.scm" . 391193))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 393284)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 393292)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 393303))
         (push.iloc 2 . 2)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 393256))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 394272))
       (push.const . define)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 396338)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 398429)
             (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 398439)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 398399))
           (if.false.ret)
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 399423))
         (push.iloc 3 . 1)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 397362))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 395296))
     (call
       (touch.gloc.of check-internal-def-contract-violation)
       (call
         (push.gloc.of car)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 401472))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of check-internal-def-contract-violation "./boot/macro/expand.scm" . 401433))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 403486))
       (push.const . define)
       (push.const
         .
         "identifier ~u already used to determine the meaning of undeferred portions of definition")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 405552)
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 406583)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 406613))
         (ret.const . #f))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 391186))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 410688))
       (push)
       (push.iloc 5 . 2)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/expand.scm" . 410662))
     (push)
     (call
       (touch.gloc.of expand-each)
       (push.iloc 3 . 0)
       (push.iloc 5 . 2)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 410714))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/expand.scm" . 409625)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/expand.scm" . 409625)
     (push.iloc 5 . 1)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 409625))
   (enclose . 6)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 413715))
   (push)
   (extend . 1)
   (extend.enclose
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (car.iloc (0 . 0) "./boot/macro/expand.scm" . 416796)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 416817)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 416808))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 417832)
       (push.iloc 3 . 2)
       (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 417826)
       (set.iloc 3 . 2)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 4 . 2)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 418860)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 418844))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 420895))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 420889))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 422937)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdar 1 "./boot/macro/expand.scm" . 422937)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cddar 1 "./boot/macro/expand.scm" . 422937)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdddar 1 "./boot/macro/expand.scm" . 422937)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 422937)
           (ret.subr.gloc.of \x2E;list? "./boot/macro/expand.scm" . 422937))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/expand.scm" . 422937)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 422937))
         (if.true
           (push.cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 422937)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;caddar 1 "./boot/macro/expand.scm" . 422937)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/expand.scm" . 422937)
           (extend . 3)
           (call
             (push.close
               (0 0)
               (touch.gloc.of compile-macro)
               (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 422937)
               (push.iloc.1 . 1)
               (push.iloc 8 . 2)
               (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 422937))
             (push.close
               (1 1)
               (call
                 (iloc.0 . 1)
                 (if.not.pair?.ret.const . #f)
                 (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 422937)
                 (push.iloc 7 . 1)
                 (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 422937)
                 (set.iloc 7 . 1)
                 (ret.const.unspec))
               (call
                 (touch.gloc.of macro-variable?)
                 (push.iloc.0 . 0)
                 (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 422937))
               (if.true
                 (push.iloc.1 . 2)
                 (push.iloc.0 . 0)
                 (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 422937))
               (push.iloc.1 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.0 . 0)
                 (push.iloc 8 . 2)
                 (apply.gloc.of make-macro "./boot/macro/expand.scm" . 422937))
               (push)
               (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 422937))
             (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 422937))
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (call
             (touch.gloc.of acons)
             (push.iloc.0 . 2)
             (push.const . #f)
             (push.iloc 3 . 2)
             (apply.gloc.of acons "./boot/macro/expand.scm" . 422937))
           (push)
           (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 422937))
         (iloc.0 . 0)
         (if.true
           (push.iloc 2 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 422937)
           (push.const . "expected symbol for first clause")
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 422937)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 422937))
         (push.iloc 2 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 422937)
         (push.const . "expected symbol and transformer expression")
         (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 422937)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 422937))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 438339)
             (apply.gloc.of desugar-define "./boot/macro/expand.scm" . 438323))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 438318)
           (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 438352)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 438308))
         (push)
         (extend . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 439334)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 439361)
           (push.iloc 4 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 439350))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 2)
           (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 440356)
           (if.true
             (call
               (touch.gloc.of current-macro-expression)
               (push.iloc 7 . 0)
               (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 442409))
             (push.const . define)
             (push.const
               .
               "identifier ~u already used to determine the meaning of undeferred portions of definition")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 444475)
             (push.car.iloc (3 . 0) "./boot/macro/expand.scm" . 445499)
             (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 443433))
           (ret.const.unspec))
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (6 . 3) "./boot/macro/expand.scm" . 446493))
         (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 447523)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of acons "./boot/macro/expand.scm" . 447550))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 447517))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/expand.scm" . 448541))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/expand.scm" . 450589))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 451656)
           (push.iloc 6 . 2)
           (apply.gloc.of expand-initial-forms "./boot/macro/expand.scm" . 451634))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 6 . 2)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 453691)
             (push.iloc 6 . 2)
             (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 453676))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 455722)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 455716))
           (call (push.iloc.0 . 0) (apply.iloc (6 . 4) "./boot/macro/expand.scm" . 456740))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 457788)
             (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 457770)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 457764))
           (push.iloc.0 . 0)
           (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 459844)
           (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 459826)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 459856)
           (push.iloc 3 . 2)
           (apply.iloc (6 . 5) "./boot/macro/expand.scm" . 459812))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 418832))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 461868)
       (push.iloc.1 . 2)
       (apply.iloc (4 . 5) "./boot/macro/expand.scm" . 461849))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 463907)
     (push.iloc.0 . 2)
     (apply.iloc (3 . 5) "./boot/macro/expand.scm" . 463888))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 414744))
   (push)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 414727))
 (set.gloc.of expand-body)
 (ret.const.unspec))
((close
   (2 0 . expand-each)
   (call
     (touch.gloc.of current-macro-expression)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 467985))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (call
     (push.close
       (1 0)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc.1 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 470040))
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 471064))
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 469009))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 468999))
 (set.gloc.of expand-each)
 (ret.const.unspec))
((close
   (2 0 . expand-form)
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 478232))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.symbol? (ret.iloc 0 . 0))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 480277))
     (if.true
       (push.close
         (0 0)
         (call
           (touch.gloc.of expansion-trace-level)
           (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 482346))
         (push)
         (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 482370))
         (push)
         (subr.gloc.of < 2 "./boot/macro/expand.scm" . 482343)
         (if.true
           (push.const . #f)
           (push.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 483411))
           (push)
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 483438))
           (push.cons)
           (push.const . 1)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 484434))
           (push)
           (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 484429)
           (extend . 4)
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 485417))
             (set.iloc 1 . 0)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 485417))
             (set.iloc 1 . 1)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 2)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 485417))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 3)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 485417))
           (push.close
             (0 0)
             (touch.gloc.of expand-macro-use)
             (push.iloc 4 . 0)
             (push.iloc 4 . 1)
             (push.iloc 3 . 0)
             (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 485417))
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 0)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 485417))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 1)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 485417))
           (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 485417))
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 486439))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 487465))
         (push)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 487447))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 478220))
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/expand.scm" . 488469))
     (if.true
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound identifier ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 490545)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 491569))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/expand.scm" . 489493))
     (call
       (touch.gloc.of out-of-context?)
       (push.iloc.0 . 0)
       (apply.gloc.of out-of-context? "./boot/macro/expand.scm" . 492565))
     (if.true
       (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 493593)
       (if.true
         (push.const . #f)
         (push.const . "identifer ~u out of context")
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 495659)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 496683))
         (push)
         (call
           (touch.gloc.of annotate)
           (push.const . syntax)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 497731)
           (push.subr.gloc.of list 2 "./boot/macro/expand.scm" . 497717)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 497743)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 497707))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 494617))
       (push.const . #f)
       (push.const . "identifer ~u out of context")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 499755)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 500779))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 498713))
     (call
       (touch.gloc.of special?)
       (push.iloc.0 . 0)
       (apply.gloc.of special? "./boot/macro/expand.scm" . 501781))
     (if.true
       (push.const . #f)
       (push.const . "misplaced syntactic keyword ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 502826)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 502873))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 502805))
     (call
       (touch.gloc.of pattern-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of pattern-variable? "./boot/macro/expand.scm" . 503829))
     (if.true
       (push.const . #f)
       (push.const . "misplaced pattern variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 504874)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 504920))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 504853))
     (ret.iloc 1 . 0))
   (iloc.0 . 0)
   (if.null?
     (push.const . #f)
     (push.const . "invalid expression")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 507916))
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.0 . 0)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 509964))
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 511004)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.0 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 512047)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 512031))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 513052))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-macro-use)
           (push.iloc 2 . 0)
           (push.iloc 2 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 514105))
         (push.close
           (2 0)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 515109))
           (push)
           (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 515133))
           (push)
           (subr.gloc.of < 2 "./boot/macro/expand.scm" . 515106)
           (if.true
             (push.const . #f)
             (push.const . #f)
             (push.iloc 2 . 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 516179))
             (push.cons)
             (push.const . 1)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 517197))
             (push)
             (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 517192)
             (extend . 4)
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 518180))
               (set.iloc 1 . 0)
               (call
                 (touch.gloc.of expansion-trace-level)
                 (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 518180))
               (set.iloc 1 . 1)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 2)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 518180))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 3)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 518180))
             (push.close
               (0 0)
               (touch.gloc.of expand-form)
               (push.iloc 2 . 0)
               (call
                 (touch.gloc.of extend-env)
                 (push.iloc 2 . 1)
                 (push.iloc 4 . 1)
                 (apply.gloc.of extend-env "./boot/macro/expand.scm" . 518198))
               (push)
               (apply.gloc.of expand-form "./boot/macro/expand.scm" . 518180))
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 0)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 518180))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 1)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 518180))
             (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 518180))
           (touch.gloc.of expand-form)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of extend-env)
             (push.iloc.0 . 1)
             (push.iloc 2 . 1)
             (apply.gloc.of extend-env "./boot/macro/expand.scm" . 519220))
           (push)
           (apply.gloc.of expand-form "./boot/macro/expand.scm" . 519202))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 512019))
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/expand.scm" . 520220))
       (if.true
         (call
           (push.iloc.1 . 0)
           (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 521248)
           (if.true.ret)
           (push.const . #f)
           (push.const . "expression is not a proper list")
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 521261))
         (call
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 522276))
           (if.true.ret)
           (push.gloc.of denote-begin)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-import)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-macro)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-let-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-letrec-syntax)
           (iloc.0 . 0)
           (ret.eq? "./boot/macro/expand.scm" . 529444))
         (if.true
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 530465)
           (apply))
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 532514))
           (set.iloc 1 . 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.const . #t)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 532514))
         (push.close
           (0 0)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 532515)
           (apply))
         (push.close
           (0 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.iloc.1 . 0)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 532514))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 532514))
       (call
         (push.iloc.1 . 0)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 534560)
         (if.true.ret)
         (push.const . #f)
         (push.const . "expression is not a proper list")
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 534573))
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 535584))
       (if.true
         (touch.gloc.of expand-each)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 536608))
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 538658))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 538658))
       (push.close
         (0 0)
         (touch.gloc.of expand-each)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 538658))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 538658))
       (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 538658))
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 540695)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 540708))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 541719))
     (if.true
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 542743))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 544793))
       (set.iloc 1 . 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #t)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 544793))
     (push.close
       (0 0)
       (touch.gloc.of expand-each)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 544793))
     (push.close
       (0 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 0)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 544793))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 544793))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/expand.scm" . 545808)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/expand.scm" . 545824)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/expand.scm" . 545839)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/expand.scm" . 545852)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of bytevector? "./boot/macro/expand.scm" . 545867))
   (if.true (ret.iloc 0 . 0))
   (push.const . #f)
   (push.const . "invalid expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 547852))
 (set.gloc.of expand-form)
 (ret.const.unspec))
((close
   (1 1 . macro-expand)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (extend . 8)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-macro-expression)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 2)
     (call
       (touch.gloc.of current-expansion-mode)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 3)
     (call
       (touch.gloc.of current-top-level-exterior)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 4)
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 5)
     (call
       (touch.gloc.of expansion-trace-level)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 6)
     (call
       (touch.gloc.of expansion-trace-stack)
       (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 560135))
     (set.iloc 1 . 7)
     (call
       (touch.gloc.of current-temporary-count)
       (push.const . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-rename-count)
       (push.const . 0)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-macro-expression)
       (push.const . #f)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.const . #f)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #f)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.const . 0)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 560135))
     (touch.gloc.of expansion-trace-stack)
     (push.const)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 560135))
   (push.close
     (0 0)
     (call
       (call
         (touch.gloc.of denote-begin?)
         (push.const)
         (push.const . begin)
         (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 560151))
       (if.true
         (touch.gloc.of flatten-top-level-begin)
         (push.const . begin)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/expand.scm" . 561175)
         (push.gloc.of private-primitives-environment)
         (apply.gloc.of flatten-top-level-begin "./boot/macro/expand.scm" . 561175))
       (ret.iloc 2 . 0))
     (push)
     (extend . 1)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 563220)
     (if.null? (ret.const.unspec))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.gloc.of private-primitives-environment)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 565293))
     (push)
     (push.gloc.of annotate)
     (push.gloc.of annotate-closure)
     (call (apply.gloc.of current-after-expansion-hook "./boot/macro/expand.scm" . 565262))
     (apply))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (push.iloc.1 . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-rename-count)
       (push.iloc.1 . 1)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.1 . 2)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc.1 . 3)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 4)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 5)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 560135))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.iloc.1 . 6)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 560135))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 7)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 560135))
   (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 559124))
 (set.gloc.of macro-expand)
 (ret.const.unspec))

;
((close
   (2 0 . expand-lambda)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 7183))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/base.scm" . 7180)
   (if.true
     (call
       (touch.gloc.of collect-lambda-formals)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 8240)
       (push.iloc.0 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/base.scm" . 8216))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 9245))
     (push)
     (extend . 1)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/base.scm" . 10303))
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/base.scm" . 10285))
       (push)
       (apply.gloc.of map "./boot/macro/base.scm" . 10270))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 3 . 0)
       (push.cddr.iloc (3 . 0) "./boot/macro/base.scm" . 11309)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of extend-env "./boot/macro/base.scm" . 11321))
       (push)
       (apply.gloc.of expand-body "./boot/macro/base.scm" . 11291))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.const . lambda)
       (push.const . "empty body")
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 13332))
     (touch.gloc.of annotate)
     (push.const . lambda)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cadr.iloc (4 . 0) "./boot/macro/base.scm" . 14399)
       (push.iloc.1 . 0)
       (apply.gloc.of rename-lambda-formals "./boot/macro/base.scm" . 14376))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/base.scm" . 14356)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 14356))
   (push.const . lambda)
   (push.const . "expected formals and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 16396))
 (set.gloc.of expand-lambda)
 (ret.const.unspec))
((close
   (2 0 . expand-quote)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 20492))
   (push)
   (push.const . 2)
   (subr.gloc.of = 2 "./boot/macro/base.scm" . 20489)
   (if.true
     (touch.gloc.of annotate)
     (push.const . quote)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 21553)
       (apply.gloc.of strip-rename-suffix "./boot/macro/base.scm" . 21532))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/base.scm" . 21513)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 21513))
   (push.const . quote)
   (push.const . "expected single datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 22537))
 (set.gloc.of expand-quote)
 (ret.const.unspec))
((close
   (2 0 . expand-begin)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 26634))
     (if.false.ret)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 27669)
     (if.pair?.ret.const . #t)
     (push.const . begin)
     (push.const . "misplaced empty begin")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 28686))
   (touch.gloc.of annotate)
   (push.const . begin)
   (call
     (touch.gloc.of flatten-begin)
     (call
       (touch.gloc.of expand-each)
       (push.cdr.iloc (0 . 0) "./boot/macro/base.scm" . 29749)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/base.scm" . 29736))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of flatten-begin "./boot/macro/base.scm" . 29721))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 29701))
 (set.gloc.of expand-begin)
 (ret.const.unspec))
((close
   (2 0 . expand-if)
   (touch.gloc.of annotate)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (ret.pair? "./boot/macro/base.scm" . 33797))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 33797)
       (extend . 1)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of \x2E;list "./boot/macro/base.scm" . 33797))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cddddr 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cadddr 1 "./boot/macro/base.scm" . 33797)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 33797)
       (extend . 2)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 1)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of \x2E;list "./boot/macro/base.scm" . 33797))
     (push.const . if)
     (push.const . "expected 2 or 3 expressions")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 33797))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 32771))
 (set.gloc.of expand-if)
 (ret.const.unspec))
((close
   (2 0 . expand-set!)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 48133)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 48133))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 48133)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (extend . 2)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/base.scm" . 48133))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 3 . 1)
           (apply.gloc.of extend-env "./boot/macro/base.scm" . 48133))
         (push)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/base.scm" . 48133))
       (if.true.ret)
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.const . set!)
       (push.const . "misplaced syntactic keyword as variable")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (push.gloc.of immutable-primitives)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (call
         (touch.gloc.of renamed-id?)
         (push.iloc.0 . 0)
         (apply.gloc.of renamed-id? "./boot/macro/base.scm" . 48133))
       (if.true.ret.const . #f)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 4 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
         (apply.gloc.of denote-lambda? "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 48133))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 48133))
     (touch.gloc.of annotate)
     (push.const . set!)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/base.scm" . 48133)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 48133))
   (push.const . set!)
   (push.const . "expected variable and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
 (set.gloc.of expand-set!)
 (ret.const.unspec))
((close
   (2 0 . expand-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/base.scm" . 74757))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 74757)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 74757))
     (touch.gloc.of expand-form)
     (push.const . \x2E;BEGIN)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/base.scm" . 74757))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 74757))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
 (set.gloc.of expand-let-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/base.scm" . 87045))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 87045)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 87045))
     (touch.gloc.of expand-form)
     (push.const . \x2E;BEGIN)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/base.scm" . 87045))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 87045))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
 (set.gloc.of expand-letrec-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-define-syntax)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99338))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 100380)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 100362))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 99333)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 99333))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 99333)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (extend . 2)
     (call
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 4 . 0)
           (push.iloc 3 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-macro "./boot/macro/base.scm" . 99333))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 99333))
           (if.true
             (push.const . variable)
             (push.iloc 3 . 1)
             (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
             (push.iloc 4 . 1)
             (apply.gloc.of \x2E;set-top-level-macro! "./boot/macro/base.scm" . 99333))
           (push.const . syntax)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of \x2E;set-top-level-macro! "./boot/macro/base.scm" . 99333))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (apply.gloc.of \x2E;dynamic-wind "./boot/macro/base.scm" . 99333))
     (call
       (touch.gloc.of env-delete!)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-delete! "./boot/macro/base.scm" . 99333))
     (ret.const begin))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
   (push.const . "expected symbol and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
 (set.gloc.of expand-define-syntax)
 (ret.const.unspec))
((close
   (1 0 . immutable?)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 119821)
   (if.true.ret)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (ret.subr.gloc.of memq "./boot/macro/base.scm" . 120845))
 (set.gloc.of immutable?\x60;2)
 (close
   (2 0 . expand-define)
   (extend.enclose+
     (1 0 . let?)
     (touch.gloc.of denote-let?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-let? "./boot/macro/base.scm" . 131081))
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 133130))
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 134172)
     (push.const . "misplaced definition")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 134154))
   (call
     (touch.gloc.of desugar-define)
     (push.iloc.1 . 0)
     (apply.gloc.of desugar-define "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 135194)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 135194)
   (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (extend . 2)
   (call
     (call
       (touch.gloc.of immutable?\x60;2)
       (push.iloc.0 . 1)
       (apply.gloc.of immutable?\x60;2 "./boot/macro/base.scm" . 135194))
     (if.false.ret)
     (push.car.iloc (3 . 0) "./boot/macro/base.scm" . 135194)
     (push.const . "attempt to modify immutable binding")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 135194))
   (call
     (push.const . #f)
     (push.const . #f)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 1)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc 2 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;cdddr 1 "./boot/macro/base.scm" . 135194)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (apply.iloc+ (3 . 0) "./boot/macro/base.scm" . 135194))
     (if.true
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/base.scm" . 135194)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/base.scm" . 135194)
   (call
     (touch.gloc.of env-delete!)
     (push.iloc 4 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-delete! "./boot/macro/base.scm" . 135194))
   (touch.gloc.of annotate)
   (push.const . define)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/base.scm" . 135194)
   (push.iloc 4 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 135194))
 (set.gloc.of expand-define)
 (ret.const.unspec))

;
((close
   (2 0 . expand-let)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.pair? "./boot/macro/derived.scm" . 7173))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 7173)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/derived.scm" . 7173)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 7173)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 7173)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 3)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 1)
       (push.const . \x2E;LETREC*)
       (push.iloc.0 . 2)
       (push.const . \x2E;LAMBDA)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 7173)
       (push.iloc.0 . 2)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
       (push.cons)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 7173)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 7173)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 7173))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 7173))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 7173))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 4 . 0)
       (push.cddr.iloc (4 . 0) "./boot/macro/derived.scm" . 7173)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of cons)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
         (push)
         (push.iloc 4 . 1)
         (apply.gloc.of extend-env "./boot/macro/derived.scm" . 7173))
       (push)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 7173))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 7173)
       (push.const . "empty body")
       (push.iloc 5 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
     (call
       (push.close
         (2 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (call
           (touch.gloc.of denote-lambda?)
           (push.iloc 6 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 7173)
           (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 7173))
         (if.false.ret)
         (touch.gloc.of set-closure-comment!)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of original-id)
           (push.iloc.0 . 1)
           (apply.gloc.of original-id "./boot/macro/derived.scm" . 7173))
         (push)
         (apply.gloc.of set-closure-comment! "./boot/macro/derived.scm" . 7173))
       (push.iloc 2 . 1)
       (push.iloc 2 . 0)
       (apply.gloc.of for-each "./boot/macro/derived.scm" . 7173))
     (touch.gloc.of annotate)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.1 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/derived.scm" . 7173))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 7173)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 7173))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 7173)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 7173))
 (set.gloc.of expand-let)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec*)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.pair? "./boot/macro/derived.scm" . 44037))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 44037))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 44037))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 44037))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 44037))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 44037)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 44037))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 44037)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 44037))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 44037)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
     (call
       (call
         (subr.gloc.of warning-level 0 "./boot/macro/derived.scm" . 44037)
         (if.false.ret)
         (touch.gloc.of check-rec*-contract-violation)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/derived.scm" . 44037))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.close
           (1 0)
           (touch.gloc.of display-warning)
           (push.const
             .
             "warning: binding construct may attempt to reference uninitialized variable ~u")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 44037)
           (push.iloc 8 . 0)
           (call
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (call
                 (touch.gloc.of check-rec-contract-violation)
                 (push.iloc.1 . 0)
                 (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 44037)
                 (push.iloc.0 . 0)
                 (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 44037))
               (if.false.ret)
               (ret.iloc 0 . 0))
             (push.iloc 2 . 0)
             (apply.gloc.of any1 "./boot/macro/derived.scm" . 44037))
           (push)
           (apply.gloc.of display-warning "./boot/macro/derived.scm" . 44037))
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/derived.scm" . 44037))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 44037))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 44037))
     (push)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 44037)
     (push.iloc 6 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 44037))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 44037)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 44037))
 (set.gloc.of expand-letrec*)
 (ret.const.unspec))
((close
   (2 0)
   (push.const . set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 75781))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close (1 0) (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 75781))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . \x2E;&UNDEF)
   (ret.subr.gloc.of list "./boot/macro/derived.scm" . 75781))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . expand-letrec)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 75781)
     (ret.pair? "./boot/macro/derived.scm" . 75781))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 75781))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.const)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 75781)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75781))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75781))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 75781)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;cdaadr 1 "./boot/macro/derived.scm" . 75781)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cdaadr 1 "./boot/macro/derived.scm" . 75781)
     (subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 75781)
     (if.not.null?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;cdadr 1 "./boot/macro/derived.scm" . 75781)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 75781))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LETREC*)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caaadr 1 "./boot/macro/derived.scm" . 75781)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cdaadr 1 "./boot/macro/derived.scm" . 75781)
       (push.subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 75781)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 75781)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 75781)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 75781)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75781))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75781))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 75781))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 75781))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 75781))
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 75781))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of extend-env)
       (call
         (push.gloc.of cons)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of extend-env "./boot/macro/derived.scm" . 75781))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 75781)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 75781))
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 5 . 0)
       (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 75781)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 75781))
     (push)
     (extend . 2)
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 75781)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 75781))
     (call
       (call
         (subr.gloc.of warning-level 0 "./boot/macro/derived.scm" . 75781)
         (if.false.ret)
         (touch.gloc.of check-rec-contract-violation)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 75781))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.close
           (1 0)
           (touch.gloc.of display-warning)
           (push.const
             .
             "warning: binding construct may attempt to reference uninitialized variable ~u")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 75781)
           (push.iloc 8 . 0)
           (call
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (call
                 (touch.gloc.of check-rec-contract-violation)
                 (push.iloc.1 . 0)
                 (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 75781)
                 (push.iloc.0 . 0)
                 (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 75781))
               (if.false.ret)
               (ret.iloc 0 . 0))
             (push.iloc 2 . 0)
             (apply.gloc.of any1 "./boot/macro/derived.scm" . 75781))
           (push)
           (apply.gloc.of display-warning "./boot/macro/derived.scm" . 75781))
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/derived.scm" . 75781))
       (ret.const.unspec))
     (call
       (touch.gloc.of every1)
       (push.close
         (1 0)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 75781)
         (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 75781))
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/derived.scm" . 75781))
     (if.true
       (touch.gloc.of annotate)
       (push.const . letrec*)
       (call
         (touch.gloc.of rewrite-letrec*-bindings)
         (call
           (push.gloc.of list)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 75781))
       (push)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 75781)
       (push.iloc 6 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 75781))
     (call
       (push.gloc.of \x2E;fn3.1\x60;3)
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (extend . 1)
     (push.const . let)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc 3 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (call
       (push.gloc.of \x2E;fn1.1\x60;1)
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 75781))
     (push)
     (push.iloc.1 . 1)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/derived.scm" . 75781)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 75781)
     (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 75781))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 75781)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 75781))
 (set.gloc.of expand-letrec)
 (ret.const.unspec))
((close
   (2 0 . expand-let*)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 111628))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 111625)
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 112665)
     (extend . 1)
     (call
       (touch.gloc.of check-let*-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let*-bindings "./boot/macro/derived.scm" . 113675))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . \x2E;LET)
             (push.const)
             (push.cddr.iloc (3 . 0) "./boot/macro/derived.scm" . 118815)
             (ret.subr.gloc.of \x2E;cons* "./boot/macro/derived.scm" . 117775))
           (push.const . \x2E;LET)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 119836)
           (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 117775)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 119854)
             (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 119848))
           (push)
           (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 117775))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 116749))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 112649))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 112649))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 122907)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 122889))
 (set.gloc.of expand-let*)
 (ret.const.unspec))
((close
   (2 0 . expand-let-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 126981))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 126981)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "expected bindings and body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of append)
           (call
             (push.close
               (1 0)
               (call
                 (iloc.0 . 0)
                 (if.not.pair?.ret.const . #f)
                 (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (if.not.pair?.ret.const . #f)
                 (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (ret.null? "./boot/macro/derived.scm" . 126981))
               (if.true
                 (touch.gloc.of collect-lambda-formals)
                 (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (push.iloc 2 . 0)
                 (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 126981))
               (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 126981)
               (push.const . "expected each binding consist of formals and expression")
               (push.iloc 2 . 0)
               (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
             (push.iloc.0 . 1)
             (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
           (push)
           (apply.gloc.of apply "./boot/macro/derived.scm" . 126981))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/derived.scm" . 126981))
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "duplicate formals")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (touch.gloc.of annotate)
     (call
       (extend.enclose
         (2 0 . loop)
         (iloc.0 . 0)
         (if.null?
           (touch.gloc.of expand-form)
           (push.const . \x2E;LET)
           (push.const)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 126981)
           (push.iloc.0 . 1)
           (apply.gloc.of expand-form "./boot/macro/derived.scm" . 126981))
         (call
           (car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 126981)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (subr.gloc.of \x2E;cddr 1 "./boot/macro/derived.scm" . 126981)
           (ret.null? "./boot/macro/derived.scm" . 126981))
         (if.true
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (push.subr.gloc.of \x2E;cadr 1 "./boot/macro/derived.scm" . 126981)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (push.subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 126981)
           (extend . 2)
           (call
             (touch.gloc.of collect-lambda-formals)
             (push.iloc.0 . 1)
             (push.iloc 4 . 0)
             (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of fresh-rename-count)
             (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (call
             (push.gloc.of cons)
             (push.iloc.1 . 0)
             (call
               (push.close
                 (1 0)
                 (touch.gloc.of rename-id)
                 (push.iloc.0 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of rename-id "./boot/macro/derived.scm" . 126981))
               (push.iloc.1 . 0)
               (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
             (push)
             (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (push.const . \x2E;call-with-values)
           (push.const . lambda)
           (push.const)
           (call
             (touch.gloc.of expand-form)
             (push.iloc 3 . 0)
             (push.iloc 7 . 1)
             (apply.gloc.of expand-form "./boot/macro/derived.scm" . 126981))
           (push)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 126981)
           (push.const . lambda)
           (call
             (touch.gloc.of rename-lambda-formals)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of rename-lambda-formals "./boot/macro/derived.scm" . 126981))
           (push)
           (call
             (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 126981)
             (call
               (touch.gloc.of extend-env)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of extend-env "./boot/macro/derived.scm" . 126981))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/derived.scm" . 126981))
           (push)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 126981)
           (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 126981))
         (push.const . "internal error: let-values: ~m")
         (push.iloc 3 . 0)
         (apply.gloc.of scheme-error "./boot/macro/derived.scm" . 126981))
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 126981))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 126981))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
 (set.gloc.of expand-let-values)
 (ret.const.unspec))
((close
   (2 0 . expand-do)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 168965)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/derived.scm" . 168965)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 168965)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 168965))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 168965)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 168965)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 168965)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 168965)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
       (push.const . "malformed (variable init update)")
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 168965))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
           (ret.pair? "./boot/macro/derived.scm" . 168965))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
           (ret.null? "./boot/macro/derived.scm" . 168965))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of \x2E;car "./boot/macro/derived.scm" . 168965))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 168965)
           (ret.null? "./boot/macro/derived.scm" . 168965))
         (if.true
           (push.iloc.1 . 0)
           (ret.subr.gloc.of \x2E;caddr "./boot/macro/derived.scm" . 168965))
         (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 168965)
         (push.const . "malformed (variable init update)")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
       (push.iloc.0 . 3)
       (apply.gloc.of map "./boot/macro/derived.scm" . 168965))
     (push)
     (extend . 2)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 0)
       (call
         (push.close
           (1 0)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 168965))
           (if.true
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (ret.subr.gloc.of list "./boot/macro/derived.scm" . 168965))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 168965)
           (push.const . "malformed (variable init update)")
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
         (push.iloc.1 . 3)
         (apply.gloc.of map "./boot/macro/derived.scm" . 168965))
       (push)
       (push.const . \x2E;IF)
       (push.iloc.1 . 2)
       (call
         (iloc.1 . 1)
         (if.null? (ret.const \x2E;UNSPECIFIED))
         (push.const . \x2E;BEGIN)
         (iloc.1 . 1)
         (ret.cons "./boot/macro/derived.scm" . 168965))
       (push)
       (push.const . \x2E;BEGIN)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 168965)
       (subr.gloc.of \x2E;append 2 "./boot/macro/derived.scm" . 168965)
       (push.cons)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 168965)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 168965)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 168965))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 168965))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
   (push.const . "expected (variable init update), test, and command")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
 (set.gloc.of expand-do)
 (ret.const.unspec))
((close
   (2 0 . expand-let*-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 201733))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 201733)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 201733)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 201733)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . \x2E;LET)
             (push.const)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;cons* "./boot/macro/derived.scm" . 201733))
           (call
             (car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 201733)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (subr.gloc.of \x2E;cddr 1 "./boot/macro/derived.scm" . 201733)
             (ret.null? "./boot/macro/derived.scm" . 201733))
           (if.true
             (push.const . \x2E;CALL-WITH-VALUES)
             (push.const . \x2E;LAMBDA)
             (push.const)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of \x2E;cadr 1 "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 201733)
             (push.const . \x2E;LAMBDA)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 201733)
             (call
               (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
               (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 201733))
             (push)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 201733)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 201733))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 201733)
           (push.const . "expected each binding consist of formals and expression")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
         (push.iloc.1 . 1)
         (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 201733))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 201733))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 201733))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
 (set.gloc.of expand-let*-values)
 (ret.const.unspec))
((close
   (2 0 . expand-cond)
   (extend.unbound . 3)
   (push.close+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 230432))
   (push.close+
     (1 0 . =>?)
     (touch.gloc.of denote-=>?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-=>? "./boot/macro/derived.scm" . 231454))
   (push.close+
     (1 0 . lambda?)
     (touch.gloc.of denote-lambda?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 232482))
   (enclose . 3)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.1 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 234511))
   (push)
   (push.const . 1)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 234508)
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?.ret.const \x2E;UNSPECIFIED)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 240674)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.pair? "./boot/macro/derived.scm" . 241686))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (call
               (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 241686))
             (if.false.ret)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.pair? "./boot/macro/derived.scm" . 241686))
           (if.true
             (cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
             (if.null?
               (push.const . \x2E;BEGIN)
               (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (ret.cons "./boot/macro/derived.scm" . 241686))
             (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 241686)
             (push.const . "misplaced else")
             (push.iloc 5 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of \x2E;list? 1 "./boot/macro/derived.scm" . 241686)
             (if.false.ret)
             (call
               (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 241686))
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 241686)
             (apply.iloc+ (4 . 2) "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;caar 1 "./boot/macro/derived.scm" . 241686)
             (extend . 1)
             (push.const . \x2E;LET)
             (push.iloc.0 . 0)
             (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;IF)
             (push.iloc.0 . 0)
             (push.const . \x2E;LET)
             (push.const)
             (push.iloc 2 . 0)
             (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (4 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (apply.iloc+ (4 . 1) "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 241686)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (extend . 2)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 241686))
             (push)
             (extend . 1)
             (push.const . \x2E;LET)
             (push.iloc.0 . 0)
             (push.iloc.1 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;IF)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.null? "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.const . \x2E;OR)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.const . \x2E;IF)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;BEGIN)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (push.cons)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 241686)
           (push.const . "malformed cond clause")
           (push.iloc 5 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 241686))
         (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 237598)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 237582))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 230405))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 230405))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 269342)
   (push.const . "expected cond clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 269324))
 (set.gloc.of expand-cond)
 (ret.const.unspec))
((close
   (2 0 . maplist)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call (push.iloc.0 . 1) (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 279579))
   (push)
   (call
     (touch.gloc.of maplist\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/macro/derived.scm" . 279604)
     (apply.gloc.of maplist\x60;2 "./boot/macro/derived.scm" . 279590))
   (ret.cons "./boot/macro/derived.scm" . 279573))
 (set.gloc.of maplist\x60;2)
 (close
   (2 0 . expand-case)
   (extend.enclose+
     (1 0 . else?)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 274464))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
     (ret.pair? "./boot/macro/derived.scm" . 300088))
   (if.true
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
     (extend . 2)
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 300088))
     (push)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 300088)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 300088)
       (push.const . \x2E;COND)
       (call
         (touch.gloc.of maplist\x60;2)
         (push.close
           (1 0)
           (push.gloc.of pair?)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (car.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
             (ret.pair? "./boot/macro/derived.scm" . 300088))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 300088)
             (ret.subr.gloc.of \x2E;list? "./boot/macro/derived.scm" . 300088))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (call
               (push.iloc 3 . 0)
               (push.subr.gloc.of \x2E;caar 1 "./boot/macro/derived.scm" . 300088)
               (apply.iloc+ (6 . 0) "./boot/macro/derived.scm" . 300088))
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 300088))
           (if.true
             (cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 300088)
             (if.null?
               (push.const . \x2E;ELSE)
               (push.iloc 3 . 0)
               (subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
               (ret.cons "./boot/macro/derived.scm" . 300088))
             (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 300088)
             (push.const . "misplaced else")
             (push.iloc 7 . 0)
             (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 300088)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 300088))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (subr.gloc.of \x2E;caar 1 "./boot/macro/derived.scm" . 300088)
             (if.not.pair?.ret.const . #f)
             (push.iloc 3 . 0)
             (subr.gloc.of \x2E;cdaar 1 "./boot/macro/derived.scm" . 300088)
             (if.not.null?.ret.const . #f)
             (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 300088)
             (subr.gloc.of \x2E;list? 1 "./boot/macro/derived.scm" . 300088)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 300088))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;caaar 1 "./boot/macro/derived.scm" . 300088)
             (extend . 2)
             (call
               (iloc.0 . 1)
               (if.symbol?.ret.const . #t)
               (push.iloc.0 . 1)
               (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 300088)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 300088)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 300088)
               (if.true.ret)
               (iloc.0 . 1)
               (ret.null? "./boot/macro/derived.scm" . 300088))
             (if.true
               (push.const . \x2E;EQ?)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 300088)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 300088)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 300088))
             (push.const . \x2E;EQV?)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 300088)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 300088)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 300088))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;caar 1 "./boot/macro/derived.scm" . 300088)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 300088)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 300088))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/derived.scm" . 300088)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;caar 1 "./boot/macro/derived.scm" . 300088)
             (extend . 2)
             (iloc.0 . 1)
             (if.null?.ret.const #f)
             (call
               (touch.gloc.of every1)
               (push.close
                 (1 0)
                 (iloc.0 . 0)
                 (if.symbol?.ret.const . #t)
                 (push.iloc.0 . 0)
                 (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 300088)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 300088)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 300088)
                 (if.true.ret)
                 (iloc.1 . 1)
                 (ret.null? "./boot/macro/derived.scm" . 300088))
               (push.iloc.0 . 1)
               (apply.gloc.of every1 "./boot/macro/derived.scm" . 300088))
             (if.true
               (push.const . \x2E;MEMQ)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 300088)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 300088)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 300088))
             (push.const . \x2E;MEMV)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 300088)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 300088)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 300088))
           (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 300088)
           (push.const . "malformed case clause")
           (push.iloc 7 . 0)
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 300088)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 300088))
         (push.iloc.1 . 0)
         (apply.gloc.of maplist\x60;2 "./boot/macro/derived.scm" . 300088))
       (push.cons)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 300088)
       (push.iloc 3 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 300088))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 300088))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 300088)
   (push.const . "expected case clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 300088))
 (set.gloc.of expand-case)
 (ret.const.unspec))
((close
   (2 0 . expand-and)
   (touch.gloc.of annotate)
   (push.const . and)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 314404)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 314391))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 314373))
 (set.gloc.of expand-and)
 (ret.const.unspec))
((close
   (2 0 . expand-or)
   (touch.gloc.of annotate)
   (push.const . or)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 318499)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 318486))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 318469))
 (set.gloc.of expand-or)
 (ret.const.unspec))
((close
   (1 0 . desugar-define)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 339981)
     (ret.pair? "./boot/macro/derived.scm" . 339981))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 339981)
     (ret.pair? "./boot/macro/derived.scm" . 339981))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 339981)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 339981))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 339981))
   (if.true
     (touch.gloc.of annotate)
     (push.const . define)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (push.const (\x2E;UNSPECIFIED))
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 339981)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 339981))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (if.not.null?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 339981)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 339981))
   (if.true
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;cdadr 1 "./boot/macro/derived.scm" . 339981)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 339981)
     (extend . 2)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 339981))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 339981))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 1)
     (push.const . lambda)
     (push.iloc.0 . 0)
     (push.const (\x2E;UNSPECIFIED))
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 339981)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 339981)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 339981))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 339981)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (ret.pair? "./boot/macro/derived.scm" . 339981))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;cdadr 1 "./boot/macro/derived.scm" . 339981)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 339981)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 339981))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 339981))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 339981)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 339981)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 339981))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 339981)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 339981)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 339981))
   (push.iloc 2 . 0)
   (push.subr.gloc.of length 1 "./boot/macro/derived.scm" . 339981)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/derived.scm" . 339981)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 339981)
     (push.const . "expected 1 or 2, but no clause given")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 339981))
   (push.iloc.0 . 0)
   (push.const 1 2)
   (subr.gloc.of \x2E;memq 2 "./boot/macro/derived.scm" . 339981)
   (if.true
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 339981)
     (push.const . "expected symbol for first clause")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 339981))
   (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 339981)
   (push.const . "expected 1 or 2, but ~a clauses given")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 339981)
   (push.iloc 3 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 339981))
 (set.gloc.of desugar-define)
 (ret.const.unspec))
((close
   (1 0 . desugar-define-macro)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 346117)
     (ret.pair? "./boot/macro/derived.scm" . 346117))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 346117)
     (ret.pair? "./boot/macro/derived.scm" . 346117))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 346117)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 346117))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 346117)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
     (ret.pair? "./boot/macro/derived.scm" . 346117))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;cdadr 1 "./boot/macro/derived.scm" . 346117)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 346117)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 346117))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 346117))
     (touch.gloc.of annotate)
     (push.const . define-macro)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 346117)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 346117)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 346117))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 346117)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 346117))
   (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 346117)
   (push.const . "expected symbol and expression")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 346117))
 (set.gloc.of desugar-define-macro)
 (ret.const.unspec))
((close
   (1 0 . rewrite-define-macro)
   (call
     (touch.gloc.of desugar-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of desugar-define-macro "./boot/macro/derived.scm" . 359450))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 359450)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 359450)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 359450)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 359450)
   (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 359450)
   (extend . 2)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 359450))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (push.const . \x2E;DEFINE-SYNTAX)
   (push.iloc.1 . 1)
   (push.const . \x2E;LAMBDA)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 359450)
   (push.const . \x2E;APPLY)
   (push.iloc.1 . 0)
   (push.const . \x2E;CDR)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 359450)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 359450)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 359450)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 359450)
   (push.iloc 3 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 359450))
 (set.gloc.of rewrite-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-define-macro)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/derived.scm" . 366602))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 367644)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 367626))
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of rewrite-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of rewrite-define-macro "./boot/macro/derived.scm" . 368658))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 368645))
 (set.gloc.of expand-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-identifier-syntax)
   (extend.enclose+
     (1 0 . set!?)
     (touch.gloc.of denote-set!?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-set!? "./boot/macro/derived.scm" . 373792))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 373765)
     (ret.pair? "./boot/macro/derived.scm" . 373765))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 373765)
     (ret.null? "./boot/macro/derived.scm" . 373765))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LAMBDA)
       (push.const x)
       (push.const . \x2E;SYNTAX-CASE)
       (push.const . x)
       (push.const)
       (push.const . id)
       (push.const \x2E;IDENTIFIER? (\x2E;SYNTAX id))
       (push.const . \x2E;SYNTAX)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 373765)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 373765)
       (push.const _ x ...)
       (push.const . \x2E;SYNTAX)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 373765)
       (const x ...)
       (push.cons)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
       (push.subr.gloc.of \x2E;list 5 "./boot/macro/derived.scm" . 373765)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 373765)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 373765))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 373765))
   (iloc.0 . 0)
   (if.false.ret)
   (cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;cdadr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
   (subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
   (subr.gloc.of \x2E;cddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;cddadr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
   (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 373765)
   (subr.gloc.of \x2E;cdr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;cdddr 1 "./boot/macro/derived.scm" . 373765)
   (if.not.null?.ret.const . #f)
   (call
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 373765)
     (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 373765))
   (if.false.ret)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;cadadr 1 "./boot/macro/derived.scm" . 373765)
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;caadr 1 "./boot/macro/derived.scm" . 373765)
   (extend . 2)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (push.const . \x2E;MAKE-VARIABLE-TRANSFORMER)
     (push.const . \x2E;LAMBDA)
     (push.const x)
     (push.const . \x2E;SYNTAX-CASE)
     (push.const . x)
     (push.const set!)
     (push.const . set!)
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;cadr 1 "./boot/macro/derived.scm" . 373765)
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 373765)
     (push.const . \x2E;SYNTAX)
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;car 1 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.iloc.0 . 1)
     (const x ...)
     (push.cons)
     (push.const . \x2E;SYNTAX)
     (push.iloc.0 . 0)
     (const x ...)
     (push.cons)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.iloc.0 . 1)
     (push.const \x2E;IDENTIFIER? (\x2E;SYNTAX id))
     (push.const . \x2E;SYNTAX)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 6 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 373765)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 373765)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 373765))
   (push)
   (push.iloc 3 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 373765))
 (set.gloc.of expand-identifier-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-assert)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 400389)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 400389)
     (ret.null? "./boot/macro/derived.scm" . 400389))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 400389)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;OR)
       (push.iloc.0 . 0)
       (push.const . assertion-violation)
       (push.const . quote)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/derived.scm" . 400389))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 400389)
       (push.const . "assertion failed in expression ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 400389)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 400389)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 400389)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 400389))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 400389))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 400389)
   (push.const . "expected single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 400389))
 (set.gloc.of expand-assert)
 (ret.const.unspec))

;
((close
   (2 0 . expand-quasiquote)
   (extend.unbound . 12)
   (push.close+
     (1 0 . unquote?)
     (touch.gloc.of denote-unquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 8228))
   (push.close+
     (1 0 . quasiquote?)
     (touch.gloc.of denote-quasiquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 9255))
   (push.close+
     (1 0 . unquote-splicing?)
     (touch.gloc.of denote-unquote-splicing?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 10285))
   (push.close+
     (1 0 . quoted?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 15381)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/quasi.scm" . 16405)
     (if.not.null?.ret.const . #f)
     (touch.gloc.of denote-quote?)
     (push.iloc 2 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 17441)
     (apply.gloc.of denote-quote? "./boot/macro/quasi.scm" . 17422))
   (push.close+
     (1 0 . constant?)
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/quasi.scm" . 21517)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/quasi.scm" . 22541)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/quasi.scm" . 23565)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/quasi.scm" . 24589)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of bytevector? 1 "./boot/macro/quasi.scm" . 25613)
     (if.true.ret)
     (push.iloc.0 . 0)
     (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 26637))
   (push.close+
     (1 0 . constant-value)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 30736))
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 30748))
     (ret.iloc 0 . 0))
   (push.close+
     (1 0 . null-constant?)
     (call (push.iloc.0 . 0) (apply.iloc+ (1 . 3) "./boot/macro/quasi.scm" . 35854))
     (if.false.ret)
     (cadr.iloc (0 . 0) "./boot/macro/quasi.scm" . 36885)
     (ret.null? "./boot/macro/quasi.scm" . 36878))
   (push.close+
     (2 0 . emit-append)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 42000))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 43031)
       (push.const . 1)
       (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 43028)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/macro/quasi.scm" . 43048))
       (push.const . \x2E;APPEND)
       (iloc.0 . 0)
       (ret.cons "./boot/macro/quasi.scm" . 43024))
     (push.const . \x2E;APPEND)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/quasi.scm" . 44047)
     (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 44047)
     (ret.cons "./boot/macro/quasi.scm" . 44047))
   (push.close+
     (2 0 . emit-cons*)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 49168)
     (push.const . 1)
     (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 49165)
     (if.true
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 50200)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 9) "./boot/macro/quasi.scm" . 50189))
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 52244))
     (if.true (push.const . \x2E;LIST) (iloc.0 . 0) (ret.cons "./boot/macro/quasi.scm" . 52243))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 54315)
       (const . \x2E;LIST)
       (ret.eq? "./boot/macro/quasi.scm" . 54310))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 55333)
       (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 54291)
       (ret.cons "./boot/macro/quasi.scm" . 54291))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56367)
       (const . \x2E;CONS)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56391)
       (const . \x2E;CONS*)
       (ret.eq? "./boot/macro/quasi.scm" . 56386))
     (if.true
       (push.const . \x2E;CONS*)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 57382)
       (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 56339)
       (ret.cons "./boot/macro/quasi.scm" . 56339))
     (push.const . \x2E;CONS*)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/quasi.scm" . 58387)
     (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 58387)
     (ret.cons "./boot/macro/quasi.scm" . 58387))
   (push.close+
     (2 0 . emit-cons)
     (call
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63506))
       (if.false.ret)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 4) "./boot/macro/quasi.scm" . 63523))
     (if.true
       (push.const . \x2E;QUOTE)
       (call (push.iloc.0 . 0) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64545))
       (push)
       (call (push.iloc.0 . 1) (apply.iloc+ (1 . 5) "./boot/macro/quasi.scm" . 64567))
       (push.cons)
       (ret.subr.gloc.of list "./boot/macro/quasi.scm" . 64525))
     (call (push.iloc.0 . 1) (apply.iloc+ (1 . 6) "./boot/macro/quasi.scm" . 65556))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 65555))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 67627)
       (const . \x2E;LIST)
       (ret.eq? "./boot/macro/quasi.scm" . 67622))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 68644)
       (ret.subr.gloc.of \x2E;cons* "./boot/macro/quasi.scm" . 67603))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69679)
       (const . \x2E;CONS)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69703)
       (const . \x2E;CONS*)
       (ret.eq? "./boot/macro/quasi.scm" . 69698))
     (if.true
       (push.const . \x2E;CONS*)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 70693)
       (ret.subr.gloc.of \x2E;cons* "./boot/macro/quasi.scm" . 69651))
     (push.const . \x2E;CONS)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 71699))
   (push.close
     (2 0 . expand-vector)
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/quasi.scm" . 76828)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 11) "./boot/macro/quasi.scm" . 76820))
     (push)
     (extend . 1)
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 6) "./boot/macro/quasi.scm" . 77842))
     (if.true.ret.const \x2E;QUOTE #())
     (call (push.iloc.0 . 0) (apply.iloc+ (2 . 4) "./boot/macro/quasi.scm" . 79890))
     (if.true
       (push.const . \x2E;QUOTE)
       (call (push.iloc.0 . 0) (apply.iloc+ (2 . 5) "./boot/macro/quasi.scm" . 80938))
       (push)
       (push.subr.gloc.of list->vector 1 "./boot/macro/quasi.scm" . 80924)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 79889))
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 81943)
     (const . \x2E;LIST)
     (if.eq?
       (push.const . \x2E;VECTOR)
       (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 82974)
       (ret.cons "./boot/macro/quasi.scm" . 81937))
     (push.const . \x2E;LIST->VECTOR)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 83985))
   (push.close
     (2 0 . expand)
     (iloc.0 . 0)
     (if.pair?
       (=n.iloc (0 . 1) 0 "./boot/macro/quasi.scm" . 90132)
       (if.true
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/quasi.scm" . 90128)
           (ret.subr.gloc.of \x2E;list? "./boot/macro/quasi.scm" . 90128))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;caar 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 8) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;caar 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 7) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (subr.gloc.of \x2E;list? 1 "./boot/macro/quasi.scm" . 90128)
           (if.false.ret)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (call
             (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.null?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of \x2E;cadr "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "nested quasiquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc+ (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote-splicing appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 90128))
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 108575)
       (extend . 1)
       (call
         (call
           (touch.gloc.of denote-unquote?)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 109601))
         (if.true.ret)
         (touch.gloc.of denote-unquote-splicing?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 109627))
       (if.true
         (push.const . \x2E;QUOTE)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/quasi.scm" . 110621)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 111664)
           (push.n+.iloc (1 . 1) -1 "./boot/macro/quasi.scm" . 111675)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 111656))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 110621))
       (call
         (touch.gloc.of denote-quasiquote?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 112669))
       (if.true
         (push.const . \x2E;QUOTE)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/quasi.scm" . 113693)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 114736)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/quasi.scm" . 114747)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 114728))
         (push)
         (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 113693))
       (call
         (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 116784)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 116776))
       (push)
       (call
         (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 117808)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 117800))
       (push)
       (apply.iloc+ (2 . 9) "./boot/macro/quasi.scm" . 116765))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/quasi.scm" . 118800)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 10) "./boot/macro/quasi.scm" . 119824))
     (iloc.0 . 0)
     (if.symbol?
       (push.const . \x2E;QUOTE)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 120847))
     (iloc.0 . 0)
     (if.null?.ret.const \x2E;QUOTE ())
     (ret.iloc 0 . 0))
   (enclose . 12)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (call
       (push.cadr.iloc (1 . 0) "./boot/macro/quasi.scm" . 127012)
       (push.const . 0)
       (apply.iloc (0 . 11) "./boot/macro/quasi.scm" . 127004))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/quasi.scm" . 126994))
   (push)
   (push.iloc.1 . 1)
   (apply.gloc.of expand-form "./boot/macro/quasi.scm" . 126981))
 (set.gloc.of expand-quasiquote)
 (ret.const.unspec))

;
((close
   (1 0 . ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 8209)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 9231)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 9226))
 (set.gloc.of ellipsis-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-splicing-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 14353)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 15375)
   (const . ...)
   (if.not.eq?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 16401)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/synpat.scm" . 17423)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 17418))
 (set.gloc.of ellipsis-splicing-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-quote?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 22545)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 23567)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 23562))
 (set.gloc.of ellipsis-quote?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 29716)
     (call
       (touch.gloc.of loop\x60;5)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 30746)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 30740))
     (push)
     (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 29710))
   (push.iloc.0 . 0)
   (const . ...)
   (if.eq? (ret.iloc 0 . 1))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 33810)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/synpat.scm" . 33829))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 34830)
   (if.true
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 35860)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 35854))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . collect-unique-ids)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 27653))
 (set.gloc.of collect-unique-ids)
 (ret.const.unspec))
((close
   (4 0 . collect-vars-ranks)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 3))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 43024)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of acons)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of acons "./boot/macro/synpat.scm" . 45072))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 0)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 46092))
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 47136)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 48173)
       (if.symbol?
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 49195)
         (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 49205)
         (push.iloc.0 . 3)
         (apply.gloc.of acons "./boot/macro/synpat.scm" . 49188))
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 50232)
       (push.iloc.0 . 1)
       (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 50248)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 50212))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 47116))
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of collect-vars-ranks)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 52256)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 53300)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 53280))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 52236))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 54284)
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 55328)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 55308))
   (ret.iloc 0 . 3))
 (set.gloc.of collect-vars-ranks)
 (ret.const.unspec))
((close
   (2 0 . check-duplicate-variable)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 65560)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 66590)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 66584))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 65554))
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq? (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (const . _)
     (if.eq? (ret.iloc 0 . 1))
     (iloc.0 . 0)
     (if.symbol?
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 70678)
       (if.true (ret.iloc 0 . 1))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 72730)
       (if.true
         (push.const . "syntax pattern")
         (push.const . "duplicate pattern variables")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 73754))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synpat.scm" . 74778))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 75794)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 76824)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 76818))
     (ret.iloc 0 . 1))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 63497))
 (set.gloc.of check-duplicate-variable\x60;2)
 (close
   (2 0 . check-misplaced-ellipsis)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq?
       (push.const . "syntax pattern")
       (push.const . "improper use of ellipsis")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 83986))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 85010))
     (if.true
       (call
         (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 86048)
         (if.not.symbol?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 87069)
         (push.iloc 2 . 1)
         (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 87063)
         (if.false.ret)
         (push.const . "syntax pattern")
         (push.const . "ellipsis following literal")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 88087))
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 91170)
         (const . ...)
         (if.eq?
           (push.const . "syntax pattern")
           (push.const . "ambiguous use of ellipsis")
           (push.iloc 4 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 92189))
         (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 93219)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 93213))
       (push.cddr.iloc (1 . 0) "./boot/macro/synpat.scm" . 89122)
       (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 89106))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 95260)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95254))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 95277)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95271))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 96274)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 97304)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 97298))
     (ret.const . #f))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 81929))
 (set.gloc.of check-misplaced-ellipsis\x60;2)
 (close
   (2 0 . check-pattern)
   (call
     (touch.gloc.of check-misplaced-ellipsis\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of check-misplaced-ellipsis\x60;2 "./boot/macro/synpat.scm" . 100357))
   (touch.gloc.of check-duplicate-variable\x60;2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of check-duplicate-variable\x60;2 "./boot/macro/synpat.scm" . 101381))
 (set.gloc.of check-pattern)
 (ret.const.unspec))
((close
   (3 0 . match-ellipsis?)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 107550)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 107561)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 107534))
   (if.false.ret)
   (touch.gloc.of match-ellipsis?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 108575)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 108558))
 (set.gloc.of match-ellipsis?)
 (ret.const.unspec))
((close
   (4 0 . match-ellipsis-n?)
   (=n.iloc (0 . 2) 0 "./boot/macro/synpat.scm" . 112649)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 114718)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 114729)
     (push.iloc.0 . 3)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 114702))
   (if.false.ret)
   (touch.gloc.of match-ellipsis-n?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 115745)
   (push.iloc.0 . 1)
   (push.n+.iloc (0 . 2) -1 "./boot/macro/synpat.scm" . 115760)
   (push.iloc.0 . 3)
   (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 115726))
 (set.gloc.of match-ellipsis-n?)
 (ret.const.unspec))
((close
   (3 0 . match-pattern?)
   (push.iloc.0 . 1)
   (const . _)
   (if.eq?.ret.const . #t)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 121875)
     (if.true
       (call
         (iloc.0 . 0)
         (if.symbol?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of identifier? "./boot/macro/synpat.scm" . 123932))
       (if.false.ret)
       (touch.gloc.of free-id=?)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of free-id=? "./boot/macro/synpat.scm" . 124952))
     (ret.const . #t))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 126988))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 128028)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 128040))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 129053)
       (if.symbol?.ret.const . #t)
       (touch.gloc.of match-ellipsis?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 130068))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131100))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 131130)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131118))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 131097)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 132118)
     (if.true
       (touch.gloc.of match-pattern?)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 133163)
       (push.iloc.1 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 133142))
     (>n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 134171)
     (if.false.ret)
     (call
       (touch.gloc.of match-ellipsis-n?)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 135195))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 136235)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 136254)
     (push.iloc.1 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 136219))
   (iloc.0 . 1)
   (if.pair?
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of match-pattern?)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 139297)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 139308)
       (push.iloc.0 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 139281))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 140321)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 140332)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 140305))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 141324)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 142353)
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143393)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143413)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 143377))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of equal? "./boot/macro/synpat.scm" . 144401))
 (set.gloc.of match-pattern?)
 (ret.const.unspec))
((close
   (2 0 . union-vars)
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (touch.gloc.of union-vars)
   (call
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 150560)
     (push.iloc.0 . 1)
     (push.subr.gloc.of cdar 1 "./boot/macro/synpat.scm" . 150582)
     (push.subr.gloc.of reverse 1 "./boot/macro/synpat.scm" . 150573)
     (push.iloc.0 . 0)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 150549))
   (push)
   (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 151573)
   (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 150537))
 (set.gloc.of union-vars)
 (ret.const.unspec))
((close
   (3 0 . bind-var!)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 2))
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (push.subr.gloc.of assq 2 "./boot/macro/synpat.scm" . 157720)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 159795)
     (push.cons)
     (subr.gloc.of set-cdr! 2 "./boot/macro/synpat.scm" . 159769)
     (ret.iloc 1 . 2))
   (touch.gloc.of acons)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of list 1 "./boot/macro/synpat.scm" . 160797)
   (push.iloc.1 . 2)
   (apply.gloc.of acons "./boot/macro/synpat.scm" . 160786))
 (set.gloc.of bind-var!)
 (ret.const.unspec))
((close
   (3 0 . bind-null-ellipsis)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 167953)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 168987)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 168981)
       (if.true (ret.iloc 0 . 1))
       (touch.gloc.of bind-var!)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 171040)
       (push.const)
       (push.iloc.0 . 1)
       (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 171029))
     (push)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 167947))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.car.iloc (1 . 0) "./boot/macro/synpat.scm" . 164905)
     (apply.gloc.of collect-unique-ids "./boot/macro/synpat.scm" . 164885))
   (push)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 164869))
 (set.gloc.of bind-null-ellipsis)
 (ret.const.unspec))
((close
   (5 0 . bind-ellipsis)
   (iloc.0 . 0)
   (if.null?
     (iloc.0 . 4)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 177165))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 178189))
   (touch.gloc.of bind-ellipsis)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 179224)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 180262)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 180273)
     (push.iloc.0 . 2)
     (push.iloc.0 . 4)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 180248))
   (push)
   (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 179209))
 (set.gloc.of bind-ellipsis)
 (ret.const.unspec))
((close
   (6 0 . bind-ellipsis-n)
   (=n.iloc (0 . 3) 0 "./boot/macro/synpat.scm" . 184329)
   (if.true
     (touch.gloc.of union-vars)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 185353))
   (touch.gloc.of bind-ellipsis-n)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 186394)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.n+.iloc (0 . 3) -1 "./boot/macro/synpat.scm" . 186415)
   (push.iloc.0 . 4)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 187432)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 187443)
     (push.iloc.0 . 2)
     (push.iloc.0 . 5)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 187418))
   (push)
   (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 186377))
 (set.gloc.of bind-ellipsis-n)
 (ret.const.unspec))
((close
   (4 0 . bind-pattern)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 192528)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 194576))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 195596))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 196636)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 196648))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 197661)
       (if.symbol?
         (touch.gloc.of bind-var!)
         (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 198687)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 198676))
       (touch.gloc.of bind-ellipsis)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 199700))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200732))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 200762)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 200750))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 200729)
     (extend . 1)
     (touch.gloc.of bind-pattern)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 201760)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 201779)
     (push.iloc.1 . 2)
     (call
       (call
         (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 202793)
         (if.false.ret)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 202810)
         (ret.subr.gloc.of symbol? "./boot/macro/synpat.scm" . 202801))
       (if.true
         (touch.gloc.of bind-var!)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 203823)
         (push.const)
         (push.iloc.1 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 203812))
       (touch.gloc.of bind-ellipsis-n)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 204836))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 201746))
   (iloc.0 . 1)
   (if.pair?
     (touch.gloc.of bind-pattern)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 206874)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 206885)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of bind-pattern)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 207912)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 207923)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 207898))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 206860))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 208908)
   (if.true
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209946)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 209966)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 209932))
   (ret.iloc 0 . 3))
 (set.gloc.of bind-pattern)
 (ret.const.unspec))

;
((close
   (2 0 . collect-rename-ids)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 11287)
     (push.iloc 2 . 1)
     (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 11281)
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 12311)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 12305))
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13335)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13351)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 13345))
     (ret.cons "./boot/macro/syntmp.scm" . 13329))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.1 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 7184))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 8199))
 (set.gloc.of collect-rename-ids)
 (ret.const.unspec))
((close
   (1 0 . parse-ellipsis-splicing)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 18469)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 18464))
     (if.true
       (push.n+.iloc (0 . 0) 1 "./boot/macro/syntmp.scm" . 19476)
       (push.cdr.iloc (0 . 1) "./boot/macro/syntmp.scm" . 19486)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 19470))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-head 2 "./boot/macro/syntmp.scm" . 21526)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 21518))
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.subr.gloc.of cdddr 1 "./boot/macro/syntmp.scm" . 17438)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 17413))
 (set.gloc.of parse-ellipsis-splicing)
 (ret.const.unspec))
((close
   (2 0 . check-template)
   (extend.unbound . 2)
   (push.close
     (2 0 . control-patvar-exists?)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 30742))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 30738))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 31762))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 32816))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 33827)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 33816))
           (if.true.ret)
           (call
             (push.iloc.0 . 0)
             (push.const . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 34845))
           (if.false.ret)
           (push.iloc.0 . 1)
           (push.iloc.1 . 1)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 35869))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 28681))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 36882))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 37916)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 37926)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 37910))
         (if.true.ret)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 38945)
           (push.const . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 38939))
         (if.false.ret)
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 39969)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 39963))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 40978))
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of rank-of)
               (push.iloc.0 . 0)
               (push.iloc 5 . 1)
               (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 42029))
             (push)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 42025))
           (call
             (touch.gloc.of collect-unique-ids)
             (push.iloc.0 . 0)
             (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 42056))
           (push)
           (apply.gloc.of any1 "./boot/macro/syntmp.scm" . 42006))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 43036)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 43030))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 45084)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 45078))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 46108)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 46102))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 47122)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 48152)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 48146))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 28681))
   (push.close
     (2 0 . check-escaped)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 55324))
         (push)
         (push.iloc 2 . 1)
         (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 55319)
         (if.false.ret)
         (push.const . "syntax template")
         (push.const . "too few ellipsis following subtemplate")
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 56343))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 58392)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 58386))
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 59416)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 59410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 60434)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 61464)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 61458))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 53257))
   (enclose . 2)
   (call
     (call
       (touch.gloc.of safe-length)
       (push.iloc.1 . 0)
       (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 63505))
     (push)
     (push.const . 2)
     (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 63502)
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 63532)
     (const . ...)
     (ret.eq? "./boot/macro/syntmp.scm" . 63527))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 64536)
     (push.const . 0)
     (apply.iloc (0 . 1) "./boot/macro/syntmp.scm" . 64521))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (call
         (push.iloc.0 . 0)
         (const . ...)
         (if.not.eq?.ret.const . #f)
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 68631))
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 69658))
       (>.iloc (0 . 1) "./boot/macro/syntmp.scm" . 69655)
       (if.false.ret)
       (push.const . "syntax template")
       (push.const . "too few ellipsis following subtemplate")
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 70679))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 71698))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 72752))
       (push.close
         (3 0)
         (call
           (=n.iloc (1 . 1) 0 "./boot/macro/syntmp.scm" . 73753)
           (if.false.ret)
           (call
             (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 74805)
             (push.iloc.0 . 2)
             (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 74781))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 4 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 75805))
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 76831)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 76820))
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 77844))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 65545))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 78866))
     (if.true
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 79906)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 80942)
           (push.iloc 3 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 80933))
         (push)
         (extend . 1)
         (<n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 81954)
         (if.true
           (push.const . "syntax template")
           (push.const . "misplace ellipsis following literal")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 83057)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 82978))
         (n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 84010)
         (<.iloc (0 . 0) "./boot/macro/syntmp.scm" . 84002)
         (if.true
           (push.const . "syntax template")
           (push.const . "too few ellipsis following subtemplate")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 85108)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 85026))
         (push.cddr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 87080)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 87074))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 88096)
       (if.pair?
         (call
           (=n.iloc (0 . 1) 0 "./boot/macro/syntmp.scm" . 89118)
           (if.false.ret)
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 90170)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 90180)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 90146))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 91276)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 91170))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 92191)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 92201)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 92185))
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 93215)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 93209))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 94240)
       (if.null?
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis following empty list")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 95257))
       (push.const . "syntax template")
       (push.const . "misplaced ellipsis following literal")
       (push.iloc 3 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 97385)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 97305))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 98322))
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 99361)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 99346))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 100376)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 100370))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 102424)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 102418))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 103448)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 103442))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 104466)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 105496)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 105490))
     (ret.const.unspec))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 65545))
 (set.gloc.of check-template)
 (ret.const.unspec))
((close
   (2 0 . rank-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 109585)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 110608))
   (ret.const . -1))
 (set.gloc.of rank-of)
 (ret.const.unspec))
((close
   (2 0 . subform-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 114698)
   (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 114693))
 (set.gloc.of subform-of)
 (ret.const.unspec))
((close
   (4 0 . collect-ellipsis-vars)
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 118800))
   (push)
   (extend . 1)
   (touch.gloc.of filter)
   (push.gloc.of values)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 121889)
       (push.iloc.1 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syntmp.scm" . 121883)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 122930)
       (push.iloc 2 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 122924)
       (subr.gloc.of cdr 1 "./boot/macro/syntmp.scm" . 122919)
       (<.iloc (2 . 2) "./boot/macro/syntmp.scm" . 123940)
       (if.true (ret.iloc 0 . 0))
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124975)
       (cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 124986)
       (ret.cons "./boot/macro/syntmp.scm" . 124969))
     (push.iloc.1 . 3)
     (apply.gloc.of map "./boot/macro/syntmp.scm" . 118789))
   (push)
   (apply.gloc.of filter "./boot/macro/syntmp.scm" . 118789))
 (set.gloc.of collect-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . consume-ellipsis-vars)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 139299)
         (push.iloc 3 . 0)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 139290))
       (<.iloc (3 . 1) "./boot/macro/syntmp.scm" . 139287)
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140317)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 140333)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 140327))
         (ret.cons "./boot/macro/syntmp.scm" . 140311))
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 141342)
       (if.null?
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 142365)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 142359))
       (push.iloc.0 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 143390)
       (if.null?
         (const . #t)
         (set.iloc 2 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 145437)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 145431))
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 147499)
         (subr.gloc.of circular-list? 1 "./boot/macro/syntmp.scm" . 147483)
         (if.true.ret)
         (const . #t)
         (set.iloc 2 . 1)
         (ret.const.unspec))
       (touch.gloc.of acons)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 148510)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 148521)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 148539)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 148533))
       (push)
       (apply.gloc.of acons "./boot/macro/syntmp.scm" . 148503))
     (push.iloc 2 . 2)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137230))
   (push)
   (extend . 1)
   (iloc.1 . 1)
   (if.true (iloc.1 . 0) (if.true.ret.const . #f) (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.true.ret)
   (ret.const))
 (set.gloc.of consume-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . contain-rank-moved-var?)
   (extend.enclose+
     (2 0 . traverse-escaped)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 160791))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 160786))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 162844)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 162838))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 163868)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 163862))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 164882)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 165912)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 165906))
       (ret.const . #f))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 158729))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (push.const . 0)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 171027))
       (push)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 171022))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 172046))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 173100))
       (push.close
         (3 0)
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 174111)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 174100))
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 175124))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 168965))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 176142))
     (if.true
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 177176)
         (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 177186)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 177170))
       (if.true.ret)
       (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 178200)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 178194))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 179214))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 180256)
       (push.iloc.0 . 1)
       (apply.iloc+ (2 . 0) "./boot/macro/syntmp.scm" . 180238))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 182296)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 182290))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 183320)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 183314))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 184334)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 185364)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 185358))
     (ret.const . #f))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 168965))
 (set.gloc.of contain-rank-moved-var?)
 (ret.const.unspec))
((close
   (1 0 . make-infinite-list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 197658)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of set-cdr! 2 "./boot/macro/syntmp.scm" . 198680)
   (ret.iloc 0 . 0))
 (set.gloc.of make-infinite-list\x60;6)
 (close
   (3 0 . rewrite-template-ranks-vars)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (2 0 . revealed)
     (push.const . 0)
     (call
       (touch.gloc.of rank-of)
       (push.iloc.0 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 202776))
     (push)
     (push.iloc.0 . 1)
     (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 202771)
     (if.true
       (push.const . "~a:~a")
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syntmp.scm" . 203842))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 3 "./boot/macro/syntmp.scm" . 203826)
       (push.subr.gloc.of string->symbol 1 "./boot/macro/syntmp.scm" . 203810)
       (extend . 1)
       (call
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syntmp.scm" . 204825)
         (if.true.ret)
         (extend.enclose+
           (2 0 . loop)
           (>n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 206882)
           (if.true
             (push.n+.iloc (0 . 0) -1 "./boot/macro/syntmp.scm" . 207912)
             (call
               (touch.gloc.of make-infinite-list\x60;6)
               (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 207946)
               (apply.gloc.of make-infinite-list\x60;6 "./boot/macro/syntmp.scm" . 207926))
             (push)
             (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 207920)
             (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 207906))
           (push.iloc 5 . 0)
           (push.iloc 2 . 0)
           (push.iloc 3 . 1)
           (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syntmp.scm" . 209954)
           (push.iloc 5 . 1)
           (push.iloc 2 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syntmp.scm" . 210978))
         (push.iloc 2 . 1)
         (call
           (touch.gloc.of rank-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 205872))
         (push)
         (push.subr.gloc.of - 2 "./boot/macro/syntmp.scm" . 205863)
         (call
           (touch.gloc.of subform-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of subform-of "./boot/macro/syntmp.scm" . 205900))
         (push)
         (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 205849))
       (ret.iloc 0 . 0))
     (ret.iloc 0 . 0))
   (push.close
     (2 0 . traverse-escaped)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 219160))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 221220)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 221214))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 222244)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 222238))
         (ret.cons "./boot/macro/syntmp.scm" . 221208))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 223256)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 224300)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 224294))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 224280))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 217103))
   (enclose . 2)
   (call
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 230427))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 231451))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 232505))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 233520)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233509))
           (push)
           (push.const . ...)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 233544))
           (push.cons)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 233501))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 228370))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 234523))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 235559)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 235569)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 235553))
         (push)
         (push.const . ...)
         (call
           (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 236594)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 236588))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/syntmp.scm" . 236577)
         (ret.cons "./boot/macro/syntmp.scm" . 235547))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 237595))
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 238625)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 239667)
           (push.iloc.0 . 1)
           (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 239649))
         (ret.cons "./boot/macro/syntmp.scm" . 238619))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 241703)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 241697))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 242727)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 242721))
         (ret.cons "./boot/macro/syntmp.scm" . 241691))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 243739)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 244783)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 244777))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 244763))
       (ret.iloc 0 . 0))
     (push.iloc 3 . 0)
     (push.const . 0)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 228370))
   (push)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 247843)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 247829)
   (push.iloc 2 . 2)
   (push.iloc.1 . 1)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 248866)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 248853)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 195595))
 (set.gloc.of rewrite-template-ranks-vars\x60;2)
 (close
   (3 0 . adapt-to-rank-moved-vars)
   (call
     (touch.gloc.of contain-rank-moved-var?)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of contain-rank-moved-var? "./boot/macro/syntmp.scm" . 250889))
   (if.true
     (touch.gloc.of rewrite-template-ranks-vars\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of rewrite-template-ranks-vars\x60;2 "./boot/macro/syntmp.scm" . 251913))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 252937))
 (set.gloc.of adapt-to-rank-moved-vars)
 (ret.const.unspec))
((close
   (1 0 . remove-duplicates)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 262172)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 262183)
       (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 262166)
       (if.true.ret.const . #f)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 263201)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 263195))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 260109))
   (if.true.ret)
   (touch.gloc.of loop\x60;13)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 264205))
 (set.gloc.of remove-duplicates\x60;2)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 266268)
   (push.iloc.0 . 1)
   (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 266262)
   (if.true
     (touch.gloc.of loop\x60;13)
     (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 267292)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 267286))
   (touch.gloc.of loop\x60;13)
   (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269340)
   (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 269356)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 269334))
 (set.gloc.of loop\x60;13)
 (close
   (5 0 . transcribe-template)
   (push.close
     (0 0)
     (touch.gloc.of adapt-to-rank-moved-vars)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (call
       (touch.gloc.of remove-duplicates\x60;2)
       (push.iloc.1 . 2)
       (apply.gloc.of remove-duplicates\x60;2 "./boot/macro/syntmp.scm" . 271440))
     (push)
     (apply.gloc.of adapt-to-rank-moved-vars "./boot/macro/syntmp.scm" . 271397))
   (push.close
     (3 0)
     (extend.unbound . 5)
     (push.close+
       (2 0 . expand-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 275474)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 277541)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 278569)
           (apply.iloc (4 . 4) "./boot/macro/syntmp.scm" . 278563))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 279587))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 281618)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 281618))
     (push.close+
       (2 0 . expand-ellipsis-var)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 286738)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 288805)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.iloc 4 . 4)
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 289837)
           (apply.gloc.of map "./boot/macro/syntmp.scm" . 289827))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 290851))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 292882)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 292882))
     (push.close
       (3 0 . expand-ellipsis-template)
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 1)
         (if.pair?
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.iloc (3 . 4) "./boot/macro/syntmp.scm" . 300064))
           (push)
           (iloc.0 . 0)
           (push.cons)
           (call
             (touch.gloc.of consume-ellipsis-vars)
             (push.iloc 4 . 1)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.gloc.of consume-ellipsis-vars "./boot/macro/syntmp.scm" . 301082))
           (push)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 300052))
         (iloc.0 . 1)
         (if.null?.ret.const)
         (push.iloc.0 . 1)
         (const . #t)
         (if.eq? (push.iloc.0 . 0) (ret.subr.gloc.of reverse "./boot/macro/syntmp.scm" . 303141))
         (push.const . "syntax template")
         (push.const . "subforms have different size of matched input")
         (push.const . template:)
         (push.iloc 5 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 305172)
         (push.const . subforms:)
         (iloc 5 . 2)
         (push.cons)
         (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 305172))
       (push.const)
       (call
         (touch.gloc.of collect-ellipsis-vars)
         (push.iloc.1 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.gloc.of collect-ellipsis-vars "./boot/macro/syntmp.scm" . 298026))
       (push)
       (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 297995))
     (push.close+
       (3 0 . expand-escaped-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 311321))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 311318)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 312349)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 312342))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 313366))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 315431)
           (ret.null? "./boot/macro/syntmp.scm" . 315424))
         (if.true
           (push.const . \x2E;&NIL)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 317493)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 317468))
           (ret.cons "./boot/macro/syntmp.scm" . 316438))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 318517)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 318492))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 319541)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 319516))
         (ret.cons "./boot/macro/syntmp.scm" . 318486))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 320530)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 321593)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 321568))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 321554))
       (ret.iloc 0 . 0))
     (push.close
       (3 0 . expand-template)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 327705))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 327702)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 328733)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 328726))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 329750))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 330770))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 331824))
         (push.close
           (3 0)
           (call
             (push.gloc.of append)
             (call
               (push.iloc.0 . 0)
               (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 332873)
               (push.iloc.1 . 2)
               (apply.iloc (2 . 2) "./boot/macro/syntmp.scm" . 332842))
             (push)
             (apply.gloc.of apply "./boot/macro/syntmp.scm" . 332828))
           (push)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc (2 . 4) "./boot/macro/syntmp.scm" . 333852))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 332820))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 325641))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 334866))
       (if.true
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 335906)
         (if.symbol?
           (call
             (touch.gloc.of rank-of)
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 336942)
             (push.iloc 2 . 1)
             (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 336933))
           (push)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 337962)
           (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 337954)
           (if.true
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 339007)
               (push.iloc.0 . 2)
               (apply.iloc+ (1 . 1) "./boot/macro/syntmp.scm" . 338986))
             (push)
             (call
               (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 340027)
               (push.iloc.0 . 1)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 340010))
             (push)
             (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 338978))
           (ret.const.unspec))
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 341024)
         (if.pair?
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 342075)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 342086)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 2) "./boot/macro/syntmp.scm" . 342049))
           (push)
           (call
             (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 343090)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 343073))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 342041))
         (ret.const.unspec))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 344082))
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 345137)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 3) "./boot/macro/syntmp.scm" . 345112))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 346153)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 346136))
         (ret.cons "./boot/macro/syntmp.scm" . 345106))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 348199)
           (ret.null? "./boot/macro/syntmp.scm" . 348192))
         (if.true
           (push.const . \x2E;&NIL)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 350253)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 350236))
           (ret.cons "./boot/macro/syntmp.scm" . 349206))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 351277)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 351260))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 352301)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 352284))
         (ret.cons "./boot/macro/syntmp.scm" . 351254))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 353298)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 354353)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 354336))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 354322))
       (ret.iloc 0 . 0))
     (enclose . 5)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.1 . 0)
         (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 357395))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 357392)
       (if.false.ret)
       (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 357422)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 357417))
     (if.true
       (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 358436)
       (push.const . 0)
       (push.iloc.1 . 2)
       (apply.iloc+ (0 . 3) "./boot/macro/syntmp.scm" . 358411))
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (apply.iloc (0 . 4) "./boot/macro/syntmp.scm" . 359435))
   (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 259079))
 (set.gloc.of transcribe-template)
 (ret.const.unspec))

;
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 30773)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 30782)
   (ret.subr.gloc.of \x2E;list "./boot/macro/synrule.scm" . 30758))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . transcribe-compiled-templete)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 10265)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 11289)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synrule.scm" . 13332))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/synrule.scm" . 14359))
   (push)
   (extend . 4)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 21536)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
           (push.iloc 2 . 3)
           (apply.gloc.of rename-id "./boot/macro/synrule.scm" . 21556))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/synrule.scm" . 21546))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synrule.scm" . 21530))
     (push.iloc 2 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/synrule.scm" . 12313)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 17426))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (apply.gloc.of transcribe-template "./boot/macro/synrule.scm" . 23573))
   (push)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 25634)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 25660)
         (apply.gloc.of env-lookup "./boot/macro/synrule.scm" . 25644))
       (ret.cons "./boot/macro/synrule.scm" . 25628))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 24597))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 23565))
 (set.gloc.of transcribe-compiled-templete\x60;2)
 (close
   (2 0 . compiled->source)
   (push.const . syntax-rules)
   (push.iloc.0 . 0)
   (call
     (push.gloc.of \x2E;fn1.1\x60;1)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 30753))
   (push)
   (ret.subr.gloc.of \x2E;cons* "./boot/macro/synrule.scm" . 29703))
 (set.gloc.of compiled->source\x60;2)
 (close
   (2 0 . transcribe-syntax-rules)
   (call
     (iloc.0 . 0)
     (if.pair?.ret.const . #t)
     (push.iloc.0 . 0)
     (push.const . "misplaced syntactic keyword")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 33801))
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 35858)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 35878)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 1)
       (if.true
         (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 39971)
         (push.const . "invalid syntax")
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of put-annotation)
           (call
             (touch.gloc.of compiled->source\x60;2)
             (push.iloc 2 . 0)
             (push.cddr.iloc (3 . 1) "./boot/macro/synrule.scm" . 40044)
             (apply.gloc.of compiled->source\x60;2 "./boot/macro/synrule.scm" . 40020))
           (push)
           (push.iloc 2 . 1)
           (apply.gloc.of put-annotation "./boot/macro/synrule.scm" . 40004))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 39953))
       (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 40995)
       (push.const . "invalid syntax")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 40977))
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 42010)
     (extend . 1)
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 43037)
     (extend . 1)
     (call
       (call
         (touch.gloc.of match-pattern?)
         (push.iloc 5 . 0)
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (apply.gloc.of match-pattern? "./boot/macro/synrule.scm" . 44063))
       (if.false.ret)
       (touch.gloc.of bind-pattern)
       (push.iloc 5 . 0)
       (push.iloc.0 . 0)
       (push.iloc 4 . 0)
       (push.const)
       (apply.gloc.of bind-pattern "./boot/macro/synrule.scm" . 45087))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (touch.gloc.of transcribe-compiled-templete\x60;2)
       (push.cdr.iloc (2 . 0) "./boot/macro/synrule.scm" . 47153)
       (push.iloc.0 . 0)
       (apply.gloc.of transcribe-compiled-templete\x60;2 "./boot/macro/synrule.scm" . 47123))
     (push.cdr.iloc (3 . 0) "./boot/macro/synrule.scm" . 48153)
     (apply.iloc+ (4 . 0) "./boot/macro/synrule.scm" . 48147))
   (push.cddr.iloc (2 . 1) "./boot/macro/synrule.scm" . 35898)
   (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 36871))
 (set.gloc.of transcribe-syntax-rules)
 (ret.const.unspec))
((close
   (3 0 . parse-syntax-rule)
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 52244)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 52268)
   (extend . 2)
   (call
     (touch.gloc.of check-pattern)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of check-pattern "./boot/macro/synrule.scm" . 53255))
   (call
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.const)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synrule.scm" . 54292))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of check-template)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of check-template "./boot/macro/synrule.scm" . 55305))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of collect-rename-ids)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-rename-ids "./boot/macro/synrule.scm" . 56360))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 56329))
 (set.gloc.of parse-syntax-rule)
 (ret.const.unspec))
((close
   (1 0 . make-remark)
   (call
     (touch.gloc.of get-annotation)
     (push.iloc.0 . 0)
     (apply.gloc.of get-annotation "./boot/macro/synrule.scm" . 63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.const . \x2E;&SOURCE-PATH)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/synrule.scm" . 65563)
     (iloc.0 . 0)
     (ret.cons "./boot/macro/synrule.scm" . 65557))
   (ret.const . #f))
 (set.gloc.of make-remark\x60;2)
 (close
   (4 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of list "./boot/macro/synrule.scm" . 73754))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (4 0 . compile-syntax-rules)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-remark\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of make-remark\x60;2 "./boot/macro/synrule.scm" . 70673))
   (push)
   (call
     (push.close
       (1 0)
       (push.close
         (0 0)
         (touch.gloc.of parse-syntax-rule)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (push.iloc 2 . 3)
         (apply.gloc.of parse-syntax-rule "./boot/macro/synrule.scm" . 72775))
       (push.gloc.of \x2E;fn2.1\x60;2)
       (apply.gloc.of \x2E;call-with-values "./boot/macro/synrule.scm" . 71702))
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 61445))
   (push)
   (subr.gloc.of cons 2 "./boot/macro/synrule.scm" . 61445)
   (ret.cons "./boot/macro/synrule.scm" . 61445))
 (set.gloc.of compile-syntax-rules)
 (ret.const.unspec))

;
((push.const . \x2E;patvars)
 (push.const)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 14337))
((close
   (3 0 . make-syntax-object)
   (push.const . type:syntax)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 16446))
 (set.gloc.of make-syntax-object)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-expr)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 17453))
 (set.gloc.of syntax-object-expr)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-renames)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 18477))
 (set.gloc.of syntax-object-renames)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-lexname)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 19501))
 (set.gloc.of syntax-object-lexname)
 (ret.const.unspec))
((close
   (1 0 . wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 23562)
   (const . type:syntax)
   (ret.eq? "./boot/macro/syncase.scm" . 23557))
 (set.gloc.of wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (2 0 . lookup-lexical-name)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 27665))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/syncase.scm" . 29715))
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 29729))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 28679))
   (ret.iloc 2 . 0))
 (set.gloc.of lookup-lexical-name)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 39964)
       (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 39958))
     (if.true.ret)
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 39981)
     (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 39975))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 40978)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 43033)
       (if.false.ret)
       (call
         (touch.gloc.of loop\x60;7)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 44067)
         (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 44061))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 45092)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 45085))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 42020)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 42017)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 42002))
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 46098))
   (if.true.ret.const . #f)
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 48146))
 (set.gloc.of loop\x60;7)
 (close
   (1 0 . contain-non-id-wrapped-syntax-object?)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 37897))
 (set.gloc.of contain-non-id-wrapped-syntax-object?\x60;2)
 (close
   (1 0 . unwrap-syntax)
   (call
     (touch.gloc.of contain-non-id-wrapped-syntax-object?\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of contain-non-id-wrapped-syntax-object?\x60;2 "./boot/macro/syncase.scm" . 50188))
   (if.true
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 55332)
               (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 55326))
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 56356)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 56350))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 57374)
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 58413)
             (apply.gloc.of for-each "./boot/macro/syncase.scm" . 58398))
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 59422))
           (if.true
             (call
               (touch.gloc.of syntax-object-renames)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 60460))
             (push)
             (extend . 1)
             (iloc.0 . 0)
             (if.null?.ret.const . #t)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 62529)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 62500)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 63548)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 63561)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 63524))
           (call
             (touch.gloc.of wrapped-syntax-object?)
             (push.iloc.0 . 0)
             (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 64542))
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 66635)
                 (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 66606)
                 (if.true.ret)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 67654)
                 (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 67662)
                 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 67630))
               (call
                 (touch.gloc.of syntax-object-renames)
                 (push.iloc.0 . 0)
                 (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 68648))
               (push)
               (apply.gloc.of for-each "./boot/macro/syncase.scm" . 65566))
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 69668))
             (push)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 69662))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 53269))
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable->alist "./boot/macro/syncase.scm" . 70677))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 73766)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73760))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 73787)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73781))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 74796)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 74814)
           (ret.eq? "./boot/macro/syncase.scm" . 74807))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 75813))
       (iloc.0 . 0)
       (if.symbol?
         (touch.gloc.of make-syntax-object)
         (push.iloc.0 . 0)
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 77875)
           (if.true.ret)
           (ret.const))
         (push)
         (push.const . #f)
         (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 77847))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 78871))
       (if.true
         (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 79902))
         (if.true (ret.iloc 0 . 0))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 80937))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 80931))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 81943)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 82991)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 82981))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 82967))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 71694))
   (ret.iloc 0 . 0))
 (set.gloc.of unwrap-syntax)
 (ret.const.unspec))
((close
   (2 0 . identical-global-macro?)
   (call
     (touch.gloc.of macro?)
     (push.iloc.0 . 0)
     (apply.gloc.of macro? "./boot/macro/syncase.scm" . 92174))
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 93208)
   (ret.eq? "./boot/macro/syncase.scm" . 93198))
 (set.gloc.of identical-global-macro?\x60;2)
 (close
   (2 0 . unrename-syntax)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (touch.gloc.of annotated?)
         (push.iloc.0 . 0)
         (apply.gloc.of annotated? "./boot/macro/syncase.scm" . 97298))
       (if.true
         (touch.gloc.of annotate)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 98344)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 98338))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 98361)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 98355))
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 98322))
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 99358)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 99352))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 99375)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 99369))
       (ret.cons "./boot/macro/syncase.scm" . 99346))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 101402))
       (push)
       (call
         (touch.gloc.of original-id)
         (push.iloc.0 . 0)
         (apply.gloc.of original-id "./boot/macro/syncase.scm" . 102424))
       (push)
       (extend . 2)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/syncase.scm" . 103447))
       (if.true (ret.iloc 0 . 1))
       (call
         (touch.gloc.of identical-global-macro?\x60;2)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of identical-global-macro?\x60;2 "./boot/macro/syncase.scm" . 104471))
       (if.true (ret.iloc 0 . 1))
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 106510)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 107558)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 107548))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 107534))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 95237))
 (set.gloc.of unrename-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 116774)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 116768))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 116795)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 116789))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 117804)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 117822)
           (ret.eq? "./boot/macro/syncase.scm" . 117815))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 118821))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 119831)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 120879)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 120869))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 120855))
       (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 121879))
       (if.true
         (call
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 122917))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?.ret.const . #t)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 124990)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 124961)
           (if.true.ret)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 126009)
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 126022)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 125985))
         (touch.gloc.of syntax-object-expr)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 126999))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 128023))
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 130116)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 130087)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 131135)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 131143)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 131111))
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 132129))
           (push)
           (apply.gloc.of for-each "./boot/macro/syncase.scm" . 129047))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 133149))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 133143))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 114702))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 135190)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 112645))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;flatten-syntax)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 111619))
((close
   (3 1)
   (extend.enclose+
     (2 0 . match)
     (call
       (touch.gloc.of match-pattern?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/syncase.scm" . 142350))
     (if.false.ret)
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc 2 . 2)
     (push.const)
     (apply.gloc.of bind-pattern "./boot/macro/syncase.scm" . 143374))
   (call
     (touch.gloc.of unwrap-syntax)
     (push.iloc.1 . 1)
     (apply.gloc.of unwrap-syntax "./boot/macro/syncase.scm" . 145425))
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (ret.subr.gloc.of car "./boot/macro/syncase.scm" . 148529))
       (push)
       (push.const . "invalid syntax")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 148493))
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149531)
     (push.subr.gloc.of cadr 1 "./boot/macro/syncase.scm" . 151581)
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149531)
     (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 152603)
     (extend . 2)
     (call
       (push.iloc 3 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 149531)
       (push.subr.gloc.of car 1 "./boot/macro/syncase.scm" . 150554)
       (apply.iloc+ (4 . 0) "./boot/macro/syncase.scm" . 153629))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.1 . 0)
       (if.false.ret.const . #t)
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 156712)
       (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 156704))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 157725)
       (apply.iloc (1 . 1) "./boot/macro/syncase.scm" . 157719))
     (push.cdr.iloc (2 . 0) "./boot/macro/syncase.scm" . 158749)
     (apply.iloc+ (3 . 0) "./boot/macro/syncase.scm" . 158743))
   (push.iloc 3 . 3)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 146439))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax-dispatch)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 137217))
((close
   (1 0 . contain-wrapped-syntax-object?)
   (touch.gloc.of loop\x60;9)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 171017))
 (set.gloc.of contain-wrapped-syntax-object?\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (car.iloc (0 . 0) "./boot/macro/syncase.scm" . 173085)
     (if.null?.ret.const . #t)
     (call
       (touch.gloc.of loop\x60;9)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 173102)
       (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 173096))
     (if.true.ret)
     (touch.gloc.of loop\x60;9)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 173119)
     (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 173113))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 174098)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 176153)
       (if.false.ret)
       (call
         (touch.gloc.of loop\x60;9)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 177187)
         (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 177181))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 178212)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 178205))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 175140)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 175137)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 175122))
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 180242))
 (set.gloc.of loop\x60;9)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;23)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 186401)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 186395))
     (push)
     (call
       (touch.gloc.of loop\x60;23)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 186422)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 186416))
     (push)
     (extend . 2)
     (call
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 187429)
       (iloc.0 . 0)
       (if.not.eq?.ret.const . #f)
       (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 187447)
       (iloc.0 . 1)
       (ret.eq? "./boot/macro/syncase.scm" . 187442))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 188448))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 189458)
   (if.true
     (call
       (touch.gloc.of loop\x60;23)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 190502)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 190496))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 190482))
   (push.iloc.0 . 0)
   (const . \x2E;&NIL)
   (if.eq?.ret.const)
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;23)
 (close
   (2 0 . wrap-renamed-id)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 198689)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 198683))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 198710)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 198704))
       (push)
       (extend . 2)
       (call
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 199717)
         (iloc.0 . 0)
         (if.not.eq?.ret.const . #f)
         (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 199735)
         (iloc.0 . 1)
         (ret.eq? "./boot/macro/syncase.scm" . 199730))
       (if.true (ret.iloc 1 . 0))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/syncase.scm" . 200736))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 201746)
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 202790)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 202784))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 202770))
     (call
       (touch.gloc.of renamed-id?)
       (push.iloc.0 . 0)
       (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 203794))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 204846)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 204818))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 196617))
 (set.gloc.of wrap-renamed-id\x60;2)
 (close
   (1 0 . rewrite-nil)
   (touch.gloc.of loop\x60;23)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 184329))
 (set.gloc.of rewrite-nil\x60;2)
 (close
   (2 0 . partial-wrap-syntax-object)
   (extend.enclose+
     (1 0 . loop)
     (call
       (touch.gloc.of contain-wrapped-syntax-object?\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of contain-wrapped-syntax-object?\x60;2 "./boot/macro/syncase.scm" . 210962))
     (if.true
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 213032)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 213026))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 213053)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 213047))
         (push)
         (extend . 2)
         (call
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 214060)
           (iloc.0 . 0)
           (if.not.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 214078)
           (iloc.0 . 1)
           (ret.eq? "./boot/macro/syncase.scm" . 214073))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 215079))
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (const . \x2E;&NIL)
     (if.eq?
       (touch.gloc.of make-syntax-object)
       (push.const)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 218130))
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 220206)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 220178))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 221202)
     (if.true
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of rewrite-nil\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-nil\x60;2 "./boot/macro/syncase.scm" . 222246))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 222226))
     (iloc.0 . 0)
     (if.pair?
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of rewrite-nil\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-nil\x60;2 "./boot/macro/syncase.scm" . 224294))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 224274))
     (iloc.0 . 0)
     (if.null?.ret.const)
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 227346))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 209929))
 (set.gloc.of partial-wrap-syntax-object\x60;2)
 (close
   (1 0 . emit)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 165904))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 166933))
 (set.gloc.of emit\x60;2)
 (close
   (5 0 . syntax-transcribe)
   (iloc.0 . 1)
   (if.null?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 230409))
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 232465))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/syncase.scm" . 234513))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of rename-id "./boot/macro/syncase.scm" . 236588))
       (ret.cons "./boot/macro/syncase.scm" . 236579))
     (call
       (touch.gloc.of collect-rename-ids)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 237590))
     (push)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 236561))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 239658)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 239688)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 239668))
       (ret.cons "./boot/macro/syncase.scm" . 239652))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 239633))
   (push)
   (extend . 1)
   (call
     (iloc 4 . 4)
     (if.null? (ret.const))
     (iloc 3 . 0)
     (if.null?.ret.const)
     (touch.gloc.of filter)
     (push.gloc.of values)
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 247857)
         (push.iloc 5 . 4)
         (push.subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 248880)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 247857)
             (push.iloc 5 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 250945))
           (push)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 250978)
           (if.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 251975)
           (call
             (touch.gloc.of make-out-of-context)
             (push.iloc 6 . 1)
             (apply.gloc.of make-out-of-context "./boot/macro/syncase.scm" . 251983))
           (ret.cons "./boot/macro/syncase.scm" . 251969))
         (ret.const . #f))
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 231433))
     (push)
     (apply.gloc.of filter "./boot/macro/syncase.scm" . 231433))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 254998))
   (if.null?
     (call
       (touch.gloc.of transcribe-template)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.iloc 5 . 0)
       (push.iloc 2 . 0)
       (push.const . #f)
       (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 256027))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of renamed-id?)
       (push.iloc.0 . 0)
       (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 257045))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 0)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 258098)
         (if.true.ret)
         (ret.const))
       (push)
       (push.iloc 6 . 3)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 258069))
     (touch.gloc.of wrap-renamed-id\x60;2)
     (push.iloc.0 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of wrap-renamed-id\x60;2 "./boot/macro/syncase.scm" . 259093))
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc 5 . 1)
     (push.iloc 5 . 2)
     (push.iloc 5 . 0)
     (push.iloc 2 . 0)
     (push.gloc.of emit\x60;2)
     (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 260123))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 262168))
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (const . \x2E;&NIL)
   (if.eq?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 264216))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 266293)
       (if.true.ret)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 266320)
       (if.true.ret)
       (ret.const))
     (push)
     (push.iloc 6 . 3)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 266264))
   (touch.gloc.of partial-wrap-syntax-object\x60;2)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of extend-env)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 268345))
   (push)
   (apply.gloc.of partial-wrap-syntax-object\x60;2 "./boot/macro/syncase.scm" . 268312))
 (set.gloc.of syntax-transcribe)
 (ret.const.unspec))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 272389))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i0)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 270337))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 276518)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 276485))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i1)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 274433))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 280581))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i2)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 278529))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 284710)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 284677))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i3)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 282625))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 288773))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c0)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 286721))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 292869))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c1)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 290817))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.iloc.0 . 2)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 296965))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c2)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 294913))
((close
   (4 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.iloc.0 . 3)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 301061))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c3)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 299009))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 309290)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 309284))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 309307)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 309301))
       (ret.cons "./boot/macro/syncase.scm" . 309278))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 310309))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 309259))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 311314)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 311352)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 311342))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 311328))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 308233))
 (set.gloc.of rewrite\x60;2)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
   (call
     (touch.gloc.of make-pattern-variable)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
     (apply.gloc.of make-pattern-variable "./boot/macro/syncase.scm" . 306181))
   (ret.cons "./boot/macro/syncase.scm" . 306181))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . expand-syntax-case)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/syncase.scm" . 306181)
     (ret.subr.gloc.of \x2E;list? "./boot/macro/syncase.scm" . 306181))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "./boot/macro/syncase.scm" . 306181)
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
     (extend . 2)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/syncase.scm" . 306181)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 306181))
     (push)
     (extend . 1)
     (call
       (call
         (push.iloc.0 . 0)
         (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 306181)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 0)
         (apply.gloc.of every1 "./boot/macro/syncase.scm" . 306181))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "invalid literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 306181))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 0)
         (apply.gloc.of unique-id-list? "./boot/macro/syncase.scm" . 306181))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "duplicate literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 306181))
     (call
       (push.const . _)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 306181)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "_ in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 306181))
     (call
       (push.const . ...)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 306181)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "... in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 306181))
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of lookup-lexical-name)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 306181))
         (ret.cons "./boot/macro/syncase.scm" . 306181))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 306181))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of rewrite\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of rewrite\x60;2 "./boot/macro/syncase.scm" . 306181))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . parse-pattern)
       (call
         (touch.gloc.of rewrite\x60;2)
         (call
           (touch.gloc.of unrename-syntax)
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 306181))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of rewrite\x60;2 "./boot/macro/syncase.scm" . 306181))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 306181))
       (call
         (touch.gloc.of check-pattern)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of check-pattern "./boot/macro/syncase.scm" . 306181))
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of \x2E;fn1.1\x60;1)
           (call
             (touch.gloc.of collect-vars-ranks)
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.const . 0)
             (push.const)
             (apply.gloc.of collect-vars-ranks "./boot/macro/syncase.scm" . 306181))
           (push)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 306181))
         (push)
         (push.iloc 7 . 1)
         (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 306181))
       (push)
       (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 306181))
     (touch.gloc.of annotate)
     (push.const . \x2E;syntax-dispatch)
     (call
       (touch.gloc.of expand-form)
       (push.const . \x2E;patvars)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 306181))
     (push)
     (call
       (touch.gloc.of expand-form)
       (push.iloc 4 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 306181))
     (push)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 306181)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 306181)
           (ret.pair? "./boot/macro/syncase.scm" . 306181))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
           (ret.null? "./boot/macro/syncase.scm" . 306181))
         (if.true
           (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
           (extend . 2)
           (push.close
             (0 0)
             (push.iloc.1 . 1)
             (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 306181))
           (push.close
             (2 0)
             (push.const . \x2E;list)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 306181)
             (push.const . #f)
             (call
               (touch.gloc.of expand-form)
               (push.const . \x2E;LAMBDA)
               (push.const \x2E;patvars)
               (push.iloc.1 . 0)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 306181)
               (push.iloc.0 . 1)
               (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 306181))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/syncase.scm" . 306181))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 306181))
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;cdddr 1 "./boot/macro/syncase.scm" . 306181)
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;caddr 1 "./boot/macro/syncase.scm" . 306181)
         (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 306181)
         (extend . 3)
         (push.close
           (0 0)
           (push.iloc.1 . 2)
           (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 306181))
         (push.close
           (2 0)
           (push.const . \x2E;list)
           (push.const . quote)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 306181)
           (call
             (touch.gloc.of expand-form)
             (push.const . \x2E;LAMBDA)
             (push.const \x2E;patvars)
             (push.iloc.1 . 1)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 306181)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 306181))
           (push)
           (call
             (touch.gloc.of expand-form)
             (push.const . \x2E;LAMBDA)
             (push.const \x2E;patvars)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 306181)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 306181))
           (push)
           (ret.subr.gloc.of \x2E;list "./boot/macro/syncase.scm" . 306181))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 306181))
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 306181))
     (push)
     (push.subr.gloc.of \x2E;cons* 5 "./boot/macro/syncase.scm" . 306181)
     (push.iloc 4 . 1)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 306181))
   (push.const . syntax-case)
   (push.const . "invalid syntax")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 306181))
 (set.gloc.of expand-syntax-case)
 (ret.const.unspec))
((close
   (2 0 . rewrite)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 370730)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 370724))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 370747)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 370741))
       (ret.cons "./boot/macro/syncase.scm" . 370718))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 371749))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 370699))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 372754)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 372792)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 372782))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 372768))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 369673))
 (set.gloc.of rewrite\x60;2)
 (close
   (2 0 . expand-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 367621)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 367621)
     (ret.null? "./boot/macro/syncase.scm" . 367621))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 367621)
     (extend . 1)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 367621))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 367621))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of pattern-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of pattern-variable? "./boot/macro/syncase.scm" . 367621))
           (if.false.ret)
           (push.iloc.1 . 0)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 367621)
           (ret.cons "./boot/macro/syncase.scm" . 367621))
         (call
           (touch.gloc.of collect-unique-ids)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-unique-ids "./boot/macro/syncase.scm" . 367621))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 367621))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 367621))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of check-template)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-template "./boot/macro/syncase.scm" . 367621))
     (call
       (touch.gloc.of expand-form)
       (push.const . \x2E;patvars)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 367621))
     (push)
     (extend . 1)
     (iloc 2 . 0)
     (if.symbol?
       (call
         (touch.gloc.of lookup-lexical-name)
         (push.iloc 3 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 367621))
       (push)
       (extend . 1)
       (push.iloc 3 . 0)
       (iloc.0 . 0)
       (if.eq?
         (iloc 2 . 0)
         (if.null?
           (touch.gloc.of annotate)
           (push.const . \x2E;syntax/i0)
           (push.iloc.1 . 0)
           (push.const . quote)
           (push.iloc 3 . 0)
           (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 367621)
           (push.iloc 5 . 0)
           (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/i1)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
         (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 367621)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/i2)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
         (push.const . quote)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
         (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 367621)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/i3)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 367621)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.iloc.0 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 367621))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of renamed-id?)
             (push.iloc.0 . 0)
             (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 367621))
           (if.false.ret)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (if.eq?.ret.const . #f)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (ret.cons "./boot/macro/syncase.scm" . 367621))
         (call
           (touch.gloc.of collect-rename-ids)
           (push.iloc 2 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 367621))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 367621))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 367621))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/c0)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
         (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 367621)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/c1)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.const . quote)
       (push.iloc 2 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 367621)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
     (iloc 2 . 0)
     (if.null?
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/c2)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 367621)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
     (touch.gloc.of annotate)
     (push.const . \x2E;syntax/c3)
     (push.iloc.1 . 0)
     (push.const . quote)
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
     (push.const . quote)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
     (push.const . quote)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 367621)
     (push.subr.gloc.of \x2E;list 5 "./boot/macro/syncase.scm" . 367621)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 367621))
   (push.const . syntax)
   (push.const . "expected exactly one datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 367621))
 (set.gloc.of expand-syntax)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;5)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 424990)
       (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 424984))
     (push)
     (call
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 425011)
       (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 425005))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 426020)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 426038)
       (ret.eq? "./boot/macro/syncase.scm" . 426031))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 427037))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 428047)
   (if.true
     (call
       (push.gloc.of loop\x60;5)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 429095)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 429085))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 429071))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 430095))
   (if.true
     (touch.gloc.of loop\x60;5)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 431125))
     (push)
     (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 431119))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . syntax->datum)
   (touch.gloc.of strip-rename-suffix)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 422918))
   (push)
   (apply.gloc.of strip-rename-suffix "./boot/macro/syncase.scm" . 422918))
 (set.gloc.of syntax->datum)
 (ret.const.unspec))
((close
   (2 0 . datum->syntax)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 436233))
   (if.false.call
     (push.const . datum->syntax)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 437293)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 437257))
   (call
     (touch.gloc.of retrieve-rename-suffix)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 438315))
     (push)
     (apply.gloc.of retrieve-rename-suffix "./boot/macro/syncase.scm" . 438291))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-renames)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 439323))
     (if.null?
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 440340))
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 441364))
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 4)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 446503)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 446497))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 446520)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 446514))
         (ret.cons "./boot/macro/syncase.scm" . 446491))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 447515)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 448563)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 448553))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 448539))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 450594)
         (if.true.ret)
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/syncase.scm" . 452684)
         (push.iloc 2 . 0)
         (push.subr.gloc.of string-append 2 "./boot/macro/syncase.scm" . 452669)
         (push.subr.gloc.of string->symbol 1 "./boot/macro/syncase.scm" . 452653)
         (extend . 1)
         (push.iloc 3 . 2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syncase.scm" . 453668)
         (call
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 454710))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq?
             (push.iloc 4 . 3)
             (push.iloc.1 . 0)
             (call
               (touch.gloc.of env-lookup)
               (push.iloc 4 . 1)
               (push.iloc 2 . 0)
               (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 457802))
             (push)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 457773))
           (push.iloc 4 . 3)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 460845))
         (ret.iloc 0 . 0))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 444434))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 464947)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 464937)
       (if.true.ret)
       (ret.const))
     (push)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 464909))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.iloc.1 . 3)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 465957)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 465933))
 (set.gloc.of datum->syntax)
 (ret.const.unspec))
((close
   (1 0 . identifier?)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 470026))
   (if.false.ret)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 471059))
   (push)
   (ret.subr.gloc.of symbol? "./boot/macro/syncase.scm" . 471050))
 (set.gloc.of identifier?)
 (ret.const.unspec))
((close
   (2 0 . bound-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 475145))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 476210)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 476169))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 477193))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 478258)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 478217))
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 479242))
   (push)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 479267))
   (ret.eq? "./boot/macro/syncase.scm" . 479237))
 (set.gloc.of bound-identifier=?)
 (ret.const.unspec))
((close
   (2 0 . free-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 483337))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 484401)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 484361))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 485385))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 486449)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 486409))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 487444))
   (push)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 488468))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 489490))
   (push)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 490514))
   (push)
   (extend . 2)
   (call
     (iloc.0 . 0)
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 491569))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 491548))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 492593))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 492572))
   (push)
   (extend . 2)
   (call (iloc.1 . 0) (if.false.ret) (ret.iloc 1 . 1))
   (if.true (push.iloc.1 . 0) (iloc.1 . 1) (ret.eq? "./boot/macro/syncase.scm" . 493600))
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 494629))
     (push)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 494654))
     (ret.eq? "./boot/macro/syncase.scm" . 494624))
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 495644))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 2 . 1)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 495669))
   (ret.eq? "./boot/macro/syncase.scm" . 495639))
 (set.gloc.of free-identifier=?)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of make-syntax-object)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syncase.scm" . 501802))
   (push)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 501782))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0 . generate-temporaries)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 499721)
   (if.false.call
     (push.const . generate-temporaries)
     (push.const . "expected list, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 500788)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 500745))
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of map "./boot/macro/syncase.scm" . 501765))
 (set.gloc.of generate-temporaries)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer)
   (touch.gloc.of make-variable-transformer-token)
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 507922))
       (if.true (ret.iloc 0 . 0))
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 509970))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 507912))
   (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 505861))
 (set.gloc.of make-variable-transformer)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer-token)
   (push.const . type:variable-transformer-token)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 514053))
 (set.gloc.of make-variable-transformer-token)
 (ret.const.unspec))
((close
   (1 0 . variable-transformer-token?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 518154)
   (const . type:variable-transformer-token)
   (ret.eq? "./boot/macro/syncase.scm" . 518149))
 (set.gloc.of variable-transformer-token?)
 (ret.const.unspec))
((close
   (1 0)
   (push.close
     (1 0 . thunk)
     (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (2 . 0) "./boot/macro/syncase.scm" . 524320))
     (push.gloc.of \x2E;fn1.1\x60;1)
     (apply.gloc.of call-with-values "./boot/macro/syncase.scm" . 523284))
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of procedure? 1 "./boot/macro/syncase.scm" . 529422)
   (if.true
     (push.close
       (0 0)
       (touch.gloc.of closure-arity)
       (push.iloc 2 . 0)
       (apply.gloc.of closure-arity "./boot/macro/syncase.scm" . 530472))
     (push.close
       (2 0)
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.0 . 1)
       (if.false.ret)
       (=n.iloc (0 . 0) 1 "./boot/macro/syncase.scm" . 531487)
       (if.false.ret)
       (=n.iloc (0 . 1) 0 "./boot/macro/syncase.scm" . 531499)
       (if.false.ret)
       (ret.iloc 1 . 0))
     (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 522245))
   (call
     (touch.gloc.of variable-transformer-token?)
     (push.iloc.1 . 0)
     (apply.gloc.of variable-transformer-token? "./boot/macro/syncase.scm" . 532494))
   (if.true
     (push.iloc.1 . 0)
     (push.const . 1)
     (subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 533529)
     (set.iloc 1 . 0)
     (touch.gloc.of make-variable-transformer-token)
     (push.iloc.0 . 0)
     (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 534542))
   (ret.iloc 1 . 0))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 1)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;flatten-syntax "./boot/macro/syncase.scm" . 527387))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 1) "./boot/macro/syncase.scm" . 528423)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 528411))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;transformer-thunk)
 (push.gloc.of \x2E;fn2.1\x60;2)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 521219))

;
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/library.scm" . 5150))
 (set.gloc.of scheme-library-paths)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 6176))
 (set.gloc.of scheme-library-exports)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 7201))
 (set.gloc.of scheme-library-versions)
 (ret.const.unspec))
((close
   (2 0 . symbol-list->string)
   (push.gloc.of string-append)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 14371)
       (if.symbol?
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 16438)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/library.scm" . 16422)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 17452)
           (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 17446))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/library.scm" . 16416)
         (ret.cons "./boot/macro/library.scm" . 15386))
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 19488)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 19482))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 12305))
   (push)
   (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 10243)
   (apply.gloc.of apply "./boot/macro/library.scm" . 10243))
 (set.gloc.of symbol-list->string)
 (ret.const.unspec))
((close
   (1 0 . generate-library-id)
   (touch.gloc.of library-name->id)
   (push.const . #f)
   (push.iloc.0 . 0)
   (apply.gloc.of library-name->id "./boot/macro/library.scm" . 23557))
 (set.gloc.of generate-library-id)
 (ret.const.unspec))
((close
   (2 0 . library-name->id)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.true
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 31809))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 31757))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 32781))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 34830)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 34848)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 34843))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 35853))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.1 . 1)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 36919))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 36893))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 36877))
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 37932)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 37929)
     (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 37913)
     (extend . 1)
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 38931))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of current-library-infix)
           (apply.gloc.of current-library-infix "./boot/macro/library.scm" . 39997))
         (push)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 39971))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 39955))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 40979))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 41993))
 (set.gloc.of library-name->id)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 55310)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 55325)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 55338))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (2 0 . library-name->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 50244))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 50189))
     (push.const . library)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 51213))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 57358)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 57376)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 57371))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 58384))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 60468)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 60465)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 60449)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 60444)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . #f)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 62494)
       (if.false.ret)
       (touch.gloc.of every1)
       (push.gloc.of exact-nonnegative-integer?\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 62507))
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 63518))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 64521))
 (set.gloc.of library-name->version)
 (ret.const.unspec))
((close
   (2 0 . library-reference->name)
   (extend.enclose+
     (0 0 . malformed-name)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 72769))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 72717))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 73741))
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.1 . 1)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 75788))
   (if.true (ret.iloc 1 . 1))
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 77866)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 77863)
   (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 77848)
   (extend . 1)
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 78869))
   (if.true (ret.iloc 0 . 0))
   (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 79898))
 (set.gloc.of library-reference->name)
 (ret.const.unspec))
((close
   (2 0 . flatten-library-reference)
   (call
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 83982)
       (if.false.ret)
       (push.iloc.0 . 1)
       (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 83999)
       (ret.subr.gloc.of not "./boot/macro/library.scm" . 83994))
     (if.true.ret)
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 85053))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 85001))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 83973)
     (if.false.ret)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (touch.gloc.of flatten-library-reference)
     (push.iloc.0 . 0)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 83973))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 83973))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 83973))
   (ret.iloc 0 . 1))
 (set.gloc.of flatten-library-reference)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 102414)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 102429)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 102442))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (2 0 . library-reference->version)
   (extend.enclose+
     (0 0 . malformed-version)
     (iloc 2 . 0)
     (if.pair?
       (push.const . import)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 97347))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 97293))
     (push.const . import)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 98317))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 104462)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 104479)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 104474))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 105488))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 106552)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 106549)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 106534)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 106529)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 107550)
     (if.true (ret.iloc 0 . 0))
     (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 108579))
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 109577))
 (set.gloc.of library-reference->version)
 (ret.const.unspec))
((close
   (1 0 . exact-nonnegative-integer?)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 116750)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 116765)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 116778))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (4 0 . test-library-versions)
   (call
     (extend.enclose
       (1 0 . loop)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 119819)
         (ret.subr.gloc.of \x2E;list? "./boot/macro/library.scm" . 119819))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . not)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
           (apply.iloc (2 . 0) "./boot/macro/library.scm" . 119819))
         (push)
         (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . or)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . and)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of every1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
       (extend.enclose
         (2 0 . loop)
         (call
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/macro/library.scm" . 119819)
             (if.false.ret)
             (push.iloc.0 . 1)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
           (if.true.ret)
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 5 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (iloc.0 . 1)
         (if.null?.ret.const . #t)
         (push.iloc.0 . 0)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (subr.gloc.of >= 2 "./boot/macro/library.scm" . 119819)
         (if.false.ret)
         (touch.gloc.of every2)
         (push.close
           (2 0)
           (call
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (0 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of \x2E;list? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 1)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (ret.null? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . not)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (call
               (push.iloc 2 . 0)
               (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
               (apply.iloc (4 . 0) "./boot/macro/library.scm" . 119819))
             (push)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . >=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of >= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . <=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of <= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . and)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of every1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . or)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
           (call
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.iloc 2 . 1)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (ret.subr.gloc.of = "./boot/macro/library.scm" . 119819))
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 8 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 8 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (apply.gloc.of every2 "./boot/macro/library.scm" . 119819))
       (push.iloc 4 . 3)
       (push.iloc 2 . 0)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 119819))
     (push.iloc.1 . 2)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 118793))
   (if.true.ret)
   (push.const . import)
   (push.const . "mismatch between version reference ~a and current version ~a")
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 142363)
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 143387))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 141321))
 (set.gloc.of test-library-versions)
 (ret.const.unspec))
((close
   (1 0 . make-shield-id-table)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (call
     (touch.gloc.of make-unbound)
     (apply.gloc.of make-unbound "./boot/macro/library.scm" . 147500))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 148510))
     (push.gloc.of coreform-primitives)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 148487))
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 151574)
           (apply.iloc (1 . 0) "./boot/macro/library.scm" . 151568))
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 152598)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 152592))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 154640))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 155664)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 156694)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 156688))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 149511))
   (ret.iloc 0 . 0))
 (set.gloc.of make-shield-id-table)
 (ret.const.unspec))
((close
   (3 0 . verify-no-unbound-id)
   (extend.enclose
     (1 0 . find-expression)
     (push.close
       (1 0)
       (extend.enclose
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq?.ret.const . #t)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 169002)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 168996)
         (if.true.ret.const . #f)
         (call
           (touch.gloc.of any1)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 170015))
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 171039))
       (call
         (push.car.iloc (4 . 1) "./boot/macro/library.scm" . 165933)
         (const . begin)
         (if.eq? (push.iloc 4 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 165951))
         (ret.iloc 4 . 1))
       (push)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 165908))
     (apply.gloc.of call/cc "./boot/macro/library.scm" . 163847))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (call
       (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 174112)
       (const . begin)
       (if.eq? (push.iloc 2 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 174130))
       (ret.iloc 2 . 1))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 175134))
       (iloc.0 . 0)
       (if.pair?
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 177178)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 177172)
         (if.true.ret)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/library.scm" . 178196))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 174087))
   (call
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 180262)
         (call
           (touch.gloc.of current-primitive-prefix)
           (apply.gloc.of current-primitive-prefix "./boot/macro/library.scm" . 180270))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 180245))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 181286)
         (call
           (touch.gloc.of current-rename-delimiter)
           (apply.gloc.of current-rename-delimiter "./boot/macro/library.scm" . 181294))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 181269))
       (if.true.ret)
       (call
         (touch.gloc.of symbol-contains)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 182310)
         (call
           (touch.gloc.of current-library-suffix)
           (apply.gloc.of current-library-suffix "./boot/macro/library.scm" . 182318))
         (push)
         (apply.gloc.of symbol-contains "./boot/macro/library.scm" . 182293))
       (if.true.ret)
       (push.iloc 3 . 2)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 183351)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 183317)
       (if.true.ret)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 184347)
       (push.gloc.of coreform-primitives)
       (subr.gloc.of memq 2 "./boot/macro/library.scm" . 184341)
       (if.true.ret)
       (call
         (touch.gloc.of current-macro-expression)
         (push.const . #f)
         (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 186391))
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 188518)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 188467)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 189491))
       (push)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 190532)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 190515))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/library.scm" . 187415))
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 191503)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 179207))
   (ret.iloc 2 . 1))
 (set.gloc.of verify-no-unbound-id)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (cadr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (ret.cons "./boot/macro/library.scm" . 197639))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 197639))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 197639))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (2 0 . parse-exports)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of reverse "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 197639))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 197639)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 197639)
       (extend . 2)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of \x2E;fn3.1\x60;3)
           (push.iloc.0 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 197639))
         (if.true.ret)
         (push.const . export)
         (push.const . "malformed export spec")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 197639)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
       (push.iloc.0 . 0)
       (call
         (push.gloc.of \x2E;fn1.1\x60;1)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/library.scm" . 197639))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 197639)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 197639))
     (push.const . export)
     (push.const . "malformed export spec")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 2 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 196613))
 (set.gloc.of parse-exports)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 231431))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 231431))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . parse-imports)
   (extend.unbound . 2)
   (push.close
     (3 0 . check-unbound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 219161)
       (if.true.ret)
       (push.const . import)
       (push.const . "attempt to reference unexported identifier ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 220211)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 220271))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 220185))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 218121))
   (push.close
     (3 0 . check-bound-identifier)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 226330)
       (if.false.ret)
       (push.const . import)
       (push.const . "duplicate import identifiers ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 227380)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 227426))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 227354))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 225289))
   (enclose . 2)
   (extend.enclose
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 231431)
       (ret.pair? "./boot/macro/library.scm" . 231431))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 231431)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 231431)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (ret.subr.gloc.of memq "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 231431)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of memq 2 "./boot/macro/library.scm" . 231431)
           (ret.subr.gloc.of not "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 231431)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of \x2E;fn1.1\x60;1)
           (push.iloc.1 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "malformed import set")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (call
           (call
             (touch.gloc.of unique-id-list?)
             (call
               (push.gloc.of car)
               (push.iloc.1 . 1)
               (apply.gloc.of map "./boot/macro/library.scm" . 231431))
             (push)
             (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
           (if.false.ret)
           (touch.gloc.of unique-id-list?)
           (call
             (push.gloc.of cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of map "./boot/macro/library.scm" . 231431))
           (push)
           (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "duplicate identifers in rename specs")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of cadr)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 1) "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of car)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 231431)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
             (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
             (ret.cons "./boot/macro/library.scm" . 231431))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cdddar 1 "./boot/macro/library.scm" . 231431)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 231431)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.close
           (1 0)
           (push.const . "~a~a")
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of string->symbol 1 "./boot/macro/library.scm" . 231431)
           (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (ret.cons "./boot/macro/library.scm" . 231431))
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
           (push.const)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
         (push)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 2 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (call
         (touch.gloc.of flatten-library-reference)
         (push.iloc 5 . 0)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 231431))
       (push)
       (call
         (touch.gloc.of library-reference->version)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->version "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of \x2E;require-scheme-library "./boot/macro/library.scm" . 231431))
       (call
         (touch.gloc.of library-name->id)
         (push.iloc 7 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-name->id "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (iloc.1 . 1)
           (if.false.ret)
           (call
             (touch.gloc.of scheme-library-versions)
             (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 231431))
           (push)
           (push.iloc.0 . 0)
           (push.const . #f)
           (ret.subr.gloc.of core-hashtable-ref "./boot/macro/library.scm" . 231431))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of test-library-versions)
           (push.iloc 9 . 0)
           (push.iloc 3 . 0)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of test-library-versions "./boot/macro/library.scm" . 231431))
         (ret.const.unspec))
       (push.iloc 3 . 0)
       (call
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 231431)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (ret.subr.gloc.of append "./boot/macro/library.scm" . 231431))
         (push.const . import)
         (push.const . "attempt to import undefined library")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 9 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (6 . 0) "./boot/macro/library.scm" . 231431))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 4 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
   (push.iloc 2 . 1)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 230405))
 (set.gloc.of parse-imports)
 (ret.const.unspec))
((close
   (2 0 . parse-depends)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 292871)
       (ret.pair? "./boot/macro/library.scm" . 292871))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 292871)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 292871)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 292871)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 292871)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;cdddar 1 "./boot/macro/library.scm" . 292871)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 292871)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of flatten-library-reference)
           (push.iloc 3 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
           (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 292871))
         (push)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 292871))
       (push)
       (iloc.1 . 1)
       (push.cons)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 3 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 292871))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 292871))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 291845))
 (set.gloc.of parse-depends)
 (ret.const.unspec))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 319506))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 320540)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 320530))
   (if.true
     (touch.gloc.of loop\x60;8)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 321560)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 321583)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 321554))
   (touch.gloc.of loop\x60;8)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 323608)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 323624)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 323602))
 (set.gloc.of loop\x60;8)
 (close
   (1 0 . permute-env)
   (touch.gloc.of loop\x60;8)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 317465)
   (push.const)
   (push.const)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 317449))
 (set.gloc.of permute-env\x60;2)
 (close
   (2 0 . expand-library)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;caddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;cdddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;cadddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of \x2E;cdr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cddddr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;caaddr 1 "./boot/macro/library.scm" . 315397)
     (const . export)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of \x2E;car 1 "./boot/macro/library.scm" . 315397)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 315397))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cddddr 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of \x2E;cdr 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdaddr 1 "./boot/macro/library.scm" . 315397)
     (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (extend . 4)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 315397))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of parse-exports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of parse-exports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 315397))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 6)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc.1 . 5)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (push.const . #f)
           (subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
           (if.false.ret)
           (push.const . library)
           (push.const . "duplicate export identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 4 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc.1 . 5)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 4)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (if.eq?.ret.const . #t)
           (push.const . library)
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc 2 . 4)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 1)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 315397))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #t)
     (push.subr.gloc.of core-hashtable-copy 2 "./boot/macro/library.scm" . 315397)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 315397)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc 2 . 4)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 315397)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 3)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.iloc 7 . 0)
       (call
         (touch.gloc.of expand-library-body)
         (push.iloc 7 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc 4 . 2)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of permute-env\x60;2)
             (push.iloc 3 . 0)
             (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 315397))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 315397))
         (push)
         (call
           (touch.gloc.of permute-env\x60;2)
           (push.iloc 2 . 0)
           (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 315397))
         (push)
         (apply.gloc.of expand-library-body "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc 4 . 4)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 315397))
   (push.const . library)
   (push.const . "expected library name, export spec, and import spec")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
 (set.gloc.of expand-library)
 (ret.const.unspec))
((close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 400414))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 400397))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 401448))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 401431))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 402454)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 404526)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 404517)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 406574)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 408659)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 408632)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 408632))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 409656))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 407590))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 412726))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 413750))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 411684))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 414742)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 416814)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 416805)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 418862)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 420947)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 420920)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 420920))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 421944))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 419878))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 425041)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 425014)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 425014))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 426065)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 426038)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 426038))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 423972))
   (push.const . library)
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 428054))
 (set.gloc.of check-duplicate-definition\x60;2)
 (close
   (1 0)
   (push.const . \x2E;require-scheme-library)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 435223)
   (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 435223))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (9 0 . expand-library-body)
   (extend.unbound . 6)
   (push.close
     (1 0 . internal-definition?)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/library.scm" . 374805)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/library.scm" . 375831)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 376874)
       (apply.gloc.of env-lookup "./boot/macro/library.scm" . 376858))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/library.scm" . 377876))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-macro)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/library.scm" . 382996))
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 389134))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 390175))
       (set.iloc 1 . 1)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 391199)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 391187))
     (set.iloc 2 . 7)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 392233)
       (push.iloc 3 . 7)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 392223))
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 392201))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 396322)
       (push.iloc 2 . 8)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 396310))
     (set.iloc 2 . 8)
     (ret.const.unspec))
   (push.close
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of check-duplicate-definition\x60;2)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of check-duplicate-definition\x60;2 "./boot/macro/library.scm" . 432137))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 7)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 433182))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc 3 . 6)
       (apply.gloc.of map "./boot/macro/library.scm" . 435218))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 440388)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 441393)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 441387)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 441382)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 442419)
             (push.iloc 6 . 7)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 442406))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 443421))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 441371))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 441371))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 441371))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 439314))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 449576))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 453701)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 453691))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 453686)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 454734)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 454742)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 454710))
             (ret.const.unspec))
           (push.iloc 5 . 8)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 455728)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 452646))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 456742))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 449558)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 449558)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 449558)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 458810)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 458804)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 458799)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 460849)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . template)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 462889)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 462889)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 462889))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . procedure)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 463913)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 463913))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 459825)
           (const . variable)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 464937)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 464937))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 465967))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 449558))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 449558)
       (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 449558))
     (push)
     (push.const . \x2E;intern-scheme-library)
     (push.const . quote)
     (push.iloc 3 . 1)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 467985)
     (push.const . quote)
     (push.iloc 3 . 2)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 467985)
     (push.const . quote)
     (call
       (push.close
         (1 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 474149)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 475186)
           (push.iloc 2 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 475180)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (touch.gloc.of make-import)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 475231)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 475218))
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 476210)
           (push.iloc 5 . 5)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 476204)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 475173))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 478252))
           (push.const . library)
           (push.const . "attempt to export unbound identifier ~u")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 480368)
           (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 480318)
           (push.iloc 6 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 481342)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 479276))
         (ret.cons "./boot/macro/library.scm" . 473117))
       (push.iloc 3 . 4)
       (apply.gloc.of map "./boot/macro/library.scm" . 434187))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 434187)
     (push.subr.gloc.of \x2E;list 4 "./boot/macro/library.scm" . 434187)
     (extend . 4)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 483353))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 484384))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 485398))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 487489)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 487497)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 487508))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 487461))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 488477))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 490543)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 492634)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 492604))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 493628))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 491567))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 489501))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 495629)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 495629)
     (subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 495629)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 495629))
   (enclose . 5)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 503844)
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 5)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 505927)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 505883))
     (push.iloc.1 . 5)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 505861))
   (extend.enclose
     (4 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 507943)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 507964)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 507955))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 7)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 508970)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 508954))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 7)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 511005))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 510999))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 513047)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdddar 1 "./boot/macro/library.scm" . 513047)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 513047)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 513047)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 513047))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;caddar 1 "./boot/macro/library.scm" . 513047)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 513047)
           (extend . 3)
           (call
             (push.iloc 4 . 5)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 513047)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 513047)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 513047))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 513047)
             (push.iloc.1 . 1)
             (push.iloc 6 . 7)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 513047))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 513047))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (6 . 3) "./boot/macro/library.scm" . 513047))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 513047)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 513047))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 513047)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 513047))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 513047))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 513047)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 7)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 513047))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 513047))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 513047)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 513047))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 513047))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 513047))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 513047)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 513047))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 533569)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 533553))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 533548)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 533582)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 533538))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 5)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 534607)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 534558)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 535646)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 535582))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 536612)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 537667)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 537636))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 538651))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 539695))
           (push)
           (apply.iloc (5 . 3) "./boot/macro/library.scm" . 539675))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 540705)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 540739))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 540699))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 542777)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 542755))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 542789)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 542743))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 543771))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 545819))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 546886)
           (push.iloc 5 . 7)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 546864))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 7)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 548921)
             (push.iloc 5 . 7)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 548906))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 550952)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 550946))
           (call (push.iloc.0 . 0) (apply.iloc (5 . 0) "./boot/macro/library.scm" . 551970))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 553018)
             (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 553000)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 552994))
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555061)
           (push.iloc 3 . 2)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 555076)
           (push.iloc 3 . 3)
           (apply.iloc (5 . 4) "./boot/macro/library.scm" . 555042))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 508942))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557098)
       (push.iloc.1 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 557113)
       (push.iloc.1 . 3)
       (apply.iloc (3 . 4) "./boot/macro/library.scm" . 557079))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 559137)
     (push.iloc.0 . 2)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 559152)
     (push.iloc.0 . 3)
     (apply.iloc (2 . 4) "./boot/macro/library.scm" . 559118))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 7)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 506902))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 506885))
 (set.gloc.of expand-library-body)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 564255)
   (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 564278)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/library.scm" . 567321)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/library.scm" . 568349)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 568375))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 569376)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 570418))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/macro/library.scm" . 571458)
   (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 571429))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0 . import-top-level-bindings)
   (push.gloc.of \x2E;fn2.1\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/macro/library.scm" . 562179))
 (set.gloc.of import-top-level-bindings)
 (ret.const.unspec))
((close
   (2 0 . expand-import)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/library.scm" . 576522))
     (if.false.ret)
     (push.const . import)
     (push.const . "misplaced top-level directive")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 577546))
   (call
     (touch.gloc.of auto-compile-cache-update)
     (apply.gloc.of auto-compile-cache-update "./boot/macro/library.scm" . 578565))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 581690)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 581658)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 583725)
         (if.eq?.ret.const . #t)
         (push.const . import)
         (push.const . "duplicate import identifiers")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 584796))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 584829)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 584739))
       (push.iloc 2 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 586811)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 586819)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 586778))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 579624)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 579604))
     (push)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 579589))
   (touch.gloc.of import-top-level-bindings)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 588834)
   (apply.gloc.of import-top-level-bindings "./boot/macro/library.scm" . 588807))
 (set.gloc.of expand-import)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (call
       (touch.gloc.of generate-library-id)
       (push.iloc.0 . 0)
       (apply.gloc.of generate-library-id "./boot/macro/library.scm" . 592919))
     (push)
     (extend . 1)
     (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 593962))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 593942)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . pending)
     (if.eq?
       (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 596005))
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 595984)
       (push.const . library)
       (push.const . "encountered cyclic dependencies")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 597008))
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 601128))
         (push)
         (push.iloc 2 . 0)
         (push.const . pending)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 601107))
       (push.close
         (0 0)
         (touch.gloc.of load-scheme-library)
         (push.iloc 3 . 0)
         (push.const . #f)
         (apply.gloc.of load-scheme-library "./boot/macro/library.scm" . 603155))
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 605233))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 605213)
         (const . pending)
         (if.not.eq?.ret.const . #f)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 606253))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 606232))
       (apply.gloc.of dynamic-wind "./boot/macro/library.scm" . 599056))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;require-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 591875))
((call
   (push.const . equal?)
   (push.subr.gloc.of make-core-hashtable 1 "./boot/macro/library.scm" . 610333)
   (extend . 1)
   (ret.close
     (1 0 . unify-import-bindings)
     (push.close
       (1 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 613397)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of values "./boot/macro/library.scm" . 613390))
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 615452)
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/library.scm" . 612359)))
 (set.gloc.of unify-import-bindings)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of scheme-library-versions)
       (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 620591))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 620570))
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 621594))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of unify-import-bindings)
     (push.iloc.0 . 2)
     (apply.gloc.of unify-import-bindings "./boot/macro/library.scm" . 621630))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 621573))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;intern-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 618497))
((close
   (1 0)
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 625693))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of core-hashtable-delete! "./boot/macro/library.scm" . 625669))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;unintern-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 623617))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 640018))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 641052)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 641042))
   (if.true
     (touch.gloc.of loop\x60;8)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 642072)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 642095)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 642066))
   (touch.gloc.of loop\x60;8)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 644120)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 644136)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 644114))
 (set.gloc.of loop\x60;8)
 (close
   (1 0 . permute-env)
   (touch.gloc.of loop\x60;8)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 637977)
   (push.const)
   (push.const)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 637961))
 (set.gloc.of permute-env\x60;2)
 (close
   (2 0 . expand-top-level-program)
   (extend.unbound . 1)
   (push.const \x2E;R6RS-TOP)
   (enclose . 1)
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 635909)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 635909)
     (if.false.ret)
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 635909)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;caar 1 "./boot/macro/library.scm" . 635909)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 635909))
   (if.true
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 635909)
     (extend . 2)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 635909))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 635909))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 635909))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 635909))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 635909))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 4)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 635909)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 635909)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
           (if.eq?.ret.const . #t)
           (push.const . "top-level program")
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 635909))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 635909))
         (push.iloc 2 . 3)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 635909)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 635909))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 635909))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #t)
     (push.subr.gloc.of core-hashtable-copy 2 "./boot/macro/library.scm" . 635909)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 635909)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 635909)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 635909)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 635909))
       (push.iloc 2 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 635909)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 635909))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 4 . 2)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.const . #f)
       (call
         (touch.gloc.of expand-top-level-program-body)
         (push.iloc 8 . 0)
         (push.iloc 5 . 0)
         (push.iloc 5 . 1)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of permute-env\x60;2)
             (push.iloc 3 . 0)
             (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 635909))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 635909))
         (push)
         (call
           (touch.gloc.of permute-env\x60;2)
           (push.iloc 2 . 0)
           (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 635909))
         (push)
         (apply.gloc.of expand-top-level-program-body "./boot/macro/library.scm" . 635909))
       (push)
       (push.iloc 4 . 3)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 635909))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 635909))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 635909))
   (push.const . "top-level program")
   (push.const . "expected import form and top-level body")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.1 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 635909))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 635909))
 (set.gloc.of expand-top-level-program)
 (ret.const.unspec))
((close
   (3 0 . check-duplicate-definition)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 714782))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 714765))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 715816))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 715799))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 716822)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 718894)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 718885)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 720942)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 723027)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 723000)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 723000))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 724024))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 721958))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 727094))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 728118))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 726052))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 729110)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 731182)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 731173)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 733230)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 735315)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 735288)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 735288))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 736312))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 734246))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 739409)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 739382)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 739382))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 740433)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 740406)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 740406))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 738340))
   (push.const . "top-level program")
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 742422))
 (set.gloc.of check-duplicate-definition\x60;2)
 (close
   (1 0)
   (push.const . \x2E;require-scheme-library)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 749591)
   (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 749591))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (8 0 . expand-top-level-program-body)
   (extend.unbound . 6)
   (push.const)
   (push.close
     (2 0 . extend-env!)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 703502))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/library.scm" . 704543))
       (set.iloc 1 . 0)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 705567)
       (push.iloc 2 . 6)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 705555))
     (set.iloc 2 . 6)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 706601)
       (push.iloc 3 . 6)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 706591))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 706569))
   (push.close
     (2 0 . extend-libenv!)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 710690)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 710678))
     (set.iloc 2 . 7)
     (ret.const.unspec))
   (push.close+
     (4 0 . rewrite-body)
     (call
       (touch.gloc.of check-duplicate-definition\x60;2)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of check-duplicate-definition\x60;2 "./boot/macro/library.scm" . 746505))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 6)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 747550))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn3.1\x60;3)
       (push.iloc 3 . 5)
       (apply.gloc.of map "./boot/macro/library.scm" . 749586))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 754756)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 755761)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 755755)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 755750)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 756787)
             (push.iloc 6 . 6)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 756774))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 757789))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 755739))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 755739))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 755739))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 753682))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 763944))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 768069)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 768059))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 768054)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 769102)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 769110)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 769078))
             (ret.const.unspec))
           (push.iloc 5 . 7)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 770096)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 767014))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 771110))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 763926)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 763926)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 763926)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 773178)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 773172)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 773167)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 775217)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . template)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 777257)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 777257)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 777257))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . procedure)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 778281)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 778281))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 774193)
           (const . variable)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 779305)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 779305))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 780335))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 763926))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 763926)
       (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 763926))
     (push)
     (extend . 3)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 782361))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 783392))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 784406))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 786497)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 786505)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 786516))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 786469))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 787485))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 789551)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 791642)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 791612))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 792636))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 790575))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 788509))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 794637)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 794637)
     (subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 794637)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 794637))
   (enclose . 4)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 801828)
   (set.iloc 0 . 4)
   (call
     (push.const . 0)
     (extend . 1)
     (ret.close
       (0 0)
       (n+.iloc (1 . 0) 1 "./boot/macro/library.scm" . 806933)
       (set.iloc 1 . 0)
       (push.const . ".e~a")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 807963)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 807947)))
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 4)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 810055)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 810011))
     (push.iloc.1 . 4)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 809989))
   (extend.enclose
     (4 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 813086)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 813101)
       (push.iloc.0 . 3)
       (apply.iloc+ (2 . 3) "./boot/macro/library.scm" . 813067))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 814123)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 814144)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 814135))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 6)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 815150)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 815134))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 6)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 817185))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 817179))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdar 1 "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cddar 1 "./boot/macro/library.scm" . 819227)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;cdddar 1 "./boot/macro/library.scm" . 819227)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (subr.gloc.of \x2E;list? 1 "./boot/macro/library.scm" . 819227)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 819227)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 819227))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;caddar 1 "./boot/macro/library.scm" . 819227)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cadar 1 "./boot/macro/library.scm" . 819227)
           (extend . 3)
           (call
             (push.iloc 4 . 4)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 819227)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 819227)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 819227))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 819227)
             (push.iloc.1 . 1)
             (push.iloc 6 . 6)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 819227))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 819227))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 819227))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 819227)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 819227))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 819227)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 819227))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 819227))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 819227)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 6)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 819227))
               (push)
               (apply.iloc (6 . 1) "./boot/macro/library.scm" . 819227))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 819227)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 819227))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 819227))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 819227))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 819227)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 819227))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 839749)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 839733))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 839728)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 839762)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 839718))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 4)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 840787)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 840738)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 841826)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 841762))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 842792)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 843847)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 843816))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 1) "./boot/macro/library.scm" . 844831))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 845875))
           (push)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 845855))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 846885)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 846919))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 846879))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 848957)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 848935))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 848969)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 848923))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 849951))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 851999))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 853066)
           (push.iloc 5 . 6)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 853044))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 6)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 855098)
             (push.iloc 5 . 6)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 855083))
           (push)
           (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 855115)
           (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 855075)
           (push.iloc 2 . 1)
           (push.iloc 2 . 2)
           (push.iloc 2 . 3)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 855069))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 815122))
       (push.const . \x2E;define)
       (call (apply.iloc (3 . 5) "./boot/macro/library.scm" . 857138))
       (push)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 857156)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/library.scm" . 857121)
       (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 857168)
       (push.cons)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 857115))
     (push.const . \x2E;define)
     (call (apply.iloc (2 . 5) "./boot/macro/library.scm" . 859177))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 859195)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/library.scm" . 859160)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 859207)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 859154))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 6)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 811030))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 811013))
 (set.gloc.of expand-top-level-program-body)
 (ret.const.unspec))

;
((close
   (2 0 . extend-env)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/synenv.scm" . 9225))
 (set.gloc.of extend-env)
 (ret.const.unspec))
((close
   (2 0 . env-lookup)
   (call
     (iloc.0 . 1)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error: env-lookup: expect symbol but got ~s")
     (push.iloc.0 . 1)
     (apply.gloc.of scheme-error "./boot/macro/synenv.scm" . 14345))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 15372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of import?)
       (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 17441)
       (apply.gloc.of import? "./boot/macro/synenv.scm" . 17432))
     (if.true
       (push.cddr.iloc (0 . 0) "./boot/macro/synenv.scm" . 18470)
       (extend . 1)
       (subr.gloc.of current-macro-environment 0)
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 19482))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of cdr "./boot/macro/synenv.scm" . 21528))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 23564))
 (set.gloc.of env-lookup)
 (ret.const.unspec))
((close
   (2 0 . env-delete!)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 27660)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of set-car! 2 "./boot/macro/synenv.scm" . 29713)
     (push.iloc.0 . 0)
     (push.const . no-use)
     (ret.subr.gloc.of set-cdr! "./boot/macro/synenv.scm" . 30737))
   (ret.const.unspec))
 (set.gloc.of env-delete!)
 (ret.const.unspec))
((close
   (2 0 . free-id=?)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synenv.scm" . 34836))
   (push)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/synenv.scm" . 34880))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of lookup-lexical-name)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 35858))
   (push)
   (call
     (iloc.1 . 1)
     (if.symbol?
       (touch.gloc.of lookup-lexical-name)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 37910))
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.1 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/synenv.scm" . 38955))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 38934))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 40989))
     (push)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 42013))
     (push)
     (extend . 2)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #t)
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 44051))
     (if.true.ret)
     (touch.gloc.of unbound?)
     (push.iloc.0 . 1)
     (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 45075))
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 46110))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.1 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 47134))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 48158))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.1 . 1)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 49182))
   (push)
   (extend . 4)
   (call
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 0)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 50205))
     (push)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/synenv.scm" . 50223))
     (if.not.eq?.ret.const . #f)
     (call
       (call
         (touch.gloc.of unbound?)
         (push.iloc.0 . 0)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 51228))
       (if.true.ret)
       (push.iloc.0 . 0)
       (iloc.1 . 0)
       (ret.eq? "./boot/macro/synenv.scm" . 51249))
     (if.false.ret)
     (call
       (call
         (touch.gloc.of unbound?)
         (push.iloc.0 . 2)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 52252))
       (if.true.ret)
       (push.iloc.0 . 2)
       (iloc.1 . 0)
       (ret.eq? "./boot/macro/synenv.scm" . 52273))
     (if.false.ret)
     (call
       (call
         (touch.gloc.of unbound?)
         (push.iloc.0 . 1)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 53276))
       (if.true.ret)
       (push.iloc.0 . 1)
       (iloc.1 . 1)
       (ret.eq? "./boot/macro/synenv.scm" . 53297))
     (if.false.ret)
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 3)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 54300))
     (if.true.ret)
     (push.iloc.0 . 3)
     (iloc.1 . 1)
     (ret.eq? "./boot/macro/synenv.scm" . 54321))
   (if.true.ret)
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 55325))
   (if.true.ret.const . #f)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 0)
   (iloc.0 . 3)
   (ret.eq? "./boot/macro/synenv.scm" . 57372))
 (set.gloc.of free-id=?)
 (ret.const.unspec))
((close
   (1 0 . make-import)
   (push.const . import)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 61445))
 (set.gloc.of make-import)
 (ret.const.unspec))
((close (0 0 . make-unbound) (ret.const unbound)) (set.gloc.of make-unbound) (ret.const.unspec))
((close
   (1 0 . make-out-of-context)
   (iloc.0 . 0)
   (if.true (push.const . out-of-context) (iloc.0 . 0) (ret.cons "./boot/macro/synenv.scm" . 70665))
   (ret.const out-of-context . #f))
 (set.gloc.of make-out-of-context)
 (ret.const.unspec))
((close
   (1 0 . make-pattern-variable)
   (push.const . pattern-variable)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 75781))
 (set.gloc.of make-pattern-variable)
 (ret.const.unspec))
((close
   (2 0 . make-macro)
   (push.const . macro)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 79877))
 (set.gloc.of make-macro)
 (ret.const.unspec))
((close
   (2 0 . make-macro-variable)
   (push.const . macro-variable)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 83973))
 (set.gloc.of make-macro-variable)
 (ret.const.unspec))
((close
   (1 0 . make-special)
   (push.const . special)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 88069))
 (set.gloc.of make-special)
 (ret.const.unspec))
((close
   (1 0 . import?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 93199)
   (const . import)
   (ret.eq? "./boot/macro/synenv.scm" . 93194))
 (set.gloc.of import?)
 (ret.const.unspec))
((close
   (1 0 . unbound?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 98319)
   (const . unbound)
   (ret.eq? "./boot/macro/synenv.scm" . 98314))
 (set.gloc.of unbound?)
 (ret.const.unspec))
((close
   (1 0 . out-of-context?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 103439)
   (const . out-of-context)
   (ret.eq? "./boot/macro/synenv.scm" . 103434))
 (set.gloc.of out-of-context?)
 (ret.const.unspec))
((close
   (1 0 . macro?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 108563)
   (const . macro)
   (if.eq?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 109587)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 109582))
 (set.gloc.of macro?)
 (ret.const.unspec))
((close
   (1 0 . macro-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 114703)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 114698))
 (set.gloc.of macro-variable?)
 (ret.const.unspec))
((close
   (1 0 . pattern-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 119823)
   (const . pattern-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 119818))
 (set.gloc.of pattern-variable?)
 (ret.const.unspec))
((close
   (1 0 . special?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 124943)
   (const . special)
   (ret.eq? "./boot/macro/synenv.scm" . 124938))
 (set.gloc.of special?)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 129047)
   (push.const . "unquote appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 129029))
 (set.gloc.of unexpected-unquote)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote-splicing)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 133143)
   (push.const . "unquote-splicing appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 133125))
 (set.gloc.of unexpected-unquote-splicing)
 (ret.const.unspec))
((close
   (2 0 . unexpected-auxiliary-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 137239)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 137221))
 (set.gloc.of unexpected-auxiliary-syntax)
 (ret.const.unspec))
((close
   (2 0 . unexpected-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 141335)
   (push.const . "misplaced syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 141317))
 (set.gloc.of unexpected-syntax)
 (ret.const.unspec))
((subr.gloc.of make-core-hashtable 0 "./boot/macro/synenv.scm" . 143378)
 (set.gloc.of core-env)
 (ret.const.unspec))
((close
   (2 0 . init-core-macro)
   (push.gloc.of core-env)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (subr.gloc.of core-hashtable-set! 3 "./boot/macro/synenv.scm" . 149511)
   (push.gloc.of core-env)
   (call
     (touch.gloc.of core-primitive-name)
     (push.iloc.0 . 0)
     (apply.gloc.of core-primitive-name "./boot/macro/synenv.scm" . 150565))
   (push)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 150535))
 (set.gloc.of init-core-macro\x60;1)
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . lambda)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-lambda)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 152615))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 152579))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . quote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 153639))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 153603))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . if)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-if)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 154663))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 154627))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . set!)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-set!)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 155687))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 155651))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 156711))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 156675))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 157735))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 157699))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 158759))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 158723))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . begin)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-begin)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 159783))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 159747))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 160807))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 160771))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . quasiquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quasiquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 161831))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 161795))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 162855))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 162819))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 163879))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 163843))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 164903))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 164867))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . cond)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-cond)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 165927))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 165891))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 166951))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 166915))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . do)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-do)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 167975))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 167939))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . and)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-and)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 168999))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 168963))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . or)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-or)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 170023))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 169987))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 171047))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 171011))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . library)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-library)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 172071))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 172035))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define-macro)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-macro)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 173095))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 173059))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let*-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 174119))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 174083))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 175143))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 175107))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 176167))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 176131))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax-case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 177191))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 177155))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . identifier-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-identifier-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 178215))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 178179))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . assert)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-assert)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 179239))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 179203))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . unquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 180263))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 180227))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . unquote-splicing)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote-splicing)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 181287))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 181251))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax-rules)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 182311))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 182275))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . else)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 183335))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 183299))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . =>)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 184359))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 184323))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . ...)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 185383))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 185347))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . _)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 186407))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 186371))
 (touch.gloc.of init-core-macro\x60;1)
 (push.const . import)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-import)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 187431))
 (push)
 (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 187395))
((push.gloc.of core-env)
 (push.const . lambda)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 189473)
 (set.gloc.of denote-lambda)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . begin)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 190497)
 (set.gloc.of denote-begin)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 191521)
 (set.gloc.of denote-define)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 192545)
 (set.gloc.of denote-define-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 193569)
 (set.gloc.of denote-let-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 194593)
 (set.gloc.of denote-letrec-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-macro)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 195617)
 (set.gloc.of denote-define-macro)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . library)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 196641)
 (set.gloc.of denote-library)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 197665)
 (set.gloc.of denote-quasiquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 198689)
 (set.gloc.of denote-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . if)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 199713)
 (set.gloc.of denote-if)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . set!)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 200737)
 (set.gloc.of denote-set!)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 201761)
 (set.gloc.of denote-unquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 202785)
 (set.gloc.of denote-unquote-splicing)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 203809)
 (set.gloc.of denote-let)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 204833)
 (set.gloc.of denote-letrec)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 205857)
 (set.gloc.of denote-let*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . cond)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 206881)
 (set.gloc.of denote-cond)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 207905)
 (set.gloc.of denote-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . do)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 208929)
 (set.gloc.of denote-do)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . and)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 209953)
 (set.gloc.of denote-and)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . or)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 210977)
 (set.gloc.of denote-or)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 212001)
 (set.gloc.of denote-letrec*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 213025)
 (set.gloc.of denote-let*-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 214049)
 (set.gloc.of denote-let-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 215073)
 (set.gloc.of denote-syntax-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 216097)
 (set.gloc.of denote-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 217121)
 (set.gloc.of denote-syntax-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 218145)
 (set.gloc.of denote-syntax-rules)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . else)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 219169)
 (set.gloc.of denote-else)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . =>)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 220193)
 (set.gloc.of denote-=>)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . import)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 221217)
 (set.gloc.of denote-import)
 (ret.const.unspec))
((close
   (2 0 . denote-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of macro?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 226322))
   (push)
   (apply.gloc.of macro? "./boot/macro/synenv.scm" . 226314))
 (set.gloc.of denote-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-special?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of special?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 231444))
   (push)
   (apply.gloc.of special? "./boot/macro/synenv.scm" . 231434))
 (set.gloc.of denote-special?)
 (ret.const.unspec))
((close
   (2 0 . denote-lambda?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 236559))
   (push)
   (gloc.of denote-lambda)
   (ret.eq? "./boot/macro/synenv.scm" . 236554))
 (set.gloc.of denote-lambda?)
 (ret.const.unspec))
((close
   (2 0 . denote-begin?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 241679))
   (push)
   (gloc.of denote-begin)
   (ret.eq? "./boot/macro/synenv.scm" . 241674))
 (set.gloc.of denote-begin?)
 (ret.const.unspec))
((close
   (2 0 . denote-let?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 246799))
   (push)
   (gloc.of denote-let)
   (ret.eq? "./boot/macro/synenv.scm" . 246794))
 (set.gloc.of denote-let?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 251919))
   (push)
   (gloc.of denote-define-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 251914))
 (set.gloc.of denote-define-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-let-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 257039))
   (push)
   (gloc.of denote-let-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 257034))
 (set.gloc.of denote-let-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-letrec-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 262159))
   (push)
   (gloc.of denote-letrec-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 262154))
 (set.gloc.of denote-letrec-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-define?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 267279))
   (push)
   (gloc.of denote-define)
   (ret.eq? "./boot/macro/synenv.scm" . 267274))
 (set.gloc.of denote-define?)
 (ret.const.unspec))
((close
   (2 0 . denote-quote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 272399))
   (push)
   (gloc.of denote-quote)
   (ret.eq? "./boot/macro/synenv.scm" . 272394))
 (set.gloc.of denote-quote?)
 (ret.const.unspec))
((close
   (2 0 . denote-quasiquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 277519))
   (push)
   (gloc.of denote-quasiquote)
   (ret.eq? "./boot/macro/synenv.scm" . 277514))
 (set.gloc.of denote-quasiquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 282639))
   (push)
   (gloc.of denote-unquote)
   (ret.eq? "./boot/macro/synenv.scm" . 282634))
 (set.gloc.of denote-unquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote-splicing?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 287759))
   (push)
   (gloc.of denote-unquote-splicing)
   (ret.eq? "./boot/macro/synenv.scm" . 287754))
 (set.gloc.of denote-unquote-splicing?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 292879))
   (push)
   (gloc.of denote-define-macro)
   (ret.eq? "./boot/macro/synenv.scm" . 292874))
 (set.gloc.of denote-define-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-syntax-rules?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 297999))
   (push)
   (gloc.of denote-syntax-rules)
   (ret.eq? "./boot/macro/synenv.scm" . 297994))
 (set.gloc.of denote-syntax-rules?)
 (ret.const.unspec))
((close
   (2 0 . denote-else?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 303119))
   (push)
   (gloc.of denote-else)
   (ret.eq? "./boot/macro/synenv.scm" . 303114))
 (set.gloc.of denote-else?)
 (ret.const.unspec))
((close
   (2 0 . denote-=>?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 308239))
   (push)
   (gloc.of denote-=>)
   (ret.eq? "./boot/macro/synenv.scm" . 308234))
 (set.gloc.of denote-=>?)
 (ret.const.unspec))
((close
   (2 0 . denote-set!?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 313359))
   (push)
   (gloc.of denote-set!)
   (ret.eq? "./boot/macro/synenv.scm" . 313354))
 (set.gloc.of denote-set!?)
 (ret.const.unspec))
((push.const . \x2E;LIST)
 (const . \x2E;list)
 (push.cons)
 (push.const . \x2E;CONS)
 (const . \x2E;cons)
 (push.cons)
 (push.const . \x2E;CONS*)
 (const . \x2E;cons*)
 (push.cons)
 (push.const . \x2E;APPEND)
 (const . \x2E;append)
 (push.cons)
 (push.const . \x2E;VECTOR)
 (const . \x2E;vector)
 (push.cons)
 (push.const . \x2E;LIST->VECTOR)
 (const . \x2E;list->vector)
 (push.cons)
 (push.const . \x2E;EQ?)
 (const . \x2E;eq?)
 (push.cons)
 (push.const . \x2E;EQV?)
 (const . \x2E;eqv?)
 (push.cons)
 (push.const . \x2E;MEMQ)
 (const . \x2E;memq)
 (push.cons)
 (push.const . \x2E;MEMV)
 (const . \x2E;memv)
 (push.cons)
 (push.const . \x2E;CALL-WITH-VALUES)
 (const . \x2E;call-with-values)
 (push.cons)
 (push.const . \x2E;APPLY)
 (const . \x2E;apply)
 (push.cons)
 (push.const . \x2E;CDR)
 (const . \x2E;cdr)
 (push.cons)
 (push.const . \x2E;IDENTIFIER?)
 (const . \x2E;identifier?)
 (push.cons)
 (push.const . \x2E;MAKE-VARIABLE-TRANSFORMER)
 (const . \x2E;make-variable-transformer)
 (push.cons)
 (push.const . \x2E;ASSERTION-VIOLATION)
 (const . \x2E;assertion-violation)
 (push.cons)
 (push.const . \x2E;UNSPECIFIED)
 (const . \x2E;unspecified)
 (push.cons)
 (push.const . \x2E;QUOTE)
 (gloc.of denote-quote)
 (push.cons)
 (push.const . \x2E;LET)
 (gloc.of denote-let)
 (push.cons)
 (push.const . \x2E;LETREC*)
 (gloc.of denote-letrec*)
 (push.cons)
 (push.const . \x2E;BEGIN)
 (gloc.of denote-begin)
 (push.cons)
 (push.const . \x2E;LAMBDA)
 (gloc.of denote-lambda)
 (push.cons)
 (push.const . \x2E;IF)
 (gloc.of denote-if)
 (push.cons)
 (push.const . \x2E;SET!)
 (gloc.of denote-set!)
 (push.cons)
 (push.const . \x2E;OR)
 (gloc.of denote-or)
 (push.cons)
 (push.const . \x2E;COND)
 (gloc.of denote-cond)
 (push.cons)
 (push.const . \x2E;ELSE)
 (gloc.of denote-else)
 (push.cons)
 (push.const . \x2E;DEFINE-SYNTAX)
 (gloc.of denote-define-syntax)
 (push.cons)
 (push.const . \x2E;SYNTAX)
 (gloc.of denote-syntax)
 (push.cons)
 (push.const . \x2E;SYNTAX-CASE)
 (gloc.of denote-syntax-case)
 (push.cons)
 (subr.gloc.of list 30 "./boot/macro/synenv.scm" . 316419)
 (set.gloc.of private-primitives-environment)
 (ret.const.unspec))
((push.gloc.of core-env)
 (ret.subr.gloc.of current-macro-environment "./boot/macro/synenv.scm" . 351233))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/compile.scm" . 5147))
 (set.gloc.of ht-local-closures)
 (ret.const.unspec))
((close
   (1 0 . local-closure?)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/compile.scm" . 9248))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 9228)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 10273)
     (push.const stack)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 10267))
   (ret.const . #f))
 (set.gloc.of local-closure?)
 (ret.const.unspec))
((close
   (1 0)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 16413)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 17435)
   (const . lambda)
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of local-closure?)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 18470)
     (apply.gloc.of local-closure? "./boot/compile.scm" . 18454))
   (if.false.ret)
   (call
     (touch.gloc.of ht-local-closures)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 19499))
   (push)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 19519)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 19478))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0 . collect-local-closure)
   (push.gloc.of \x2E;fn2.1\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/compile.scm" . 15365))
 (set.gloc.of collect-local-closure)
 (ret.const.unspec))
((close
   (1 0 . make-application-comment)
   (subr.gloc.of backtrace 0 "./boot/compile.scm" . 24585)
   (if.true
     (subr.gloc.of current-source-comments 0 "./boot/compile.scm" . 25616)
     (if.true
       (subr.gloc.of current-source-comments 0)
       (push)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 27676)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 29733)
         (if.true
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . \x2E;&SOURCE-PATH)
           (push.const . #f)
           (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 30766)
           (push.iloc.0 . 0)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 30834)
           (ret.subr.gloc.of \x2E;cons* "./boot/compile.scm" . 29729))
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . \x2E;&SOURCE-PATH)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 31784)
         (iloc.0 . 0)
         (ret.cons "./boot/compile.scm" . 29729))
       (push.iloc.1 . 0)
       (ret.subr.gloc.of list "./boot/compile.scm" . 33820))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 35856))
   (ret.const))
 (set.gloc.of make-application-comment)
 (ret.const.unspec))
((close
   (1 0 . make-closure-comment)
   (call
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 40977))
     (if.false.ret)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 42021))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of core-hashtable-ref "./boot/compile.scm" . 42001))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/compile.scm" . 40965))
   (ret.const))
 (set.gloc.of make-closure-comment)
 (ret.const.unspec))
((close
   (1 0 . top-level-subr)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 49162)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 50193)
   (subr.gloc.of subr? 1 "./boot/compile.scm" . 50186)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 51210))
 (set.gloc.of top-level-subr)
 (ret.const.unspec))
((close
   (1 0 . top-level-value-or-false)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 56330)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 57354))
 (set.gloc.of top-level-value-or-false)
 (ret.const.unspec))
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 62479)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 62504)
       (apply.gloc.of formals->list "./boot/compile.scm" . 62489))
     (ret.cons "./boot/compile.scm" . 62473))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/compile.scm" . 64533))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . make-formals-operand)
   (push.iloc.0 . 1)
   (subr.gloc.of list? 1 "./boot/compile.scm" . 68620)
   (if.true
     (push.iloc.0 . 1)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 68642)
     (push.const . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 68636))
   (iloc.0 . 1)
   (if.pair?
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 69669)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/compile.scm" . 69666)
     (push.const . 1)
     (ret.subr.gloc.of list "./boot/compile.scm" . 69660))
   (ret.const 0 1))
 (set.gloc.of make-formals-operand)
 (ret.const.unspec))
((close
   (2 0 . make-iloc-operand)
   (extend.enclose+
     (2 0 . loop1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 76824)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 76816)
     (if.true
       (push.iloc.0 . 1)
       (call
         (extend.enclose+
           (2 0 . loop2)
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 79905)
           (iloc 4 . 0)
           (if.eq? (ret.iloc 0 . 1))
           (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 81955)
           (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 81966)
           (apply.iloc+ (1 . 0) "./boot/compile.scm" . 81948))
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 78888)
         (push.const . 0)
         (apply.iloc+ (0 . 0) "./boot/compile.scm" . 78870))
       (ret.cons "./boot/compile.scm" . 75783))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 82967)
     (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 82978)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 82960))
   (push.iloc.1 . 1)
   (push.const . 0)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 74757))
 (set.gloc.of make-iloc-operand)
 (ret.const.unspec))
((close
   (3 0 . iloc-iota)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 89102)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/compile.scm" . 90137)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of + 2 "./boot/compile.scm" . 90167)
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 90131))
   (push.n+.iloc (1 . 2) -1 "./boot/compile.scm" . 88087)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 88069))
 (set.gloc.of iloc-iota)
 (ret.const.unspec))
((close
   (2 0 . cte-extend-iloc)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "./boot/compile.scm" . 94213))
 (set.gloc.of cte-extend-iloc)
 (ret.const.unspec))
((close
   (2 0 . iloc?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 101405)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 101397)
     (if.true.ret)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 102427)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 102421))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 99338))
 (set.gloc.of iloc?)
 (ret.const.unspec))
((close
   (1 0 . immediate-literal?)
   (push.iloc.0 . 0)
   (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 106505)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of char? 1 "./boot/compile.scm" . 106517)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of boolean? 1 "./boot/compile.scm" . 106527)
   (if.true.ret)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 107549)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 107574)
   (ret.subr.gloc.of symbol? "./boot/compile.scm" . 107565))
 (set.gloc.of immediate-literal?)
 (ret.const.unspec))
((close
   (2 0 . compile-touch)
   (call
     (iloc.0 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 113686)
     (if.true.ret.const . #f)
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 114710))
     (push)
     (ret.subr.gloc.of not "./boot/compile.scm" . 114705))
   (if.true
     (push.const . touch.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 112651)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 112651))
   (ret.const))
 (set.gloc.of compile-touch)
 (ret.const.unspec))
((close
   (4 0 . compile-lambda-helper)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/compile.scm" . 120849))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of cte-extend-iloc)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 121874))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of make-formals-operand)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of make-formals-operand "./boot/compile.scm" . 122900))
   (push)
   (push.iloc 2 . 2)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 122892)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 123918))
   (ret.cons "./boot/compile.scm" . 121863))
 (set.gloc.of compile-lambda-helper)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 128027))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of cons)
     (push.gloc.of =)
     (push.gloc.of <)
     (push.gloc.of <=)
     (push.gloc.of >)
     (push.gloc.of >=)
     (push.gloc.of eq?)
     (push.gloc.of null?)
     (push.gloc.of pair?)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of eqv?)
     (push.gloc.of equal?)
     (push.subr.gloc.of list 18 "./boot/compile.scm" . 129039)
     (apply.gloc.of for-each "./boot/compile.scm" . 128005))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 130053))
 (set.gloc.of ht-special-subr-expression)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 133123)
 (set.gloc.of alist-special-binary-subr)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 136195)
 (set.gloc.of alist-special-binary-subr-negate)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 139267)
 (set.gloc.of alist-special-binary-subr-iloc)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 142339)
 (set.gloc.of alist-special-binary-subr-iloc-negate)
 (ret.const.unspec))
((close
   (4 0 . compile-anonymous)
   (iloc.0 . 2)
   (if.true
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 150568)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 150545))
     (push)
     (push.const . ret.subr.gloc.of)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 150603)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 149513)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 149513)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 149513))
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151592)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 151569))
   (push)
   (push.const . subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 151623)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151643)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 151635)
   (push.iloc.0 . 3)
   (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 149513)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 149513)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 149513))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (4 0 . compile-subr-expression)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 153620))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 154660)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 154643)
   (extend . 1)
   (push.gloc.of ht-special-subr-expression)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 155661)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 156699)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (iloc 2 . 2)
         (if.true.ret.const)
         (iloc 2 . 3)
         (if.true
           (push.const . ret.const.unspec)
           (push.subr.gloc.of list 1 "./boot/compile.scm" . 159789)
           (ret.subr.gloc.of list "./boot/compile.scm" . 159783))
         (push.const . const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 160813)
         (ret.subr.gloc.of list "./boot/compile.scm" . 160807))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 161824))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 162843)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of pair?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 165943)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 165923))
           (push)
           (push.const . ret.pair?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 164894)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 164894))
         (push.iloc.0 . 0)
         (gloc.of null?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 167991)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 167971))
           (push)
           (push.const . ret.null?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 166942)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 166942))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 170015))
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 171043)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 171036))
       (if.true
         (iloc 2 . 2)
         (if.true.ret.const)
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 175178)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 175159))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 174121)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 174121))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 177226)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 177207))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 176169)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 176169))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 179275)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 179256))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 178217)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 178217))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 181323)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 181304))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 180265)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 180265))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 183338))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 184348))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 185371)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of cons)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 188469)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 188451))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 188508)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 188488))
           (push)
           (push.const . ret.cons)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 187422)
           (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 187422)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 187422))
         (push.iloc.0 . 0)
         (gloc.of eq?)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 190517)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 190499))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 190556)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 190536))
           (push)
           (push.const . ret.eq?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 189470)
           (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 189470)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 189470))
         (push.iloc.0 . 0)
         (gloc.of eqv?)
         (if.eq?
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 192574)
           (extend . 1)
           (call
             (call
               (touch.gloc.of immediate-literal?)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 192555)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193577))
             (if.true.ret)
             (touch.gloc.of immediate-literal?)
             (push.iloc.0 . 0)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193603))
           (if.true
             (call
               (touch.gloc.of compile-argument)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 194619)
               (push.iloc 3 . 1)
               (apply.gloc.of compile-argument "./boot/compile.scm" . 194601))
             (push)
             (call
               (touch.gloc.of compile-expression)
               (push.iloc 3 . 0)
               (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 194658)
               (push.iloc 3 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 194638))
             (push)
             (push.const . ret.eq?)
             (iloc 2 . 0)
             (push.cons)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 193569)
             (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 193569)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 193569))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 195621))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 197663))
       (push.iloc.0 . 0)
       (push.gloc.of alist-special-binary-subr)
       (subr.gloc.of assq 2 "./boot/compile.scm" . 198687)
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 199723)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 199742)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 201787)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 201817))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 201858)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 201853)
             (ret.subr.gloc.of values "./boot/compile.scm" . 201835))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 202811)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 202841))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 202882)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 202877)
             (ret.subr.gloc.of values "./boot/compile.scm" . 202859))
           (push.const . #f)
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 203835))
         (push.close
           (3 0)
           (iloc.0 . 2)
           (if.true
             (push.iloc.0 . 2)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 204857))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 204841)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 204841))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 205866))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 206894))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 206937)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 206932)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 206982))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 205865)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 205865)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 205865))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 207914))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 208942))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 208985)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 208980)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 209037))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 207913)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 207913)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 207913))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 209967))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 199711))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 213035)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 213054)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 214085)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 214115))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 214133))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 215109)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 215139))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 215157))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 216133))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 218163))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 217123)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 217123))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 219175))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 213023))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 221227)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 221246)
         (extend . 2)
         (call
           (push.iloc.0 . 1)
           (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 222250)
           (if.false.ret)
           (iloc.0 . 0)
           (if.not.symbol?.ret.const . #f)
           (touch.gloc.of iloc?)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of iloc? "./boot/compile.scm" . 222280))
         (if.true
           (push.const . n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 223281))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 223311)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 222241)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 222241))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 3)
         (push.iloc 2 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 224293))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 227359))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 3)
     (push.iloc.1 . 0)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 229396))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc 2 . 3)
   (push.iloc.1 . 0)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 230413))
 (set.gloc.of compile-subr-expression)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 234523))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of cons)
     (push.subr.gloc.of list 8 "./boot/compile.scm" . 235535)
     (apply.gloc.of for-each "./boot/compile.scm" . 234501))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 236549))
 (set.gloc.of ht-special-subr-argument)
 (ret.const.unspec))
((close
   (3 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243748)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 243725))
   (push)
   (push.const . push.subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 243784)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243804)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 243796)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 242695)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 242695)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 242695))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (2 0 . compile-subr-argument)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 245780))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 246820)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 246803)
   (extend . 1)
   (push.gloc.of ht-special-subr-argument)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 247821)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 248859)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (push.const . push.const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 249912)
         (ret.subr.gloc.of list "./boot/compile.scm" . 249906))
       (push.const . subr.gloc.of)
       (push.car.iloc (2 . 0) "./boot/compile.scm" . 251948)
       (push.const 0)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 250906)
       (push.const . push)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 251963)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 250906))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 252955)
     (if.null?
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 253983)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 253976))
       (if.true
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . push.car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 255059)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 255040))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 255006)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 255006))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . push.cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 256083)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 256064))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 256030)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 256030))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . push.cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 257109)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 257090))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 257054)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 257054))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . push.cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 258133)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 258114))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 258078)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 258078))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 259108))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 260120))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 261147)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of cons)
       (if.eq?
         (call
           (touch.gloc.of compile-argument)
           (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 263217)
           (push.iloc 2 . 1)
           (apply.gloc.of compile-argument "./boot/compile.scm" . 263199))
         (push)
         (call
           (touch.gloc.of compile-expression)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 263256)
           (push.iloc 2 . 1)
           (push.const . #f)
           (push.const . #f)
           (apply.gloc.of compile-expression "./boot/compile.scm" . 263236))
         (push)
         (push.const . push.cons)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 263281)
         (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 262170)
         (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 262170)
         (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 262170))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 265255)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 265274)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 266305))
             (if.false.ret)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 266322))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 266338))
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 267329))
             (if.false.ret)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 267346))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 267362))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 268353))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . push.n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 270388))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 269343)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 269343))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 271395))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 265243))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 273447)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 273466)
         (extend . 2)
         (call
           (call
             (touch.gloc.of iloc?)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 274470))
           (if.false.ret)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 274487))
         (if.true
           (push.const . push.n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 275506))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 275536)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 274461)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 274461))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 2 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 276513))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 278555))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 280596))
   (cdr.iloc (2 . 0) "./boot/compile.scm" . 281624)
   (if.null?
     (push.const . subr.gloc.of)
     (push.car.iloc (2 . 0) "./boot/compile.scm" . 282658)
     (push.const 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 281613)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 282673)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 281613))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 283665))
 (set.gloc.of compile-subr-argument)
 (ret.const.unspec))
((close
   (2 0 . compile-argument-each)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of append)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 288808)
       (apply.gloc.of apply "./boot/compile.scm" . 288794))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 291862)
     (call
       (touch.gloc.of compile-argument)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 290857)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 290839))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 291856))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 287749))
 (set.gloc.of compile-argument-each)
 (ret.const.unspec))
((close
   (2 0 . compile-argument)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 296995)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 296979))
     (if.true
       (touch.gloc.of compile-subr-argument)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-subr-argument "./boot/compile.scm" . 298003))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 299032)
     (const . lambda)
     (if.eq?
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 300086)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 300098)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 300110))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 300063))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of local-closure?)
         (push.iloc.1 . 0)
         (apply.gloc.of local-closure? "./boot/compile.scm" . 301081))
       (if.true
         (push.const . push.close+)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of list "./boot/compile.scm" . 302105))
       (push.const . push.close)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 303129))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 304152)
     (const . quote)
     (if.eq?
       (push.const . push.const)
       (cadr.iloc (0 . 0) "./boot/compile.scm" . 305188)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 304146))
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 307223))
     (push)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 307260)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 306194)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 306194))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (const . \x2E;&UNDEF)
     (if.eq?
       (push.const . push.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 309293)
       (ret.subr.gloc.of list "./boot/compile.scm" . 309287))
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 311319))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 312354))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 313375)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . push.iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 314418)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 314395))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . push.iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 315442)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 315419))
       (push.const . push.iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 316443))
     (push.const . push.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 311315)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 311315))
   (push.const . push.const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 318475))
 (set.gloc.of compile-argument)
 (ret.const.unspec))
((close
   (4 0 . compile-call)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 324624))
     (push)
     (push.const . apply)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 324661)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 323595)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 323595))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of iloc? "./boot/compile.scm" . 326675))
     (if.true
       (call
         (touch.gloc.of ht-local-closures)
         (apply.gloc.of ht-local-closures "./boot/compile.scm" . 327729))
       (push)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 327703)
       (if.true
         (push.const . apply.iloc+)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 3)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 328743))
         (push)
         (push.iloc.0 . 2)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 327699)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 327699))
       (push.const . apply.iloc)
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 329766))
       (push)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 327699)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 327699))
     (call
       (touch.gloc.of top-level-subr)
       (push.iloc.0 . 0)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 330771))
     (if.true
       (push.const . ret.subr.gloc.of)
       (push.iloc.0 . 0)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 330770)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 330770))
     (push.const . apply.gloc.of)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 332818)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 332818))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (push.const . apply)
   (iloc.0 . 2)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 334859))
 (set.gloc.of compile-call)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-begin)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 339985)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?
     (iloc.1 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 342045)
       (ret.subr.gloc.of list "./boot/compile.scm" . 342039))
     (ret.const))
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 343061)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 344098)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 344078))
   (touch.gloc.of compile-expression-seq)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 346126))
 (set.gloc.of compile-expression-begin)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-quote)
   (iloc.0 . 2)
   (if.true.ret.const)
   (iloc.0 . 3)
   (if.true
     (push.const . ret.const)
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 352269))
   (push.const . const)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 353293))
 (set.gloc.of compile-expression-quote)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-define)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 357413)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 357393))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 359454)
   (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 357381)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 358434)
       (ret.subr.gloc.of list "./boot/compile.scm" . 358428))
     (ret.const))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 357381))
 (set.gloc.of compile-expression-define)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-set!)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 363557)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 363537))
   (push)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 364578)
       (ret.subr.gloc.of list "./boot/compile.scm" . 364572))
     (ret.const))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of iloc?)
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 365589)
     (push.iloc.1 . 1)
     (apply.gloc.of iloc? "./boot/compile.scm" . 365582))
   (if.true
     (push.iloc.0 . 0)
     (push.const . set.iloc)
     (call
       (touch.gloc.of make-iloc-operand)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 366646)
       (push.iloc.1 . 1)
       (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 366627))
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 365581))
   (push.iloc.0 . 0)
   (call
     (subr.gloc.of backtrace 0 "./boot/compile.scm" . 368671)
     (if.true
       (touch.gloc.of compile-touch)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 368698)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-touch "./boot/compile.scm" . 368683))
     (ret.const))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 369711)
   (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 368654)
   (iloc.0 . 1)
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 368654)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 368654))
 (set.gloc.of compile-expression-set!)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-lambda)
   (call
     (touch.gloc.of compile-lambda-helper)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 373800)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 373812)
     (call
       (touch.gloc.of make-closure-comment)
       (push.iloc.0 . 0)
       (apply.gloc.of make-closure-comment "./boot/compile.scm" . 373824))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 373777))
   (push)
   (extend . 1)
   (iloc.1 . 2)
   (if.true.ret.const)
   (iloc.1 . 3)
   (if.true
     (push.const . ret.close)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 375821))
   (push.const . close)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 376845))
 (set.gloc.of compile-expression-lambda)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-let)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 380947)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 381988)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 381964))
   (call
     (touch.gloc.of collect-local-closure)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 384035)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 384012))
   (call
     (push.gloc.of car)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 385057)
     (apply.gloc.of map "./boot/compile.scm" . 385048))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of compile-argument-each)
     (call
       (push.gloc.of cadr)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 386111)
       (apply.gloc.of map "./boot/compile.scm" . 386101))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 386078))
   (push)
   (push.const . extend)
   (push.iloc.0 . 0)
   (subr.gloc.of length 1 "./boot/compile.scm" . 387113)
   (push.cons)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (1 . 0) "./boot/compile.scm" . 388152)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 388164))
     (push)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 388128))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 386068)
   (extend . 1)
   (iloc 2 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 389150))
 (set.gloc.of compile-expression-let)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (push.const . set.iloc)
   (iloc.0 . 0)
   (push.cons)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 426038)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 426038))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (4 0 . compile-expression-letrec*)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 393235)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 394276)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 394252))
   (push.iloc.0 . 0)
   (subr.gloc.of cdadr 1 "./boot/compile.scm" . 395283)
   (if.null?
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 396315)
     (extend . 1)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 397360)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 397354)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 397337))
     (push)
     (extend . 1)
     (call
       (cadr.iloc (1 . 0) "./boot/compile.scm" . 398371)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 398392)
       (const . lambda)
       (ret.eq? "./boot/compile.scm" . 398387))
     (if.true
       (call
         (touch.gloc.of collect-local-closure)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 399406)
         (apply.gloc.of collect-local-closure "./boot/compile.scm" . 399383))
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 400419)
       (extend . 1)
       (call
         (call
           (touch.gloc.of local-closure?)
           (push.iloc.0 . 0)
           (apply.gloc.of local-closure? "./boot/compile.scm" . 403497))
         (if.true (ret.const . extend.enclose+))
         (ret.const . extend.enclose))
       (push)
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 401473)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 401485)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 401497))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 401450))
       (push.cons)
       (call
         (touch.gloc.of compile-expression-seq)
         (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 402498)
         (push.iloc.1 . 0)
         (push.const . #f)
         (push.const . #t)
         (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 402474))
       (push.cons)
       (extend . 1)
       (iloc 4 . 3)
       (if.true (ret.iloc 0 . 0))
       (push.const . call)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 405547))
     (push.const . extend.unbound)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-argument)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 408634)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 408616))
     (push)
     (push.const . enclose)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (2 . 0) "./boot/compile.scm" . 410688)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 410664))
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 407581)
     (push.cons)
     (extend . 1)
     (iloc 3 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 411687))
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 413724)
   (extend . 1)
   (call
     (touch.gloc.of collect-local-closure)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 414734))
   (push.close
     (0 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc 3 . 0)
         (push.const)
         (ret.subr.gloc.of values "./boot/compile.scm" . 418850))
       (push.iloc.0 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 419886)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #t)
         (push.car.iloc (0 . 0) "./boot/compile.scm" . 420933)
         (push.const quote lambda)
         (ret.subr.gloc.of memq "./boot/compile.scm" . 420927))
       (if.true
         (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 421934)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 421950)
         (iloc.1 . 1)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/compile.scm" . 421928))
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 422960)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/compile.scm" . 422952))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/compile.scm" . 416796))
   (push.close
     (2 0)
     (call
       (touch.gloc.of cte-extend-iloc)
       (call (push.gloc.of car) (push.iloc.1 . 0) (apply.gloc.of map "./boot/compile.scm" . 423980))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 423963))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of compile-argument-each)
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/compile.scm" . 425019))
       (push)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 424996))
     (push)
     (call
       (push.gloc.of append)
       (call
         (push.gloc.of \x2E;fn1.1\x60;1)
         (call
           (touch.gloc.of iloc-iota)
           (push.const . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427075)
           (push.iloc.1 . 1)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427090)
           (apply.gloc.of iloc-iota "./boot/compile.scm" . 427062))
         (push)
         (call
           (push.close
             (1 0)
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 428123)
             (push.iloc.1 . 0)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 428103))
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/compile.scm" . 428086))
         (push)
         (apply.gloc.of map "./boot/compile.scm" . 426033))
       (push)
       (apply.gloc.of apply "./boot/compile.scm" . 426019))
     (push)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 429115)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 429091))
     (push)
     (extend . 3)
     (call
       (iloc.0 . 0)
       (if.null?
         (push.const . extend.unbound)
         (push.iloc 3 . 0)
         (subr.gloc.of length 1 "./boot/compile.scm" . 431161)
         (push.cons)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
         (ret.cons "./boot/compile.scm" . 430112))
       (push.const . extend.unbound)
       (push.iloc 3 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432185)
       (push.cons)
       (push.iloc.0 . 0)
       (push.const . enclose)
       (push.iloc.0 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432229)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
       (push.cons)
       (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
       (ret.cons "./boot/compile.scm" . 430112))
     (push)
     (extend . 1)
     (iloc 5 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 433188))
   (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 413708))
 (set.gloc.of compile-expression-letrec*)
 (ret.const.unspec))
((close
   (5 0 . compile-binary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cdadr 1 "./boot/compile.scm" . 478229)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 479253)
   (extend . 2)
   (call
     (touch.gloc.of compile-argument)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 480309)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 480291))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 481335)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 481315))
   (push)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 480283)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 482332))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 483377)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 483357))
   (push)
   (extend . 3)
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 484381)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 484404)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 484398))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 485438)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 485399))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 486423)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 486423))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 487447))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 488471)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 488471))
 (set.gloc.of compile-binary-special\x60;2)
 (close
   (4 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 441390)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 441370))
   (push)
   (extend . 1)
   (call
     (cdr.iloc (0 . 0) "./boot/compile.scm" . 442395)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 442417)
     (const . const)
     (ret.eq? "./boot/compile.scm" . 442412))
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of cdar 1 "./boot/compile.scm" . 443411)
     (if.true
       (touch.gloc.of compile-expression)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 444455)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 444435))
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 445479)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 445459))
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 446517)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 446497))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 447540)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 447520))
   (push)
   (extend . 2)
   (call
     (cadr.iloc (2 . 0) "./boot/compile.scm" . 448547)
     (if.not.symbol?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 448565)
     (push.iloc 2 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 448577)
     (ret.eq? "./boot/compile.scm" . 448560))
   (if.true
     (iloc 2 . 3)
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 449584)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 449563))
     (push.const . call)
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 450587)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 450587))
   (iloc 2 . 3)
   (if.true
     (call
       (cdr.iloc (0 . 1) "./boot/compile.scm" . 452652)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 1)
       (push.subr.gloc.of caar 1 "./boot/compile.scm" . 452674)
       (const . ret.const)
       (ret.eq? "./boot/compile.scm" . 452669))
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret.const)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 453700)
       (push.cons)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 452636))
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 452636))
   (push.const . call)
   (push.iloc.1 . 0)
   (push.const . if.true)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 0)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 455707)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 455707))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (5 0 . compile-unary-special)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/compile.scm" . 460820)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 461845)
   (extend . 2)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 462875))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 463900))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 464945)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 464925))
   (push)
   (extend . 3)
   (call
     (push.iloc 2 . 4)
     (const . if.null?.ret.const)
     (if.not.eq?.ret.const . #f)
     (iloc.1 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (ret.eq? "./boot/compile.scm" . 466000))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 466970)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 466970))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 4)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 467994)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 467994)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 467994))
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 470052)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 470075)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 470069))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 471109)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 471070))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 472094)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 472094))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 473118))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 474142)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 474142))
 (set.gloc.of compile-unary-special\x60;2)
 (close
   (4 0 . compile-expression-if)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/compile.scm" . 492563)
   (if.null?
     (iloc.0 . 2)
     (if.true
       (touch.gloc.of compile-expression)
       (push.const . and)
       (cdr.iloc (0 . 0) "./boot/compile.scm" . 494636)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 494608))
     (touch.gloc.of compile-expression)
     (push.const . if)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 495659)
     (push.const (\x2E;unspecified))
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 495632)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 495632))
   (call
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 497695)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 497724)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 497708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 499750)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 499742)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.null?)
         (push.const . if.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 502818))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.pair?)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 504866))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.symbol?)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 506914))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 508962))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.eq?)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;2 "./boot/compile.scm" . 512034))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 513078))
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 514127)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 514120)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 514100)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 514094)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515116))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515142))
         (if.true
           (touch.gloc.of compile-binary-special\x60;2)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.const . if.eq?)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;2 "./boot/compile.scm" . 516136))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 517160))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 519202))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.iloc 2 . 3)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 521243))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 523283))
 (set.gloc.of compile-expression-if)
 (ret.const.unspec))
((close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 541733)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 541713))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 541790)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 541774))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 540683))
 (set.gloc.of compile-unary-special\x60;4)
 (close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 537637)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 537617))
   (push)
   (push.const . if.false.ret.const)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 537707)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 537691))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 536587))
 (set.gloc.of compile-anonymous-negate\x60;4)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 533541)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 533521))
   (push)
   (push.const . if.true.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 533563)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 533601)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 533585))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 532491))
 (set.gloc.of compile-anonymous\x60;4)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 545827)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 545809))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 545866)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 545846))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 545924)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 545908))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 544779)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 544779))
 (set.gloc.of compile-binary-special\x60;4)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 547860)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 548897)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 548877))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 549920)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 549947)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 549931))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 553006)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 553018)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 554034)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 554061)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 554045))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 556089)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 556081)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.null?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 559157))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.pair?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 561205))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.symbol?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 563253))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 565301))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of compile-binary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.eq?.ret.const)
             (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 568373))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 569417))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 570464)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 570457)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 570439)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 570433)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571455))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571481))
             (if.true
               (touch.gloc.of compile-binary-special\x60;4)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.not.eq?.ret.const)
               (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 572475))
             (touch.gloc.of compile-anonymous-negate\x60;4)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 573499))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 575541))
         (touch.gloc.of compile-anonymous-negate\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 577582))
       (touch.gloc.of compile-anonymous-negate\x60;4)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 579622))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 580651)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 580643)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 583719))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 585767))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 587815))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 589863))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 592935))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 593979))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 595026)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 595019)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 595001)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 594995)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596017))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596043))
         (if.true
           (touch.gloc.of compile-binary-special\x60;4)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 597037))
         (touch.gloc.of compile-anonymous\x60;4)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 598061))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 600103))
     (touch.gloc.of compile-anonymous\x60;4)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 602144))
   (touch.gloc.of compile-anonymous\x60;4)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 604180))
 (set.gloc.of compile-clause\x60;2)
 (close
   (4 0 . compile-expression-or)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 606227)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #f)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 608280))
     (push.const . const)
     (const . #f)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 609304))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 610323)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 611360)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 611340))
   (call
     (iloc.0 . 3)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 613400)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 614424)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of top-level-value-or-false)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caaddr 1 "./boot/compile.scm" . 615472)
       (apply.gloc.of top-level-value-or-false "./boot/compile.scm" . 615446))
     (push)
     (gloc.of assertion-violation)
     (ret.eq? "./boot/compile.scm" . 615441))
   (if.true
     (call
       (touch.gloc.of compile-expression)
       (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 616484)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616464))
     (push)
     (push.const . if.false.call)
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 616544)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616524))
     (push.cons)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 612363)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 612363))
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 618536)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 618520))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 619548))
 (set.gloc.of compile-expression-or)
 (ret.const.unspec))
((close
   (3 0 . compile-unary-special)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 637989)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 637969))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 638046)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 638030))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 636939))
 (set.gloc.of compile-unary-special\x60;4)
 (close
   (3 0 . compile-binary-special)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 642083)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 642065))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 642122)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 642102))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 642180)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 642164))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 641035)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 641035))
 (set.gloc.of compile-binary-special\x60;4)
 (close
   (2 0 . compile-anonymous-negate)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 633893)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 633873))
   (push)
   (push.const . if.true.ret.const)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 633962)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 633946))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 632843))
 (set.gloc.of compile-anonymous-negate\x60;4)
 (close
   (2 0 . compile-anonymous)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 629797)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 629777))
   (push)
   (push.const . if.false.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 629819)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 629858)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 629842))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 628747))
 (set.gloc.of compile-anonymous\x60;4)
 (close
   (2 0 . compile-clause)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 644116)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 645153)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 645133))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 646176)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 646203)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 646187))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 649262)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 649274)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 650290)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 650317)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 650301))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 652345)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 652337)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.null?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 655413))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.pair?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 657461))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.symbol?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 659509))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 661557))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of compile-binary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.eq?.ret.const)
             (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 664629))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 665673))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 666720)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 666713)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 666695)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 666689)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667711))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667737))
             (if.true
               (touch.gloc.of compile-binary-special\x60;4)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.eq?.ret.const)
               (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 668731))
             (touch.gloc.of compile-anonymous-negate\x60;4)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 669755))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 671797))
         (touch.gloc.of compile-anonymous-negate\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 673838))
       (touch.gloc.of compile-anonymous-negate\x60;4)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 675878))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 676907)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 676899)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 679975))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 682023))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 684071))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 686119))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 689191))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 690235))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 691282)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 691275)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 691257)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 691251)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692273))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692299))
         (if.true
           (touch.gloc.of compile-binary-special\x60;4)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.not.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 693293))
         (touch.gloc.of compile-anonymous\x60;4)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 694317))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 696359))
     (touch.gloc.of compile-anonymous\x60;4)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 698400))
   (touch.gloc.of compile-anonymous\x60;4)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 700436))
 (set.gloc.of compile-clause\x60;2)
 (close
   (4 0 . compile-expression-and)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 702483)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #t)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 704536))
     (push.const . const)
     (const . #t)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 705560))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 706579)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 707616)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 707596))
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 709672)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 709656))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 710684))
 (set.gloc.of compile-expression-and)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . begin)
   (push.gloc.of compile-expression-begin)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 714757)
   (push.iloc.0 . 0)
   (push.const . quote)
   (push.gloc.of compile-expression-quote)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 715781)
   (push.iloc.0 . 0)
   (push.const . define)
   (push.gloc.of compile-expression-define)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 716805)
   (push.iloc.0 . 0)
   (push.const . set!)
   (push.gloc.of compile-expression-set!)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 717829)
   (push.iloc.0 . 0)
   (push.const . lambda)
   (push.gloc.of compile-expression-lambda)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 718853)
   (push.iloc.0 . 0)
   (push.const . let)
   (push.gloc.of compile-expression-let)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 719877)
   (push.iloc.0 . 0)
   (push.const . letrec*)
   (push.gloc.of compile-expression-letrec*)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 720901)
   (push.iloc.0 . 0)
   (push.const . if)
   (push.gloc.of compile-expression-if)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 721925)
   (push.iloc.0 . 0)
   (push.const . or)
   (push.gloc.of compile-expression-or)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 722949)
   (push.iloc.0 . 0)
   (push.const . and)
   (push.gloc.of compile-expression-and)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 723973)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 724997))
 (set.gloc.of ht-dispatch-expression)
 (ret.const.unspec))
((close
   (1 0 . reverse-append)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/compile.scm" . 732169))
 (set.gloc.of reverse-append\x60;2)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of loop\x60;7)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 735256)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 735274)
   (push.iloc.0 . 1)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 735266)
   (apply.gloc.of loop\x60;7 "./boot/compile.scm" . 735250))
 (set.gloc.of loop\x60;7)
 (close
   (4 0 . compile-expression-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (touch.gloc.of reverse-append\x60;2)
       (push.iloc.0 . 1)
       (apply.gloc.of reverse-append\x60;2 "./boot/compile.scm" . 740378))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 747542)
     (call
       (touch.gloc.of compile-expression)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 743448)
       (push.iloc 2 . 1)
       (call
         (iloc 2 . 2)
         (if.true.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 745515)
         (ret.pair? "./boot/compile.scm" . 745508))
       (push)
       (call
         (iloc 2 . 3)
         (if.false.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 746537)
         (ret.null? "./boot/compile.scm" . 746530))
       (push)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 742423))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 747536))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 739333))
 (set.gloc.of compile-expression-seq)
 (ret.const.unspec))
((close
   (4 0 . compile-expression)
   (iloc.0 . 0)
   (if.pair?
     (push.gloc.of ht-dispatch-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 755774)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 755731)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (0 . 0) "./boot/compile.scm" . 756773))
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 757795)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 757779))
     (if.true
       (touch.gloc.of compile-subr-expression)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-subr-expression "./boot/compile.scm" . 758803))
     (call
       (subr.gloc.of backtrace 0 "./boot/compile.scm" . 762916)
       (if.true
         (touch.gloc.of compile-touch)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 762943)
         (push.iloc.1 . 1)
         (apply.gloc.of compile-touch "./boot/compile.scm" . 762928))
       (ret.const))
     (push)
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 761910)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 761887))
     (push)
     (call
       (touch.gloc.of compile-call)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 760877)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 760896)
       (push.subr.gloc.of length 1 "./boot/compile.scm" . 760888)
       (call
         (touch.gloc.of make-application-comment)
         (push.iloc.1 . 0)
         (apply.gloc.of make-application-comment "./boot/compile.scm" . 760908))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-call "./boot/compile.scm" . 760863))
     (push)
     (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 763931)
     (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 763931)
     (extend . 1)
     (iloc 2 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 764965))
   (iloc.0 . 3)
   (if.true
     (push.iloc.0 . 0)
     (const . \x2E;&UNDEF)
     (if.eq?
       (push.const . ret.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 769053)
       (ret.subr.gloc.of list "./boot/compile.scm" . 769047))
     (push.iloc.0 . 0)
     (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 770071)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 771101)
       (ret.subr.gloc.of list "./boot/compile.scm" . 771095))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of iloc?)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 773147))
       (if.true
         (push.const . ret.iloc)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 774185))
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 773143))
       (push.const . ret.gloc.of)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 773143)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 773143))
     (push.const . ret.const)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 776214))
   (iloc.0 . 2)
   (if.true.ret.const)
   (push.iloc.0 . 0)
   (const . \x2E;&UNDEF)
   (if.eq?
     (push.const . const.undef)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 780317)
     (ret.subr.gloc.of list "./boot/compile.scm" . 780311))
   (push.iloc.0 . 0)
   (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 781335)
   (if.true
     (push.const . const.unspec)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 782365)
     (ret.subr.gloc.of list "./boot/compile.scm" . 782359))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 784411))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 785446))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 786467)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 787505)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 787487))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 788529)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 788511))
       (push.const . iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 789535))
     (push.const . gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 784407)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 784407))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 791574))
 (set.gloc.of compile-expression)
 (ret.const.unspec))
((close
   (1 0 . compile-coreform)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of ht-local-closures)
       (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
     (set.iloc 1 . 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 1)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of compile-expression)
     (push.iloc 2 . 0)
     (push.const)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 0)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (apply.gloc.of \x2E;dynamic-wind "./boot/compile.scm" . 797703))
 (set.gloc.of compile-coreform)
 (ret.const.unspec))

;
((close
   (3 0 . dynamic-wind)
   (call (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 11269))
   (call
     (touch.gloc.of current-dynamic-wind-record)
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (push.cons)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12342))
     (push.cons)
     (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12293))
   (push.iloc.0 . 1)
   (push.close
     (0 1)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16429))
       (push)
       (push.subr.gloc.of cdr 1 "./boot/dynamic-wind.scm" . 16424)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16395))
     (call (apply.iloc (1 . 2) "./boot/dynamic-wind.scm" . 17419))
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/dynamic-wind.scm" . 18443))
   (apply.gloc.of call-with-values "./boot/dynamic-wind.scm" . 13317))
 (set.gloc.of dynamic-wind)
 (ret.const.unspec))
((close
   (2 0 . common-tail)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25619)
   (push.iloc.0 . 1)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25635)
   (extend . 2)
   (touch.gloc.of \x2E;L0\x60;9)
   (call
     (iloc.0 . 0)
     (>.iloc (0 . 1) "./boot/dynamic-wind.scm" . 26647)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 26670)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 26657))
     (ret.iloc 1 . 0))
   (push)
   (call
     (iloc.0 . 1)
     (>.iloc (0 . 0) "./boot/dynamic-wind.scm" . 27671)
     (if.true
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 27694)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 27681))
     (ret.iloc 1 . 1))
   (push)
   (apply.gloc.of \x2E;L0\x60;9 "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of common-tail\x60;2)
 (close
   (2 0 . \x2E;L0)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq? (ret.iloc 0 . 0))
   (touch.gloc.of \x2E;L0\x60;9)
   (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 26684)
   (push.cdr.iloc (0 . 1) "./boot/dynamic-wind.scm" . 27708)
   (apply.gloc.of \x2E;L0\x60;9 "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of \x2E;L0\x60;9)
 (close
   (3 0 . perform-dynamic-wind)
   (call
     (call
       (touch.gloc.of common-tail\x60;2)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 30754))
       (push)
       (apply.gloc.of common-tail\x60;2 "./boot/dynamic-wind.scm" . 30737))
     (push)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.const.unspec))
         (call
           (touch.gloc.of current-dynamic-wind-record)
           (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 33837)
           (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 33808))
         (call (push.iloc.0 . 0) (subr.gloc.of cdar 1 "./boot/dynamic-wind.scm" . 34833) (apply))
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 35862)
         (apply.iloc+ (1 . 0) "./boot/dynamic-wind.scm" . 35856))
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 31767))
       (push)
       (apply.iloc+ (0 . 0) "./boot/dynamic-wind.scm" . 31751))
     (extend.enclose
       (1 0 . loop)
       (push.iloc.0 . 0)
       (iloc 2 . 0)
       (if.eq? (ret.const.unspec))
       (call
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 38934)
         (apply.iloc (1 . 0) "./boot/dynamic-wind.scm" . 38928))
       (call (push.iloc.0 . 0) (subr.gloc.of caar 1 "./boot/dynamic-wind.scm" . 39953) (apply))
       (touch.gloc.of current-dynamic-wind-record)
       (push.iloc.0 . 0)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 40976))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 36871))
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of apply "./boot/dynamic-wind.scm" . 41989))
 (set.gloc.of perform-dynamic-wind)
 (ret.const.unspec))
((close (0 0) (ret.const . #f))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . call-with-port)
   (push.gloc.of \x2E;fn2.1\x60;2)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/dynamic-wind.scm" . 48145))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of close-port "./boot/dynamic-wind.scm" . 49169))
   (apply.gloc.of dynamic-wind "./boot/dynamic-wind.scm" . 46085))
 (set.gloc.of call-with-port)
 (ret.const.unspec))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/exception.scm" . 5154))
 (set.gloc.of parent-exception-handler)
 (ret.const.unspec))
((close
   (1 0 . raise)
   (call
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 9228))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 11281))
       (call
         (call
           (touch.gloc.of parent-exception-handler)
           (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 12312))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (call (apply.gloc.of make-non-continuable-violation "./boot/exception.scm" . 14382))
             (push)
             (call
               (push.const . raise)
               (apply.gloc.of make-who-condition "./boot/exception.scm" . 15406))
             (push)
             (call
               (push.const . "returned from non-continuable exception")
               (apply.gloc.of make-message-condition "./boot/exception.scm" . 16430))
             (push)
             (call
               (push.iloc 2 . 0)
               (push.subr.gloc.of list 1 "./boot/exception.scm" . 17480)
               (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 17454))
             (push)
             (apply.gloc.of condition "./boot/exception.scm" . 14371))
           (push)
           (apply.iloc (0 . 0) "./boot/exception.scm" . 14365))
         (ret.const.unspec))
       (push.const . "error in raise: returned from non-continuable exception~%~%irritants:~%~a")
       (call
         (touch.gloc.of describe-condition)
         (push.const . #f)
         (push.iloc.1 . 0)
         (apply.gloc.of describe-condition "./boot/exception.scm" . 18539))
       (push)
       (apply.gloc.of scheme-error "./boot/exception.scm" . 18449))
     (ret.const.unspec))
   (push.const . "error in raise: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.0 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 19544))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 19461))
 (set.gloc.of raise)
 (ret.const.unspec))
((close
   (1 0 . raise-continuable)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 23564))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 24606))
   (push.const . "error in raise-continuable: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 26731))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 26636))
 (set.gloc.of raise-continuable)
 (ret.const.unspec))
((close
   (2 0 . with-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 30739))
   (push)
   (extend . 1)
   (push.const . #f)
   (push.const . #f)
   (push.close
     (1 0 . tmp2)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-exception-handler)
         (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
       (set.iloc 1 . 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc 3 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
     (push.close (0 0) (push.iloc 2 . 0) (apply.iloc (4 . 0) "./boot/exception.scm" . 36881))
     (push.close
       (0 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
     (apply.gloc.of \x2E;dynamic-wind "./boot/exception.scm" . 36881))
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of parent-exception-handler)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of parent-exception-handler)
       (push.iloc 2 . 0)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 2)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
   (push.close (0 0) (apply.iloc (3 . 1) "./boot/exception.scm" . 37897))
   (push.close
     (0 0)
     (call
       (touch.gloc.of parent-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 1)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
   (apply.gloc.of \x2E;dynamic-wind "./boot/exception.scm" . 37897))
 (set.gloc.of with-exception-handler)
 (ret.const.unspec))
((close
   (2 1 . assertion-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 45083))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 46116))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 47131))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 48155))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 45077)
       (apply.gloc.of filter "./boot/exception.scm" . 44045))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 43014))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 41989))
 (set.gloc.of assertion-violation)
 (ret.const.unspec))
((close
   (1 1 . undefined-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 55323))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 56356))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 57416)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 57392))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 55317)
       (apply.gloc.of filter "./boot/exception.scm" . 54285))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 53254))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 52229))
 (set.gloc.of undefined-violation)
 (ret.const.unspec))
((close
   (1 1 . lexical-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-lexical-violation "./boot/exception.scm" . 64539))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 65572))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 66632)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 66608))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 64533)
       (apply.gloc.of filter "./boot/exception.scm" . 63501))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 62470))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 61445))
 (set.gloc.of lexical-violation)
 (ret.const.unspec))
((close
   (3 1 . syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 73804))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 73755))
       (push)
       (call
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (apply.gloc.of make-who-condition "./boot/exception.scm" . 75807))
         (call
           (call
             (call
               (touch.gloc.of wrapped-syntax-object?)
               (push.iloc.0 . 2)
               (apply.gloc.of wrapped-syntax-object? "./boot/exception.scm" . 76853))
             (if.true
               (touch.gloc.of unwrap-syntax)
               (push.iloc.0 . 2)
               (apply.gloc.of unwrap-syntax "./boot/exception.scm" . 76883))
             (ret.iloc 0 . 2))
           (push)
           (extend . 1)
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/exception.scm" . 77871))
           (if.true
             (touch.gloc.of original-id)
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/exception.scm" . 77902))
             (push)
             (apply.gloc.of original-id "./boot/exception.scm" . 77889))
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (call
             (push.car.iloc (0 . 0) "./boot/exception.scm" . 78925)
             (apply.gloc.of identifier? "./boot/exception.scm" . 78912))
           (if.false.ret)
           (touch.gloc.of original-id)
           (call
             (touch.gloc.of syntax-object-expr)
             (push.car.iloc (0 . 0) "./boot/exception.scm" . 78970)
             (apply.gloc.of syntax-object-expr "./boot/exception.scm" . 78950))
           (push)
           (apply.gloc.of original-id "./boot/exception.scm" . 78937))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (apply.gloc.of make-who-condition "./boot/exception.scm" . 76831))
         (ret.const . #f))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 82971))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 69635)
       (apply.gloc.of filter "./boot/exception.scm" . 69635))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 69635))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 69635))
 (set.gloc.of syntax-violation)
 (ret.const.unspec))
((close
   (2 1 . error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-error "./boot/exception.scm" . 90139))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 91172))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 92187))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 93211))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 90133)
       (apply.gloc.of filter "./boot/exception.scm" . 89101))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 88070))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 87045))
 (set.gloc.of error)
 (ret.const.unspec))
((close
   (2 1 . implementation-restriction-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (apply.gloc.of make-implementation-restriction-violation "./boot/exception.scm" . 100379))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 101412))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 102427))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 103474))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 100373)
       (apply.gloc.of filter "./boot/exception.scm" . 99341))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 98310))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 97285))
 (set.gloc.of implementation-restriction-violation)
 (ret.const.unspec))
((close
   (3 1 . undefined/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 110668))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 110619))
       (push)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 111643))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 112676))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 113691))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 110613)
       (apply.gloc.of filter "./boot/exception.scm" . 109581))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 108550))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 107525))
 (set.gloc.of undefined/syntax-violation)
 (ret.const.unspec))
((close
   (3 1 . assertion/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 120908))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 120859))
       (push)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 121883))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 122916))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 123931))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 120853)
       (apply.gloc.of filter "./boot/exception.scm" . 119821))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 118790))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 117765))
 (set.gloc.of assertion/syntax-violation)
 (ret.const.unspec))
((close
   (0 1 . scheme-error)
   (push.const . #t)
   (push.const . "~!")
   (subr.gloc.of format 2 "./boot/exception.scm" . 141317)
   (subr.gloc.of current-error-port 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . "~&~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 143367)
   (call
     (push.gloc.of format)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of apply "./boot/exception.scm" . 144391))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 145415)
   (subr.gloc.of display-backtrace 0 "./boot/exception.scm" . 146439)
   (push.iloc.0 . 0)
   (push.const . "~%[exit]~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 147463)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/exception.scm" . 148487))
 (set.gloc.of scheme-error)
 (ret.const.unspec))
((close
   (3 1 . raise-i/o-filename-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-i/o-filename-error "./boot/exception.scm" . 155675))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 156708))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 157723))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 158770))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 155669)
       (apply.gloc.of filter "./boot/exception.scm" . 154637))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 153606))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 152581))
 (set.gloc.of raise-i/o-filename-error)
 (ret.const.unspec))
((close
   (2 1 . raise-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-i/o-error "./boot/exception.scm" . 165915))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 166948))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 167963))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 169010))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 165909)
       (apply.gloc.of filter "./boot/exception.scm" . 164877))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 163846))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 162821))
 (set.gloc.of raise-i/o-error)
 (ret.const.unspec))
((close
   (4 1 . raise-misc-i/o-error-with-port)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 4)
         (apply.gloc.of apply "./boot/exception.scm" . 177179))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 178212))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 179227))
       (push)
       (call
         (iloc.0 . 3)
         (if.false.ret)
         (push.iloc.0 . 3)
         (apply.gloc.of make-i/o-port-error "./boot/exception.scm" . 180261))
       (push)
       (call
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (push.subr.gloc.of cons* 2 "./boot/exception.scm" . 181301)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 181275))
       (push)
       (push.subr.gloc.of list 5 "./boot/exception.scm" . 177173)
       (apply.gloc.of filter "./boot/exception.scm" . 176141))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 175110))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 174085))
 (set.gloc.of raise-misc-i/o-error-with-port)
 (ret.const.unspec))
((close
   (3 1 . raise-misc-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of apply "./boot/exception.scm" . 188443))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 189476))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 190491))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 192544))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 188437)
       (apply.gloc.of filter "./boot/exception.scm" . 187405))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 186374))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 185349))
 (set.gloc.of raise-misc-i/o-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-read-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-read-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 196613))
 (set.gloc.of raise-i/o-read-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-write-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-write-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 200709))
 (set.gloc.of raise-i/o-write-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-protection-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-protection-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 204805))
 (set.gloc.of raise-i/o-file-protection-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-is-read-only-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-file-is-read-only-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 208901))
 (set.gloc.of raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-already-exists-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-already-exists-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 212997))
 (set.gloc.of raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-does-not-exist-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-does-not-exist-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 217093))
 (set.gloc.of raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-invalid-position-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-invalid-position-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 221189))
 (set.gloc.of raise-i/o-invalid-position-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-decoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-decoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 225285))
 (set.gloc.of raise-i/o-decoding-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-encoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-encoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 229381))
 (set.gloc.of raise-i/o-encoding-error)
 (ret.const.unspec))

;
((subr.gloc.of make-weak-core-hashtable 0 "./boot/record.scm" . 5156)
 (set.gloc.of nongenerative-record-types)
 (ret.const.unspec))
((close
   (6 0 . make-rtd)
   (push.const . type:record-type-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 9221))
 (set.gloc.of make-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 13322)
   (const . type:record-type-descriptor)
   (ret.eq? "./boot/record.scm" . 13317))
 (set.gloc.of record-type-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rtd-name)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 15395))
 (set.gloc.of rtd-name)
 (ret.const.unspec))
((close
   (1 0 . rtd-parent)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 16419))
 (set.gloc.of rtd-parent)
 (ret.const.unspec))
((close
   (1 0 . rtd-uid)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 17443))
 (set.gloc.of rtd-uid)
 (ret.const.unspec))
((close
   (1 0 . rtd-sealed?)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 18467))
 (set.gloc.of rtd-sealed?)
 (ret.const.unspec))
((close
   (1 0 . rtd-opaque?)
   (push.iloc.0 . 0)
   (push.const . 5)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 19491))
 (set.gloc.of rtd-opaque?)
 (ret.const.unspec))
((close
   (1 0 . rtd-fields)
   (push.iloc.0 . 0)
   (push.const . 6)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 20515))
 (set.gloc.of rtd-fields)
 (ret.const.unspec))
((close
   (2 0 . rtd-ancestor?)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 27670))
     (push)
     (apply.iloc+ (1 . 0) "./boot/record.scm" . 27664))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/record.scm" . 24581))
 (set.gloc.of rtd-ancestor?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of loop\x60;5)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 33812))
     (push)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 34853))
     (push)
     (push.subr.gloc.of length 1 "./boot/record.scm" . 34845)
     (push.subr.gloc.of + 2 "./boot/record.scm" . 34836)
     (apply.gloc.of loop\x60;5 "./boot/record.scm" . 33806))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . rtd-inherited-field-count)
   (touch.gloc.of loop\x60;5)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 31765))
   (push)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/record.scm" . 31749))
 (set.gloc.of rtd-inherited-field-count)
 (ret.const.unspec))
((close
   (1 0 . rtd-total-field-count)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 40968))
   (push)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 41008))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 41000)
   (ret.subr.gloc.of + "./boot/record.scm" . 40965))
 (set.gloc.of rtd-total-field-count)
 (ret.const.unspec))
((close
   (1 0 . record-type-name)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 45065))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 46128))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 46089))
   (touch.gloc.of rtd-name)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-name "./boot/record.scm" . 47109))
 (set.gloc.of record-type-name)
 (ret.const.unspec))
((close
   (1 0 . record-type-parent)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 51209))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 52272))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 52233))
   (touch.gloc.of rtd-parent)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-parent "./boot/record.scm" . 53253))
 (set.gloc.of record-type-parent)
 (ret.const.unspec))
((close
   (1 0 . record-type-uid)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 57353))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 58416))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 58377))
   (touch.gloc.of rtd-uid)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-uid "./boot/record.scm" . 59397))
 (set.gloc.of record-type-uid)
 (ret.const.unspec))
((close
   (1 0 . record-type-generative?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 63497))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 64560))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 64521))
   (call
     (touch.gloc.of rtd-uid)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-uid "./boot/record.scm" . 65546))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 65541))
 (set.gloc.of record-type-generative?)
 (ret.const.unspec))
((close
   (1 0 . record-type-sealed?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 69641))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 70704))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 70665))
   (touch.gloc.of rtd-sealed?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-sealed? "./boot/record.scm" . 71685))
 (set.gloc.of record-type-sealed?)
 (ret.const.unspec))
((close
   (1 0 . record-type-opaque?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 75785))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 76848))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 76809))
   (touch.gloc.of rtd-opaque?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-opaque? "./boot/record.scm" . 77829))
 (set.gloc.of record-type-opaque?)
 (ret.const.unspec))
((close
   (1 0 . record-type-field-names)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 81929))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 82992))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 82953))
   (call
     (push.gloc.of cdr)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 83996))
     (push)
     (apply.gloc.of map "./boot/record.scm" . 83987))
   (push)
   (ret.subr.gloc.of list->vector "./boot/record.scm" . 83973))
 (set.gloc.of record-type-field-names)
 (ret.const.unspec))
((close
   (2 0 . record-field-mutable?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 88073))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 89136))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 89197)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 89097))
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 90132))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-ref 2 "./boot/record.scm" . 90122)
   (ret.subr.gloc.of car "./boot/record.scm" . 90117))
 (set.gloc.of record-field-mutable?)
 (ret.const.unspec))
((close
   (6 0 . make-record-type-descriptor)
   (push.iloc.0 . 0)
   (subr.gloc.of symbol? 1 "./boot/record.scm" . 94217)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "symbol")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 96286))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 97310)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 95241))
   (push.iloc.0 . 5)
   (subr.gloc.of vector? 1 "./boot/record.scm" . 98313)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "vector")
       (push.iloc.0 . 5)
       (push.const . 6)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 100382))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 101406)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 99337))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 103438))
     (if.false.call
       (push.const . make-record-type-descriptor)
       (call
         (touch.gloc.of wrong-type-argument-message)
         (push.const . "record-type descriptor or #f")
         (push.iloc.0 . 1)
         (push.const . 2)
         (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 105507))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.iloc.0 . 4)
       (push.iloc.0 . 5)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 106531)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 104462))
     (if.false.ret)
     (call
       (touch.gloc.of rtd-sealed?)
       (push.iloc.0 . 1)
       (apply.gloc.of rtd-sealed? "./boot/record.scm" . 107535))
     (if.false.ret)
     (push.const . make-record-type-descriptor)
     (push.const . "attempt to extend a sealed record-type")
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 108559))
   (call
     (iloc.0 . 4)
     (if.true.ret)
     (iloc.0 . 1)
     (if.false.ret)
     (touch.gloc.of rtd-opaque?)
     (push.iloc.0 . 1)
     (apply.gloc.of rtd-opaque? "./boot/record.scm" . 111645))
   (push)
   (call
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (ret.null? "./boot/record.scm" . 113690))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . mutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #t)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . immutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #f)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (push.const . make-record-type-descriptor)
       (push.const . "malformed field specifiers")
       (push.iloc 2 . 5)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 113690))
     (push.iloc.0 . 5)
     (push.subr.gloc.of vector->list 1 "./boot/record.scm" . 120856)
     (apply.gloc.of map "./boot/record.scm" . 109573))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of make-rtd)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of make-rtd "./boot/record.scm" . 121874))
   (push)
   (extend . 1)
   (iloc 2 . 2)
   (if.true
     (push.gloc.of nongenerative-record-types)
     (push.iloc 2 . 2)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/record.scm" . 123920)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 125988))
         (push)
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 126002))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 125982)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127012))
         (push)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127029))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 127006)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128038))
         (push)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128055))
         (push)
         (ret.subr.gloc.of equal? "./boot/record.scm" . 128030))
       (if.true (ret.iloc 0 . 0))
       (push.const . make-record-type-descriptor)
       (push.const . "mismatched subsequent call for nongenerative record-type")
       (push.iloc 3 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (push.iloc 3 . 3)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 132142)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 130073))
     (push.gloc.of nongenerative-record-types)
     (push.iloc 3 . 2)
     (push.iloc.1 . 0)
     (subr.gloc.of core-hashtable-set! 3 "./boot/record.scm" . 134167)
     (ret.iloc 1 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of make-record-type-descriptor)
 (ret.const.unspec))
((close
   (4 0 . make-rcd)
   (push.const . type:record-constructor-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 138245))
 (set.gloc.of make-rcd)
 (ret.const.unspec))
((close
   (1 0 . record-constructor-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 142346)
   (const . type:record-constructor-descriptor)
   (ret.eq? "./boot/record.scm" . 142341))
 (set.gloc.of record-constructor-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rcd-rtd)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 144428))
 (set.gloc.of rcd-rtd)
 (ret.const.unspec))
((close
   (1 0 . rcd-protocol)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 145452))
 (set.gloc.of rcd-protocol)
 (ret.const.unspec))
((close
   (1 0 . rcd-custom-protocol?)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 146476))
 (set.gloc.of rcd-custom-protocol?)
 (ret.const.unspec))
((close
   (1 0 . rcd-parent)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 147500))
 (set.gloc.of rcd-parent)
 (ret.const.unspec))
((close
   (1 0)
   (ret.close
     (0 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/record.scm" . 160783)))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0 . default-protocol)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 151571))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 153637))
     (push)
     (extend . 1)
     (ret.close
       (1 0)
       (ret.close
         (0 1)
         (push.close
           (0 0)
           (touch.gloc.of split-at)
           (push.iloc.1 . 0)
           (push.iloc 3 . 0)
           (apply.gloc.of split-at "./boot/record.scm" . 156743))
         (push.close
           (2 0)
           (call
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (apply.gloc.of apply "./boot/record.scm" . 157722))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of apply "./boot/record.scm" . 157715))
         (apply.gloc.of \x2E;call-with-values "./boot/record.scm" . 155663))))
   (ret.gloc.of \x2E;fn1.1\x60;1))
 (set.gloc.of default-protocol)
 (ret.const.unspec))
((close
   (3 0 . make-record-constructor-descriptor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 164873))
   (if.false.call
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 166942))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 167966)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 165897))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of record-constructor-descriptor?)
       (push.iloc.0 . 1)
       (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 169998))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor or #f")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 172067))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 173091)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 171022))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (push.iloc.0 . 2)
     (subr.gloc.of procedure? 1 "./boot/record.scm" . 175118)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "procedure or #f")
       (push.iloc.0 . 2)
       (push.const . 3)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 177187))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 178211)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 176142))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 180238))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 181262))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 186378))
     (if.false.ret)
     (call
       (touch.gloc.of rcd-rtd)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-rtd "./boot/record.scm" . 187411))
     (push)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 187428))
     (if.eq?.ret.const . #t)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 188430))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 193546))
     (if.false.ret)
     (iloc.0 . 1)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "expected #f for protocol since no parent constructor descriptor is provided")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 195598))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rcd-custom-protocol?)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-custom-protocol? "./boot/record.scm" . 200714))
     (if.false.ret)
     (iloc.0 . 2)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const
       .
       "expected procedure for protocol since parent constructor descriptor have custom one")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 202766))
   (touch.gloc.of make-rcd)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 2)
     (if.true.ret)
     (touch.gloc.of default-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of default-protocol "./boot/record.scm" . 208930))
   (push)
   (call (iloc.0 . 2) (if.false.ret) (ret.const . #t))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 210974))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of make-record-constructor-descriptor "./boot/record.scm" . 213027))
     (ret.const . #f))
   (push)
   (apply.gloc.of make-rcd "./boot/record.scm" . 215047))
 (set.gloc.of make-record-constructor-descriptor)
 (ret.const.unspec))
((close
   (1 0 . record?)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 219171)
     (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 219146))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 220196)
     (apply.gloc.of record-type-opaque? "./boot/record.scm" . 220175))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 220170))
 (set.gloc.of record?)
 (ret.const.unspec))
((close
   (1 0 . record-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/record.scm" . 224265))
   (if.true
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 225289))
   (push.const . record-rtd)
   (call
     (touch.gloc.of wrong-type-argument-message)
     (push.const . "non-opaque record")
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 226346))
   (push)
   (apply.gloc.of assertion-violation "./boot/record.scm" . 226313))
 (set.gloc.of record-rtd)
 (ret.const.unspec))
((close
   (3 0 . make-nested-conser)
   (call
     (call
       (extend.enclose
         (1 0 . loop)
         (call
           (touch.gloc.of rcd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rcd-parent "./boot/record.scm" . 232464))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (ret.close
             (0 1)
             (ret.close
               (0 1)
               (ret.close
                 (0 1)
                 (call
                   (call
                     (call (push.iloc 3 . 0) (apply.iloc (5 . 0) "./boot/record.scm" . 238634))
                     (push)
                     (push.iloc.0 . 0)
                     (push.iloc 2 . 0)
                     (push.subr.gloc.of append 2 "./boot/record.scm" . 239658)
                     (apply.gloc.of apply "./boot/record.scm" . 238627))
                   (push)
                   (call
                     (touch.gloc.of rcd-protocol)
                     (push.iloc 3 . 0)
                     (apply.gloc.of rcd-protocol "./boot/record.scm" . 237603))
                   (apply))
                 (push)
                 (push.iloc.1 . 0)
                 (apply.gloc.of apply "./boot/record.scm" . 237595)))))
         (ret.close
           (0 1)
           (ret.close
             (0 1)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.subr.gloc.of append 2 "./boot/record.scm" . 244776)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of length 1 "./boot/record.scm" . 245789)
             (=.iloc (6 . 2) "./boot/record.scm" . 245786)
             (if.true
               (push.gloc.of tuple)
               (push.iloc 6 . 1)
               (push.iloc.0 . 0)
               (apply.gloc.of apply "./boot/record.scm" . 246810))
             (push.const . "record constructor")
             (push.const . "wrong number of arguments")
             (push.iloc.0 . 0)
             (apply.gloc.of assertion-violation "./boot/record.scm" . 247834))))
       (push.iloc.1 . 0)
       (apply.iloc (0 . 0) "./boot/record.scm" . 231431))
     (apply))
   (push)
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 230406))
   (apply))
 (set.gloc.of make-nested-conser)
 (ret.const.unspec))
((close
   (3 0 . make-simple-conser)
   (push.close
     (0 1)
     (push.iloc.0 . 0)
     (subr.gloc.of length 1 "./boot/record.scm" . 253967)
     (=.iloc (1 . 2) "./boot/record.scm" . 253964)
     (if.true
       (push.gloc.of tuple)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of apply "./boot/record.scm" . 254988))
     (push.const . "record constructor")
     (push.const . "wrong number of arguments")
     (push.iloc.0 . 0)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 256012))
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 251910))
   (apply))
 (set.gloc.of make-simple-conser)
 (ret.const.unspec))
((close
   (2 0 . flat-field-offset)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 260104))
   (push)
   (push.iloc.0 . 1)
   (push.const . 1)
   (ret.subr.gloc.of + "./boot/record.scm" . 260101))
 (set.gloc.of flat-field-offset)
 (ret.const.unspec))
((close
   (2 0 . make-accessor)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 265239)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 265258))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 266273)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 266254))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 266292))
     (push.const . "record accessor")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 268398))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 268370)
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 268341))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 268302)))
 (set.gloc.of make-accessor)
 (ret.const.unspec))
((close
   (2 0 . make-mutator)
   (ret.close
     (2 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 273431)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 273450))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 274465)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 274446))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 274484))
     (push.const . "record mutator")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 276589))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 276561)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of list 2 "./boot/record.scm" . 276605)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 276532))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 276494)))
 (set.gloc.of make-mutator)
 (ret.const.unspec))
((close
   (1 0 . make-predicate)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 281620)
     (if.eq?.ret.const . #t)
     (touch.gloc.of rtd-ancestor?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 282654)
     (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 282635)))
 (set.gloc.of make-predicate)
 (ret.const.unspec))
((close
   (1 0 . record-constructor)
   (call
     (touch.gloc.of record-constructor-descriptor?)
     (push.iloc.0 . 0)
     (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 286729))
   (if.false.call
     (push.const . record-constructor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 287794))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 287753))
   (call
     (touch.gloc.of rcd-rtd)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-rtd "./boot/record.scm" . 288784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of rcd-parent)
     (push.iloc.1 . 0)
     (apply.gloc.of rcd-parent "./boot/record.scm" . 289803))
   (if.true
     (touch.gloc.of make-nested-conser)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 290856))
     (push)
     (apply.gloc.of make-nested-conser "./boot/record.scm" . 290827))
   (touch.gloc.of make-simple-conser)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 291888))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 291880)
   (apply.gloc.of make-simple-conser "./boot/record.scm" . 291851))
 (set.gloc.of record-constructor)
 (ret.const.unspec))
((close
   (1 0 . record-predicate)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 295945))
   (if.false.call
     (push.const . record-predicate)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 297008))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 296969))
   (touch.gloc.of make-predicate)
   (push.iloc.0 . 0)
   (apply.gloc.of make-predicate "./boot/record.scm" . 297989))
 (set.gloc.of record-predicate)
 (ret.const.unspec))
((close
   (2 0 . record-accessor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 302089))
   (if.false.call
     (push.const . record-accssor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 303150))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 303209)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 303113))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 304153))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 304145)
   (subr.gloc.of < 3 "./boot/record.scm" . 304137)
   (if.false.call
     (push.const . record-accssor)
     (push.const . "field index out of range")
     (apply.gloc.of assertion-violation "./boot/record.scm" . 305161))
   (touch.gloc.of make-accessor)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 306200))
   (push)
   (apply.gloc.of make-accessor "./boot/record.scm" . 306181))
 (set.gloc.of record-accessor)
 (ret.const.unspec))
((close
   (2 0 . record-mutator)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 310281))
   (if.false.call
     (push.const . record-mutator)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 311342))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 311401)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 311305))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 312345))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 312337)
   (subr.gloc.of < 3 "./boot/record.scm" . 312329)
   (if.false.call
     (push.const . record-mutator)
     (push.const . "field index out of range")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 313417)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 313353))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of record-field-mutable? "./boot/record.scm" . 314377))
   (if.false.call
     (push.const . record-mutator)
     (push.const . "specified field is immutable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 315469)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 315401))
   (touch.gloc.of make-mutator)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 316439))
   (push)
   (apply.gloc.of make-mutator "./boot/record.scm" . 316421))
 (set.gloc.of record-mutator)
 (ret.const.unspec))
((close
   (3 0 . make-record-type)
   (push.const . type:record-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 320517))
 (set.gloc.of make-record-type)
 (ret.const.unspec))
((close
   (1 0 . record-type?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 324618)
   (const . type:record-type)
   (ret.eq? "./boot/record.scm" . 324613))
 (set.gloc.of record-type?)
 (ret.const.unspec))
((close
   (1 0 . record-type-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 328713))
   (if.false.call
     (push.const . record-type-rtd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 329775))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 329737))
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 330757))
 (set.gloc.of record-type-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-rcd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 334857))
   (if.false.call
     (push.const . record-type-rcd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 335919))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 335881))
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 336901))
 (set.gloc.of record-type-rcd)
 (ret.const.unspec))

;
((call
   (call
     (push.const . &condition)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 6159))
   (push)
   (extend . 1)
   (push.const . &condition)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 7183))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 8197))
 (set.gloc.of &condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition-component)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/condition.scm" . 10292))
 (set.gloc.of compound-condition-component)
 (ret.const.unspec))
((close
   (0 1 . condition)
   (push.const . type:condition)
   (call
     (push.gloc.of append)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of condition? "./boot/condition.scm" . 17438))
         (if.false.call
           (push.const . condition)
           (push.const . "expected condition, but got ~r")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/condition.scm" . 18494)
           (push.iloc.1 . 0)
           (apply.gloc.of assertion-violation "./boot/condition.scm" . 18462))
         (push.iloc.0 . 0)
         (apply.gloc.of simple-conditions "./boot/condition.scm" . 19482))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/condition.scm" . 16403))
     (push)
     (apply.gloc.of apply "./boot/condition.scm" . 15372))
   (push)
   (ret.subr.gloc.of tuple "./boot/condition.scm" . 14341))
 (set.gloc.of condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition?)
   (push.iloc.0 . 0)
   (subr.gloc.of tuple? 1 "./boot/condition.scm" . 24586)
   (if.false.ret)
   (push.const . type:condition)
   (push.iloc.0 . 0)
   (push.const . 0)
   (subr.gloc.of tuple-ref 2 "./boot/condition.scm" . 25631)
   (ret.eq? "./boot/condition.scm" . 25610))
 (set.gloc.of compound-condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-condition?)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/condition.scm" . 29706))
   (if.false.ret)
   (touch.gloc.of rtd-ancestor?)
   (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 30745))
   (push)
   (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 30774))
   (push)
   (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 30730))
 (set.gloc.of simple-condition?)
 (ret.const.unspec))
((close
   (1 0 . condition?)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 34825))
   (if.true.ret)
   (touch.gloc.of compound-condition?)
   (push.iloc.0 . 0)
   (apply.gloc.of compound-condition? "./boot/condition.scm" . 35849))
 (set.gloc.of condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-conditions)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 39948))
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of list "./boot/condition.scm" . 39970))
   (call
     (touch.gloc.of compound-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition? "./boot/condition.scm" . 40972))
   (if.true
     (touch.gloc.of compound-condition-component)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition-component "./boot/condition.scm" . 40996))
   (push.const . simple-conditions)
   (push.const . "expected condition, but got ~r")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/condition.scm" . 43060)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 43020))
 (set.gloc.of simple-conditions)
 (ret.const.unspec))
((close
   (1 0 . condition-predicate)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 47128))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 47113))
   (if.false.call
     (push.const . condition-predicate)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 48179)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 48137))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 50190))
     (if.true
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 51233))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 51214))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 52238))
     (if.true
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of rtd-ancestor?)
         (push.iloc 2 . 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 53307))
         (push)
         (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 53288))
       (call
         (touch.gloc.of compound-condition-component)
         (push.iloc.0 . 0)
         (apply.gloc.of compound-condition-component "./boot/condition.scm" . 54292))
       (push)
       (apply.gloc.of any1 "./boot/condition.scm" . 53262))
     (ret.const . #f)))
 (set.gloc.of condition-predicate)
 (ret.const.unspec))
((close
   (2 0 . wrong-type)
   (push.const . "condition accessor")
   (push.const . "expected condition of a subtype of ~s, but got ~r")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 3 "./boot/condition.scm" . 62515)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 62473))
 (set.gloc.of wrong-type\x60;2)
 (close
   (2 0 . condition-accessor)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 64536))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 64521))
   (if.false.call
     (push.const . condition-accessor)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 65586)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 65545))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 68622))
     (if.true
       (call
         (call
           (touch.gloc.of rtd-ancestor?)
           (push.iloc.1 . 0)
           (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 69669))
           (push)
           (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 69650))
         (if.true.ret)
         (touch.gloc.of wrong-type\x60;2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 69687))
       (push.iloc.0 . 0)
       (apply.iloc (1 . 1) "./boot/condition.scm" . 70670))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 71694))
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of rtd-ancestor?)
             (push.iloc 2 . 0)
             (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 72775))
             (push)
             (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 72756))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call
           (touch.gloc.of compound-condition-component)
           (push.iloc.0 . 0)
           (apply.gloc.of compound-condition-component "./boot/condition.scm" . 73755))
         (push)
         (apply.gloc.of any1 "./boot/condition.scm" . 72725))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (apply.iloc (2 . 1) "./boot/condition.scm" . 72718))
       (touch.gloc.of wrong-type\x60;2)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 76821))
     (touch.gloc.of wrong-type\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 78862)))
 (set.gloc.of condition-accessor)
 (ret.const.unspec))
((close
   (1 0 . list-parents)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/condition.scm" . 86025))
 (set.gloc.of list-parents\x60;2)
 (close
   (2 0 . loop)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-parent "./boot/condition.scm" . 87058))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of loop\x60;7)
     (push.iloc.0 . 0)
     (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 88111))
     (push)
     (iloc.1 . 1)
     (push.cons)
     (apply.gloc.of loop\x60;7 "./boot/condition.scm" . 88097))
   (push.cdr.iloc (1 . 1) "./boot/condition.scm" . 89120)
   (ret.subr.gloc.of reverse "./boot/condition.scm" . 89111))
 (set.gloc.of loop\x60;7)
 (close
   (2 0 . describe-condition)
   (call (push.iloc.0 . 1) (apply.gloc.of condition? "./boot/condition.scm" . 91148))
   (if.true
     (subr.gloc.of make-string-output-port 0)
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . "  #<condition~!")
     (subr.gloc.of format 2 "./boot/condition.scm" . 93198)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 96295))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of list-parents\x60;2)
           (push.iloc.0 . 0)
           (apply.gloc.of list-parents\x60;2 "./boot/condition.scm" . 98349))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of record-type-field-names "./boot/condition.scm" . 99386))
         (push)
         (push.subr.gloc.of vector-length 1 "./boot/condition.scm" . 99371)
         (extend . 2)
         (push.iloc 3 . 0)
         (push.const . "~%    ~a")
         (call (push.iloc.1 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 97322))
         (push)
         (subr.gloc.of format 3 "./boot/condition.scm" . 100384)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (push.iloc 3 . 0)
           (push.const . " ~s")
           (push.iloc.0 . 0)
           (ret.subr.gloc.of format "./boot/condition.scm" . 101429))
         (=n.iloc (0 . 1) 1 "./boot/condition.scm" . 102439)
         (if.true
           (push.iloc 3 . 0)
           (push.const . ": ~s")
           (call
             (push.iloc 2 . 0)
             (call
               (push.iloc.1 . 0)
               (push.const . 0)
               (apply.gloc.of record-accessor "./boot/condition.scm" . 103483))
             (apply))
           (push)
           (ret.subr.gloc.of format "./boot/condition.scm" . 103463))
         (>n.iloc (0 . 1) 1 "./boot/condition.scm" . 104487)
         (if.true
           (extend.enclose+
             (2 0 . loop)
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.iloc 5 . 0)
             (push.const . "~%     ~a: ~s")
             (push.car.iloc (0 . 1) "./boot/condition.scm" . 109646)
             (call
               (push.iloc 4 . 0)
               (call
                 (push.iloc 3 . 0)
                 (push.iloc.0 . 0)
                 (apply.gloc.of record-accessor "./boot/condition.scm" . 109657))
               (apply))
             (push)
             (subr.gloc.of format 4 "./boot/condition.scm" . 109618)
             (push.n+.iloc (0 . 0) 1 "./boot/condition.scm" . 110648)
             (push.cdr.iloc (0 . 1) "./boot/condition.scm" . 110656)
             (apply.iloc+ (1 . 0) "./boot/condition.scm" . 110642))
           (push.const . 0)
           (call
             (push.iloc 2 . 0)
             (apply.gloc.of record-type-field-names "./boot/condition.scm" . 105536))
           (push)
           (push.subr.gloc.of vector->list 1 "./boot/condition.scm" . 105522)
           (apply.iloc+ (0 . 0) "./boot/condition.scm" . 106537))
         (ret.const.unspec))
       (call (push.iloc.1 . 1) (apply.gloc.of simple-conditions "./boot/condition.scm" . 94233))
       (push)
       (apply.gloc.of for-each "./boot/condition.scm" . 92172))
     (push.iloc.0 . 0)
     (push.const . "~%   >")
     (subr.gloc.of format 2 "./boot/condition.scm" . 112654)
     (push.iloc.1 . 0)
     (push.const . "~a~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/condition.scm" . 113698)
     (ret.subr.gloc.of format "./boot/condition.scm" . 113678))
   (push.iloc.0 . 0)
   (push.const . "~s~!")
   (push.iloc.0 . 1)
   (ret.subr.gloc.of format "./boot/condition.scm" . 115724))
 (set.gloc.of describe-condition)
 (ret.const.unspec))
((call
   (call
     (push.const . &message)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 118837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable message)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 118798))
   (push)
   (extend . 1)
   (push.const . &message)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 119864))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 119824))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 120839))
 (set.gloc.of &message)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 121908))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 121888))
 (set.gloc.of make-message-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 122929))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 122908))
 (set.gloc.of message-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123951))
   (push)
   (call
     (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123995))
     (push)
     (push.const . 0)
     (apply.gloc.of record-accessor "./boot/condition.scm" . 123978))
   (push)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 123931))
 (set.gloc.of condition-message)
 (ret.const.unspec))
((call
   (call
     (push.const . &warning)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 127029))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 126990))
   (push)
   (extend . 1)
   (push.const . &warning)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 128056))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 128016))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 129031))
 (set.gloc.of &warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 130090))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 130070))
 (set.gloc.of make-warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 131111))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 131090))
 (set.gloc.of warning?)
 (ret.const.unspec))
((call
   (call
     (push.const . &serious)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 134197))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 134158))
   (push)
   (extend . 1)
   (push.const . &serious)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 135224))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 135184))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 136199))
 (set.gloc.of &serious)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 137268))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 137248))
 (set.gloc.of make-serious-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 138289))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 138268))
 (set.gloc.of serious-condition?)
 (ret.const.unspec))
((call
   (call
     (push.const . &error)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 141363))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 141326))
   (push)
   (extend . 1)
   (push.const . &error)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 142392))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 142352))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 143367))
 (set.gloc.of &error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 144424))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 144404))
 (set.gloc.of make-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 145445))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 145424))
 (set.gloc.of error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &violation)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 148535))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 148494))
   (push)
   (extend . 1)
   (push.const . &violation)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 149560))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 149520))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 150535))
 (set.gloc.of &violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 151596))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 151576))
 (set.gloc.of make-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 152617))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 152596))
 (set.gloc.of violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &assertion)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 155703))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 155662))
   (push)
   (extend . 1)
   (push.const . &assertion)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 156728))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 156688))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 157703))
 (set.gloc.of &assertion)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 158774))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 158754))
 (set.gloc.of make-assertion-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 159795))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 159774))
 (set.gloc.of assertion-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &irritants)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 162871))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable irritants)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 162830))
   (push)
   (extend . 1)
   (push.const . &irritants)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 163896))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 163856))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 164871))
 (set.gloc.of &irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 165935))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 165918))
 (set.gloc.of &irritants-irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 166966))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 166946))
 (set.gloc.of make-irritants-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 167987))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 167966))
 (set.gloc.of irritants-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 169009))
   (push)
   (push.gloc.of &irritants-irritants)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 168989))
 (set.gloc.of condition-irritants)
 (ret.const.unspec))
((call
   (call
     (push.const . &who)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 172081))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable who)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 172046))
   (push)
   (extend . 1)
   (push.const . &who)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 173112))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 173072))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 174087))
 (set.gloc.of &who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 175139))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 175122))
 (set.gloc.of &who-who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 176176))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 176156))
 (set.gloc.of make-who-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 177197))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 177176))
 (set.gloc.of who-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 178219))
   (push)
   (push.gloc.of &who-who)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 178199))
 (set.gloc.of condition-who)
 (ret.const.unspec))
((call
   (call
     (push.const . &non-continuable)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 181309))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 181262))
   (push)
   (extend . 1)
   (push.const . &non-continuable)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 182328))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 182288))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 183303))
 (set.gloc.of &non-continuable)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 184380))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 184360))
 (set.gloc.of make-non-continuable-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 185401))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 185380))
 (set.gloc.of non-continuable-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &implementation-restriction)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 188488))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 188430))
   (push)
   (extend . 1)
   (push.const . &implementation-restriction)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 189496))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 189456))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 190471))
 (set.gloc.of &implementation-restriction)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 192535))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 192515))
 (set.gloc.of make-implementation-restriction-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 194584))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 194563))
 (set.gloc.of implementation-restriction-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &lexical)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 197685))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 197646))
   (push)
   (extend . 1)
   (push.const . &lexical)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 198712))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 198672))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 199687))
 (set.gloc.of &lexical)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 200756))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 200736))
 (set.gloc.of make-lexical-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 201777))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 201756))
 (set.gloc.of lexical-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &syntax)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 204852))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable form) (immutable subform)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 204814))
   (push)
   (extend . 1)
   (push.const . &syntax)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 205880))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 205840))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 206855))
 (set.gloc.of &syntax)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 207911))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 207894))
 (set.gloc.of &syntax-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 208938))
   (push)
   (push.const . 1)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 208921))
 (set.gloc.of &syntax-subform)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 209971))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 209951))
 (set.gloc.of make-syntax-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 210992))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 210971))
 (set.gloc.of syntax-violation?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 212019))
   (push)
   (push.gloc.of &syntax-form)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 211999))
 (set.gloc.of syntax-violation-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 213046))
   (push)
   (push.gloc.of &syntax-subform)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 213026))
 (set.gloc.of syntax-violation-subform)
 (ret.const.unspec))
((call
   (call
     (push.const . &undefined)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 216119))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 216078))
   (push)
   (extend . 1)
   (push.const . &undefined)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 217144))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 217104))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 218119))
 (set.gloc.of &undefined)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 219190))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 219170))
 (set.gloc.of make-undefined-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 220211))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 220190))
 (set.gloc.of undefined-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 223281))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 223246))
   (push)
   (extend . 1)
   (push.const . &i/o)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 224312))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 224272))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 225287))
 (set.gloc.of &i/o)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 226348))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 226328))
 (set.gloc.of make-i/o-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 227369))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 227348))
 (set.gloc.of i/o-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-read)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 230454))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 230414))
   (push)
   (extend . 1)
   (push.const . &i/o-read)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 231480))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 231440))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 232455))
 (set.gloc.of &i/o-read)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 233521))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 233501))
 (set.gloc.of make-i/o-read-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 234542))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 234521))
 (set.gloc.of i/o-read-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-write)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 237623))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 237582))
   (push)
   (extend . 1)
   (push.const . &i/o-write)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 238648))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 238608))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 239623))
 (set.gloc.of &i/o-write)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 240690))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 240670))
 (set.gloc.of make-i/o-write-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 241711))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 241690))
 (set.gloc.of i/o-write-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-invalid-position)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 244802))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable position)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 244750))
   (push)
   (extend . 1)
   (push.const . &i/o-invalid-position)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 245816))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 245776))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 246791))
 (set.gloc.of &i/o-invalid-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 248852))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 248835))
 (set.gloc.of &i/o-invalid-position-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 250903))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 250883))
 (set.gloc.of make-i/o-invalid-position-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 251962))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 251941))
 (set.gloc.of i/o-invalid-position-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 253975))
   (push)
   (push.gloc.of &i/o-invalid-position-position)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 253955))
 (set.gloc.of i/o-error-position)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-filename)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 257082))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable filename)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 257038))
   (push)
   (extend . 1)
   (push.const . &i/o-filename)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 258104))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 258064))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 259079))
 (set.gloc.of &i/o-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 260145))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 260128))
 (set.gloc.of &i/o-filename-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 261173))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 261153))
 (set.gloc.of make-i/o-filename-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 262194))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 262173))
 (set.gloc.of i/o-filename-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 263216))
   (push)
   (push.gloc.of &i/o-filename-filename)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 263196))
 (set.gloc.of i/o-error-filename)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-protection)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 266305))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 266254))
   (push)
   (extend . 1)
   (push.const . &i/o-file-protection)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 267320))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 267280))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 268295))
 (set.gloc.of &i/o-file-protection)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 270359))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 270339))
 (set.gloc.of make-i/o-file-protection-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 271417))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 271396))
 (set.gloc.of i/o-file-protection-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-is-read-only)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 274499))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 274446))
   (push)
   (extend . 1)
   (push.const . &i/o-file-is-read-only)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 275512))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 275472))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 276487))
 (set.gloc.of &i/o-file-is-read-only)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 277566))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 277546))
 (set.gloc.of make-i/o-file-is-read-only-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 278587))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 278566))
 (set.gloc.of i/o-file-is-read-only-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-already-exists)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 281669))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 281614))
   (push)
   (extend . 1)
   (push.const . &i/o-file-already-exists)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 282680))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 282640))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 283655))
 (set.gloc.of &i/o-file-already-exists)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 284736))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 284716))
 (set.gloc.of make-i/o-file-already-exists-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 285757))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 285736))
 (set.gloc.of i/o-file-already-exists-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-does-not-exist)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 288837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 288782))
   (push)
   (extend . 1)
   (push.const . &i/o-file-does-not-exist)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 289848))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 289808))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 290823))
 (set.gloc.of &i/o-file-does-not-exist)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 291904))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 291884))
 (set.gloc.of make-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 292925))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 292904))
 (set.gloc.of i/o-file-does-not-exist-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-port)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 295990))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable port)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 295950))
   (push)
   (extend . 1)
   (push.const . &i/o-port)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 297016))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 296976))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 297991))
 (set.gloc.of &i/o-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 299049))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 299032))
 (set.gloc.of &i/o-port-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 300081))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 300061))
 (set.gloc.of make-i/o-port-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 301102))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 301081))
 (set.gloc.of i/o-port-error?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 302124))
   (push)
   (push.gloc.of &i/o-port-port)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 302104))
 (set.gloc.of i/o-error-port)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-decoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 305210))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 305166))
   (push)
   (extend . 1)
   (push.const . &i/o-decoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 306232))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 306192))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 307207))
 (set.gloc.of &i/o-decoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 308277))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 308257))
 (set.gloc.of make-i/o-decoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 309298))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 309277))
 (set.gloc.of i/o-decoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-encoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 312378))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable char)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 312334))
   (push)
   (extend . 1)
   (push.const . &i/o-encoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 313400))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 313360))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 314375))
 (set.gloc.of &i/o-encoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 315437))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 315420))
 (set.gloc.of &i/o-encoding-char)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 316469))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 316449))
 (set.gloc.of make-i/o-encoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 317490))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 317469))
 (set.gloc.of i/o-encoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 318517))
   (push)
   (push.gloc.of &i/o-encoding-char)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 318497))
 (set.gloc.of i/o-encoding-error-char)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-infinities)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 321595))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 321550))
   (push)
   (extend . 1)
   (push.const . &no-infinities)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 322616))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 322576))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 323591))
 (set.gloc.of &no-infinities)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 324666))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 324646))
 (set.gloc.of make-no-infinities-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 325687))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 325666))
 (set.gloc.of no-infinities-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-nans)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 328757))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 328718))
   (push)
   (extend . 1)
   (push.const . &no-nans)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 329784))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 329744))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 330759))
 (set.gloc.of &no-nans)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 331828))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 331808))
 (set.gloc.of make-no-nans-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 332849))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 332828))
 (set.gloc.of no-nans-violation?)
 (ret.const.unspec))

;
((call (push.const . 100) (apply.gloc.of make-parameter "./boot/pp.scm" . 62498))
 (set.gloc.of pretty-print-line-length)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/pp.scm" . 63525))
 (set.gloc.of pretty-print-initial-indent)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 64548))
 (set.gloc.of pretty-print-maximum-lines)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 65572))
 (set.gloc.of pretty-print-unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0 . indent-type3?)
   (push.iloc.0 . 0)
   (push.const do let-optionals)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 87051))
 (set.gloc.of indent-type3?\x60;4)
 (close
   (1 0 . parse-list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 139289)
   (if.null?
     (call
       (touch.gloc.of parse\x60;4)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 140319)
       (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 140312))
     (push)
     (ret.subr.gloc.of list "./boot/pp.scm" . 140306))
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 141337)
   (if.pair?
     (call
       (touch.gloc.of parse\x60;4)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 142368)
       (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 142361))
     (push)
     (push.const . #\;)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 142395)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 142383))
     (push)
     (ret.subr.gloc.of cons* "./boot/pp.scm" . 142354))
   (call
     (touch.gloc.of parse\x60;4)
     (push.car.iloc (0 . 0) "./boot/pp.scm" . 144415)
     (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 144408))
   (push)
   (push.const . #\;)
   (push.const . ".")
   (push.const . #\;)
   (call
     (touch.gloc.of parse\x60;4)
     (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 144445)
     (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 144438))
   (push)
   (ret.subr.gloc.of list "./boot/pp.scm" . 144402))
 (set.gloc.of parse-list\x60;4)
 (close
   (1 0 . infinite-print?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (3 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/pp.scm" . 197656)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/pp.scm" . 198680))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 200735)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/pp.scm" . 202795)
           (push.iloc.0 . 0)
           (push.iloc.1 . 2)
           (apply.iloc (2 . 0) "./boot/pp.scm" . 202789))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/pp.scm" . 203819)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/pp.scm" . 203813))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/pp.scm" . 204831)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 205855)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 2)
           (apply.iloc (3 . 0) "./boot/pp.scm" . 207923))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 207948)
         (apply.gloc.of any1 "./boot/pp.scm" . 207905))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/pp.scm" . 208927)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 209951)
         (>n.iloc (0 . 2) 0 "./boot/pp.scm" . 210980)
         (if.false.ret)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (push.n+.iloc (0 . 2) -1 "./boot/pp.scm" . 212048)
         (extend . 2)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (apply.iloc (3 . 0) "./boot/pp.scm" . 213048))
         (push.iloc.1 . 0)
         (push.subr.gloc.of tuple->list 1 "./boot/pp.scm" . 213073)
         (apply.gloc.of any1 "./boot/pp.scm" . 213030))
       (ret.const . #f))
     (push.iloc 2 . 0)
     (push.const)
     (subr.gloc.of record-print-nesting-limit 0)
     (push)
     (apply.iloc (0 . 0) "./boot/pp.scm" . 196626))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of infinite-print?\x60;4)
 (close
   (2 0 . fits?)
   (>=n.iloc (0 . 0) 0 "./boot/pp.scm" . 91152)
   (if.false.ret)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 1) "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of \x2E;cdar 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of \x2E;cddar 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 1)
     (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 2 . 1)
     (subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 3 . 1)
     (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc 3 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&BREAK)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true.ret.const . #t)
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&FLAT)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.n+.iloc (4 . 0) -1 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (ret.subr.gloc.of string? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of - 2 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&GROUP)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 92180)
     (push.const . \x2E;&FLAT)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&NEST)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;cadr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of + 2 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;cddr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (iloc.0 . 0)
   (if.true
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 92180)
     (extend . 2)
     (touch.gloc.of fits?\x60;4)
     (push.iloc 5 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 5 . 1)
     (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (5 . 1) "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (ret.const . #f))
 (set.gloc.of fits?\x60;4)
 (close
   (1 0 . indent-type2?)
   (push.iloc.0 . 0)
   (push.const if cond case and or set! import export cons map for-each exists for-all)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 82955))
 (set.gloc.of indent-type2?\x60;4)
 (close
   (1 0 . indent-type1?)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     define-macro
     define-inline
     define-constant
     syntax-rules
     syntax-case
     with-syntax
     lambda
     let-syntax
     letrec-syntax
     let
     letrec
     let*
     letrec
     letrec*
     let-values
     let*-values
     destructuring-match
     parameterize)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 74763))
 (set.gloc.of indent-type1?\x60;4)
 (close
   (1 0 . parse)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (cddr.iloc (1 . 0) "./boot/pp.scm" . 149522)
       (ret.null? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (cddr.iloc (2 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "'")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quasiquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "`")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote-splicing)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",@")
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . let)
       (if.not.eq?.ret.const . #f)
       (cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (if.not.symbol?.ret.const . #f)
       (push.iloc 3 . 0)
       (subr.gloc.of \x2E;cdddr 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;cdddr 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(let ~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . 4)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type1?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type1?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type2?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type2?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . 2)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type3?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type3?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (push.iloc 3 . 0)
       (subr.gloc.of \x2E;cdddr 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;cdddr 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.car.iloc (4 . 0) "./boot/pp.scm" . 149522)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 5 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 3 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of symbol? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . \x2E;&GROUP)
       (push.const . "(")
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc 3 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
     (push.const . \x2E;&GROUP)
     (push.const . "(")
     (push.const . \x2E;&NEST)
     (push.const . 1)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.iloc 3 . 0)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 149522)
     (push.const ")")
     (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/pp.scm" . 184338)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/pp.scm" . 185369)
     (push.const . 0)
     (subr.gloc.of = 2 "./boot/pp.scm" . 185366)
     (if.true.ret.const . "#()")
     (push.const . \x2E;&GROUP)
     (push.const . "#(")
     (push.const . \x2E;&NEST)
     (push.const . 2)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 187453)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 187441))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 185362)
     (push.const ")")
     (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 185362))
   (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/pp.scm" . 188434))
   (if.true
     (push.const . "~u")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/pp.scm" . 189458))
   (push.const . "~s")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/pp.scm" . 191506))
 (set.gloc.of parse\x60;4)
 (close
   (1 0 . symbol->length)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/pp.scm" . 134170)
   (ret.subr.gloc.of string-length "./boot/pp.scm" . 134155))
 (set.gloc.of symbol->length\x60;4)
 (close
   (1 1 . pretty-print)
   (call
     (iloc.0 . 1)
     (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of car "./boot/pp.scm" . 69666))
     (ret.subr.gloc.of current-output-port "./boot/pp.scm" . 69677))
   (push)
   (call
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70686))
     (if.false.ret)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70718))
     (push)
     (push.const . 1)
     (ret.subr.gloc.of - "./boot/pp.scm" . 70715))
   (push)
   (extend . 2)
   (extend.enclose
     (3 0 . print)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.gloc.of string?)
     (extend . 1)
     (call
       (iloc.1 . 2)
       (if.not.pair?.ret.const . #f)
       (car.iloc (1 . 2) "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of \x2E;cdar 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of \x2E;cddar 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 2 . 2)
       (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 3 . 2)
       (subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 4 . 2)
       (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&BREAK)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (call
         (push.iloc 8 . 1)
         (const . #f)
         (if.eq?.ret.const . #t)
         (push.iloc 8 . 1)
         (push.const . 0)
         (ret.subr.gloc.of > "./boot/pp.scm" . 104463))
       (if.true
         (call
           (iloc 8 . 1)
           (if.false.ret)
           (n+.iloc (8 . 1) -1 "./boot/pp.scm" . 104463)
           (set.iloc 8 . 1)
           (ret.const.unspec))
         (push.iloc 8 . 0)
         (push.const . #\linefeed)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
         (call
           (extend.enclose+
             (1 0 . loop)
             (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.iloc 10 . 0)
             (push.const . #\space)
             (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 104463)
             (apply.iloc+ (1 . 0) "./boot/pp.scm" . 104463))
           (push.iloc.1 . 1)
           (apply.iloc+ (0 . 0) "./boot/pp.scm" . 104463))
         (push.iloc 6 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
       (ret.const.unspec))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&FLAT)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (extend . 1)
       (push.iloc 8 . 0)
       (push.const . #\space)
       (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.n+.iloc (6 . 1) 1 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (apply.iloc (4 . 0) "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 8 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of put-string 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&GROUP)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 104463)
       (extend . 3)
       (push.iloc.0 . 2)
       (push.const . \x2E;&FLAT)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (iloc.0 . 0)
       (push.cons)
       (extend . 1)
       (call
         (touch.gloc.of fits?\x60;4)
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.subr.gloc.of - 2 "./boot/pp.scm" . 104463)
         (push.iloc.0 . 0)
         (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 104463))
       (if.true
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
       (push.iloc 7 . 0)
       (push.iloc 7 . 1)
       (push.iloc.1 . 2)
       (push.const . \x2E;&BREAK)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (iloc.1 . 0)
       (push.cons)
       (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of \x2E;cdddar 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&NEST)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;cadr 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;cddr 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.cons)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (iloc.0 . 0)
     (if.true
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;cadar 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of \x2E;caar 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;car 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 6 . 2)
       (push.subr.gloc.of \x2E;caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;cdr 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (push.cdr.iloc (6 . 2) "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 104463)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (ret.const . #f))
   (call
     (call
       (touch.gloc.of infinite-print?\x60;4)
       (push.iloc 2 . 0)
       (apply.gloc.of infinite-print?\x60;4 "./boot/pp.scm" . 217099))
     (if.true
       (push.iloc.1 . 0)
       (push.const . "~w")
       (push.iloc 2 . 0)
       (ret.subr.gloc.of format "./boot/pp.scm" . 218123))
     (call (apply.gloc.of pretty-print-line-length "./boot/pp.scm" . 219160))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of collect-notify 0 "./boot/pp.scm" . 221199)
       (set.iloc 1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (push.close
       (0 0)
       (push.iloc 2 . 0)
       (push.const . 0)
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 221218))
       (push)
       (push.const . \x2E;&FLAT)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc 5 . 0)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 221256))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 221199)
       (push.subr.gloc.of \x2E;list 1 "./boot/pp.scm" . 221199)
       (apply.iloc (3 . 0) "./boot/pp.scm" . 221199))
     (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (apply.gloc.of \x2E;dynamic-wind "./boot/pp.scm" . 221199))
   (call
     (iloc.1 . 1)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of <= "./boot/pp.scm" . 222240))
   (if.true
     (push.iloc.1 . 0)
     (push.const . #\linefeed)
     (subr.gloc.of put-char 2 "./boot/pp.scm" . 223246)
     (call
       (extend.enclose+
         (1 0 . loop)
         (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 224321)
         (if.false.ret)
         (push.iloc 3 . 0)
         (push.const . #\space)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 224329)
         (if.false.ret)
         (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 224359)
         (apply.iloc+ (1 . 0) "./boot/pp.scm" . 224353))
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 224284))
       (push)
       (apply.iloc+ (0 . 0) "./boot/pp.scm" . 224270))
     (push.iloc.1 . 0)
     (push.const . "  ...")
     (ret.subr.gloc.of put-string "./boot/pp.scm" . 225294))
   (ret.const.unspec))
 (set.gloc.of pretty-print)
 (ret.const.unspec))

;
((const . ypsilon-0.9.6-080804)
 (set.gloc.of auto-compile-cache-validation-signature)
 (ret.const.unspec))
((close
   (1 0 . core-eval)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of backtrace 0 "./boot/eval.scm" . 10247)
     (set.iloc 1 . 0)
     (push.const . #f)
     (ret.subr.gloc.of backtrace "./boot/eval.scm" . 10247))
   (push.close
     (0 0)
     (touch.gloc.of interpret-coreform)
     (push.iloc 2 . 0)
     (apply.gloc.of interpret-coreform "./boot/eval.scm" . 10247))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of backtrace "./boot/eval.scm" . 10247))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 10247))
 (set.gloc.of core-eval)
 (ret.const.unspec))
((close
   (1 0 . compile)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
     (set.iloc 1 . 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 1)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
   (push.close
     (0 0)
     (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 16409))
     (push)
     (apply.gloc.of compile-coreform "./boot/eval.scm" . 16391))
   (push.close
     (0 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 0)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 16391))
 (set.gloc.of compile)
 (ret.const.unspec))
((close
   (1 0 . interpret)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call
     (push.const . #f)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
       (set.iloc 1 . 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 1)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
     (push.close
       (0 0)
       (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 23584))
       (push)
       (apply.gloc.of compile-coreform "./boot/eval.scm" . 23566))
     (push.close
       (0 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 0)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 23566))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 24583))
 (set.gloc.of interpret)
 (ret.const.unspec))
((close
   (1 0 . interpret-coreform)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call (push.iloc.0 . 0) (apply.gloc.of compile-coreform "./boot/eval.scm" . 28704))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 29703))
 (set.gloc.of interpret-coreform)
 (ret.const.unspec))
((close
   (0 1 . environment)
   (call
     (touch.gloc.of parse-imports)
     (push.const . environment)
     (iloc.0 . 0)
     (push.cons)
     (push.iloc.0 . 0)
     (apply.gloc.of parse-imports "./boot/eval.scm" . 33797))
   (push.const . type:eval-environment)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/eval.scm" . 34821))
 (set.gloc.of environment)
 (ret.const.unspec))
((close
   (2 0 . eval)
   (call
     (touch.gloc.of environment?)
     (push.iloc.0 . 1)
     (apply.gloc.of environment? "./boot/eval.scm" . 38924))
   (if.true
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 40974)
       (set.iloc 1 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 40974))
     (push.close
       (0 0)
       (touch.gloc.of interpret)
       (push.iloc 2 . 0)
       (apply.gloc.of interpret "./boot/eval.scm" . 40974))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 40974))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 40974))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 43029)
   (push.const . type:eval-environment)
   (subr.gloc.of eq? 2 "./boot/eval.scm" . 43024)
   (if.false.call
     (push.const . eval)
     (push.const . "expected environment, but got ~r, as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/eval.scm" . 44075)
     (apply.gloc.of assertion-violation "./boot/eval.scm" . 44048))
   (touch.gloc.of interpret)
   (push.const . begin)
   (push.const . library)
   (push.const \x2E;R6RS-EVAL)
   (push.const export)
   (push.const . import)
   (push.const
     rename
     (only (core primitives) set-top-level-value! string->symbol)
     (set-top-level-value! \x2E;SET-TOP-LEVEL-VALUE!)
     (string->symbol \x2E;STRING->SYMBOL))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 53286)
   (push.subr.gloc.of \x2E;cons* 3 "./boot/eval.scm" . 45068)
   (push.const . \x2E;SET-TOP-LEVEL-VALUE!)
   (push.const \x2E;STRING->SYMBOL ".R6RS-EVAL-RESULT")
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 3 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 5 "./boot/eval.scm" . 45068)
   (push.const . let)
   (push.const (result \x2E;R6RS-EVAL-RESULT))
   (push.const \x2E;set-top-level-value! '\x2E;R6RS-EVAL-RESULT \x2E;&UNDEF)
   (push.const . \x2E;unintern-scheme-library)
   (push.const . quote)
   (call
     (touch.gloc.of generate-library-id)
     (push.const \x2E;R6RS-EVAL)
     (apply.gloc.of generate-library-id "./boot/eval.scm" . 57400))
   (push)
   (push.subr.gloc.of \x2E;list 2 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 2 "./boot/eval.scm" . 45068)
   (push.const result)
   (push.subr.gloc.of \x2E;cons* 5 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 3 "./boot/eval.scm" . 45068)
   (apply.gloc.of interpret "./boot/eval.scm" . 45068))
 (set.gloc.of eval)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 60445))
 (set.gloc.of scheme-load-verbose)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/eval.scm" . 61467))
 (set.gloc.of scheme-load-paths)
 (ret.const.unspec))
((close
   (1 0 . expand-path)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 65564)
     (push.const . 1)
     (subr.gloc.of > 2 "./boot/eval.scm" . 65561)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 65594)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 65588))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 66595)
     (push.const . #\~)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 66587))
   (if.true
     (push.const . "~a~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 67613))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 67648)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 67630)
     (ret.subr.gloc.of format "./boot/eval.scm" . 67598))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 68643)
     (push.const . #\.)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 68635))
   (if.true
     (push.const . "~a~/")
     (subr.gloc.of current-directory 0)
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 69699)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 69681)
     (ret.subr.gloc.of format "./boot/eval.scm" . 69646))
   (push.iloc.1 . 0)
   (push.const . ".")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 70670)
   (if.true
     (push.const . "~/")
     (subr.gloc.of current-directory 0)
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 71694))
   (push.iloc.1 . 0)
   (push.const . "~")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 72718)
   (if.true
     (push.const . "~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 73755))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 73742))
   (push.const . "~/")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 75790))
 (set.gloc.of expand-path)
 (ret.const.unspec))
((close
   (1 0 . path-not-found)
   (push.const . load)
   (push.const . "~a~/~a not found")
   (push.const . #\")
   (push.iloc.0 . 0)
   (push.const . #\")
   (push.subr.gloc.of format 4 "./boot/eval.scm" . 82980)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 82953))
 (set.gloc.of path-not-found\x60;2)
 (close
   (1 0 . confirm-path)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 87054)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of confirm-path\x60;2)
 (close
   (1 0 . locate-load-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 89103)
   (push.const . 0)
   (subr.gloc.of = 2 "./boot/eval.scm" . 89100)
   (if.true
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 90124))
   (call
     (push.iloc.0 . 0)
     (push.const . ":")
     (subr.gloc.of string-contains 2 "./boot/eval.scm" . 91152)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 91185)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 91179))
   (if.true
     (call
       (touch.gloc.of confirm-path\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 92176))
     (if.true.ret)
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 92196))
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 93202)
   (push.const #\. #\~)
   (subr.gloc.of memq 2 "./boot/eval.scm" . 93196)
   (if.true
     (call
       (touch.gloc.of confirm-path\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/eval.scm" . 94238))
       (push)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 94224))
     (if.true.ret)
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 94258))
   (call
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of confirm-path\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (push.const . "/")
         (push.iloc.1 . 0)
         (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 95289)
         (apply.gloc.of expand-path "./boot/eval.scm" . 95276))
       (push)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 95262))
     (push.const . ".")
     (call (apply.gloc.of scheme-load-paths "./boot/eval.scm" . 96284))
     (push.cons)
     (apply.gloc.of any1 "./boot/eval.scm" . 95244))
   (if.true.ret)
   (touch.gloc.of path-not-found\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 98316))
 (set.gloc.of locate-load-file)
 (ret.const.unspec))
((close
   (1 0 . load-file-has-r6rs-comment?)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 103431)
     (set.iloc 1 . 0)
     (push.const . #t)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 103431))
   (push.close
     (0 0)
     (call
       (touch.gloc.of open-script-input-port)
       (call
         (touch.gloc.of locate-load-file)
         (push.iloc 2 . 0)
         (apply.gloc.of locate-load-file "./boot/eval.scm" . 103467))
       (push)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 103443))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . load)
     (subr.gloc.of core-read 3 "./boot/eval.scm" . 104457)
     (push.iloc.0 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 105481)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (ret.subr.gloc.of not "./boot/eval.scm" . 106505))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 103431))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 103431))
 (set.gloc.of load-file-has-r6rs-comment?)
 (ret.const.unspec))
((close
   (1 0 . load)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/eval.scm" . 110604)
   (if.true
     (call
       (touch.gloc.of auto-compile-cache-update)
       (apply.gloc.of auto-compile-cache-update "./boot/eval.scm" . 111628))
     (touch.gloc.of load-scheme-library)
     (push.iloc.0 . 0)
     (apply.gloc.of load-scheme-library "./boot/eval.scm" . 112652))
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 114716))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 115731))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 115753))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 116762))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 119834))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 120858)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 121882))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 123930))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 131093))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (call
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 132149)
           (if.false.ret)
           (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 132161))
         (push)
         (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 132119)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 133155)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 134176)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 135200))
         (call
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 137248))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 138272))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 131093))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 131093))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 127025))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 116750))
 (set.gloc.of load)
 (ret.const.unspec))
((close
   (1 0 . load-r6rs)
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 142357))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 143372))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 143394))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 144403))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 147475))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 148499)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 149523))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 151571))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 158734))
     (push.close
       (0 0)
       (call
         (subr.gloc.of backtrace 0 "./boot/eval.scm" . 158764)
         (if.false.ret)
         (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 158776))
       (push)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 160796)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 161817)
         (if.true
           (push.iloc 6 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 162841)
           (call
             (touch.gloc.of expand-top-level-program)
             (push.iloc.1 . 0)
             (push.subr.gloc.of reverse 1 "./boot/eval.scm" . 163906)
             (push.const)
             (apply.gloc.of expand-top-level-program "./boot/eval.scm" . 163880))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/eval.scm" . 164891))
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 165915))
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 167961))
       (push.const)
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 159758))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 158734))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 154666))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 144391))
 (set.gloc.of load-r6rs)
 (ret.const.unspec))
((close
   (1 0 . load-cache)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 172042))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 172064))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 173073))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 176138)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 177162))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-environment 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 1)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 2)
       (push.const . #f)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 183308)
       (push.const . #f)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 183308))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (push.iloc 5 . 0)
         (push.const . #f)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 184346)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 185367)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 186391))
         (call
           (touch.gloc.of run-vmi)
           (push.const 1 . 0)
           (iloc.0 . 0)
           (push.cons)
           (apply.gloc.of run-vmi "./boot/eval.scm" . 188439))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 189463))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 183308))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 1)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 2)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 183308))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 182308))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 173061))
 (set.gloc.of load-cache)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 191518))
 (set.gloc.of auto-compile-verbose)
 (ret.const.unspec))
((close
   (1 0)
   (iloc.0 . 0)
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of string? 1 "./boot/eval.scm" . 198674)
       (if.false.ret)
       (push.const . "~//.")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/eval.scm" . 198700)
       (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 198686))
     (if.true
       (push.const . "~/")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/eval.scm" . 198720))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const
       .
       "~&;; warning in auto-compile-cache: directory ~s not exist (temporary disable caching)~!~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/eval.scm" . 200717)
     (ret.const . #f))
   (ret.iloc 0 . 0))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.const . #f)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 196612))
 (set.gloc.of auto-compile-cache)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 208949)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 209976)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 210008)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 210005)
   (ret.subr.gloc.of = "./boot/eval.scm" . 209973))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 213057))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 213042)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 214070)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 215078)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 215104))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 216102)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 216132))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 217126))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 217149))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (0 0 . auto-compile-cache-clean)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 205836))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn3.1\x60;3)
     (call
       (touch.gloc.of filter)
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 210986)
       (apply.gloc.of filter "./boot/eval.scm" . 207906))
     (push)
     (apply.gloc.of for-each "./boot/eval.scm" . 207889))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-clean)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 238645)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 239672)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 239704)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 239701)
   (ret.subr.gloc.of = "./boot/eval.scm" . 239669))
 (set.gloc.of \x2E;fn4.1\x60;4)
 (close
   (1 0 . inconsistent-cache-state)
   (call
     (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 225294))
     (if.false.ret)
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~&;; reset ~s~%")
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 226365))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 226318))
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/eval.scm" . 224263))
 (set.gloc.of inconsistent-cache-state\x60;2)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 228407))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 228392)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 229420)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 230428)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 230454))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 231452)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 231482))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 232476))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 232499))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (0 0 . auto-compile-cache-update)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 235532))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of filter)
       (push.gloc.of \x2E;fn4.1\x60;4)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 240682)
       (apply.gloc.of filter "./boot/eval.scm" . 237602))
     (push)
     (extend . 1)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (call
           (iloc.0 . 1)
           (if.false.ret)
           (push.close
             (1 0)
             (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 245839))
             (push)
             (push.const . "/")
             (push.iloc.0 . 0)
             (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 245824)
             (extend . 1)
             (push.iloc.0 . 0)
             (push.const . ".time")
             (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 246852)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 247862)
             (if.true
               (call
                 (touch.gloc.of make-file-input-port)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-file-input-port "./boot/eval.scm" . 249914))
               (push)
               (push.close
                 (1 0)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 251987)
                 (extend . 1)
                 (push.iloc.1 . 0)
                 (subr.gloc.of close-port 1 "./boot/eval.scm" . 252990)
                 (iloc.0 . 0)
                 (>=.iloc (5 . 1) "./boot/eval.scm" . 254021)
                 (if.true
                   (push.iloc 2 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 255045)
                   (push.iloc 3 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 256069)
                   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 257098))
                   (if.false.ret)
                   (push.const . #t)
                   (push.const . "~&;; clean ~s~%")
                   (push.iloc 3 . 0)
                   (ret.subr.gloc.of format "./boot/eval.scm" . 257121))
                 (ret.const.unspec))
               (apply.gloc.of call-with-port "./boot/eval.scm" . 248886))
             (touch.gloc.of inconsistent-cache-state\x60;2)
             (push.iloc 5 . 0)
             (apply.gloc.of inconsistent-cache-state\x60;2 "./boot/eval.scm" . 259126))
           (push.iloc 2 . 0)
           (apply.gloc.of for-each "./boot/eval.scm" . 243740))
         (ret.const.unspec))
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 263230))
       (push)
       (push.const . "/")
       (push.car.iloc (0 . 0) "./boot/eval.scm" . 263255)
       (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 263215)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const . ".time")
       (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 264243)
       (extend . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 265253)
       (if.true
         (call
           (touch.gloc.of make-file-input-port)
           (push.iloc.0 . 0)
           (apply.gloc.of make-file-input-port "./boot/eval.scm" . 267305))
         (push)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 269379)
           (extend . 1)
           (push.iloc.1 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 270404)
           (extend . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 271423)
           (extend . 1)
           (push.iloc 3 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 272451)
           (extend . 1)
           (push.iloc 4 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 273453)
           (call
             (push.iloc 3 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 274494)
             (if.false.ret)
             (push.iloc 2 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 274520)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of string? 1 "./boot/eval.scm" . 274547)
             (if.false.ret)
             (push.iloc.0 . 0)
             (gloc.of auto-compile-cache-validation-signature)
             (if.not.eq?.ret.const . #f)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 274631))
           (if.true
             (call
               (touch.gloc.of stat-mtime)
               (push.iloc.1 . 0)
               (apply.gloc.of stat-mtime "./boot/eval.scm" . 276535))
             (=.iloc (2 . 0) "./boot/eval.scm" . 276532)
             (if.true
               (push.cdr.iloc (7 . 0) "./boot/eval.scm" . 277562)
               (push.iloc 7 . 1)
               (apply.iloc (8 . 0) "./boot/eval.scm" . 277556))
             (push.cdr.iloc (7 . 0) "./boot/eval.scm" . 279610)
             (call
               (iloc 7 . 1)
               (if.true
                 (iloc 3 . 0)
                 (<.iloc (7 . 1) "./boot/eval.scm" . 281665)
                 (if.true (ret.iloc 3 . 0))
                 (ret.iloc 7 . 1))
               (ret.iloc 3 . 0))
             (push)
             (apply.iloc (8 . 0) "./boot/eval.scm" . 269355))
           (touch.gloc.of inconsistent-cache-state\x60;2)
           (push.iloc 9 . 0)
           (apply.gloc.of inconsistent-cache-state\x60;2 "./boot/eval.scm" . 275508))
         (apply.gloc.of call-with-port "./boot/eval.scm" . 263196))
       (push.iloc.1 . 0)
       (subr.gloc.of delete-file 1 "./boot/eval.scm" . 284709)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 285738))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; clean ~s~%")
         (push.iloc.1 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 285761))
       (push.cdr.iloc (2 . 0) "./boot/eval.scm" . 286763)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "./boot/eval.scm" . 286757))
     (push.iloc.1 . 0)
     (push.const . #f)
     (apply.iloc (0 . 0) "./boot/eval.scm" . 241683))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-update)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 293918)
     (if.false.ret)
     (touch.gloc.of every1)
     (push.gloc.of string?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/eval.scm" . 293932))
   (if.true (ret.iloc 0 . 0))
   (push.const . library-extensions)
   (push.const . "expected list of strings, but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/eval.scm" . 296002)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 295961))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.const . ".ypsilon.sls")
   (push.const . ".ypsilon.ss")
   (push.const . ".ypsilon.scm")
   (push.const . ".sls")
   (push.const . ".ss")
   (push.const . ".scm")
   (push.subr.gloc.of list 6 "./boot/eval.scm" . 291859)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 291843))
 (set.gloc.of library-extensions)
 (ret.const.unspec))
((close
   (2 0 . locate-cache)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 356368))
   (if.false.ret)
   (push.const . "~a/~a.cache")
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 357432))
   (push)
   (call
     (touch.gloc.of symbol-list->string)
     (push.iloc.0 . 0)
     (push.const . ".")
     (apply.gloc.of symbol-list->string "./boot/eval.scm" . 357453))
   (push)
   (push.subr.gloc.of format 3 "./boot/eval.scm" . 357410)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 358423)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . ".time")
     (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 359469)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 360478)
     (if.false.ret)
     (call
       (touch.gloc.of make-file-input-port)
       (push.iloc.0 . 0)
       (apply.gloc.of make-file-input-port "./boot/eval.scm" . 362530))
     (push)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 364580)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 365604)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 366655)
       (subr.gloc.of equal? 2 "./boot/eval.scm" . 366635)
       (if.true (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 368683)
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/eval.scm" . 369707))
       (ret.const . #f))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 360473))
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of locate-cache\x60;4)
 (close
   (4 0 . make-cache)
   (call
     (touch.gloc.of make-file-output-port)
     (push.iloc.0 . 1)
     (apply.gloc.of make-file-output-port "./boot/eval.scm" . 306191))
   (push)
   (push.close
     (1 0)
     (call
       (touch.gloc.of open-script-input-port)
       (push.iloc.1 . 0)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 309269))
     (push)
     (push.close
       (1 0)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 313370)
         (push.iloc 2 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 314394)
         (call
           (iloc 3 . 1)
           (if.false.ret)
           (push.iloc 3 . 1)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 315427)
           (if.false.ret)
           (push.iloc 3 . 1)
           (ret.subr.gloc.of delete-file "./boot/eval.scm" . 315446))
         (push.iloc.0 . 0)
         (apply.gloc.of raise "./boot/eval.scm" . 316442))
       (push.close
         (0 0)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (subr.gloc.of current-source-comments 0)
         (push)
         (subr.gloc.of current-environment 0)
         (push)
         (subr.gloc.of extend-lexical-syntax 0)
         (push)
         (subr.gloc.of backtrace 0)
         (push)
         (extend . 8)
         (push.close
           (0 0)
           (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 0)
           (subr.gloc.of current-environment 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 1)
           (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 2)
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 3)
           (push.iloc.1 . 4)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 5)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 6)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 7)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 323612))
         (push.close
           (0 0)
           (extend.enclose+
             (0 0 . loop)
             (call
               (subr.gloc.of backtrace 0 "./boot/eval.scm" . 324668)
               (if.false.ret)
               (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 324680))
             (push)
             (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 324638)
             (push.iloc 5 . 0)
             (subr.gloc.of current-source-comments 0)
             (push)
             (push.const . load)
             (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 325673)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 326695)
             (if.true
               (push.iloc 7 . 0)
               (push.const . "~%")
               (subr.gloc.of format 2 "./boot/eval.scm" . 327719)
               (push.iloc 6 . 0)
               (subr.gloc.of close-port 1 "./boot/eval.scm" . 328743)
               (push.iloc 7 . 0)
               (ret.subr.gloc.of close-port "./boot/eval.scm" . 329767))
             (call
               (push.const . #f)
               (subr.gloc.of make-core-hashtable 0)
               (push)
               (extend . 2)
               (push.close
                 (0 0)
                 (call
                   (touch.gloc.of current-closure-comments)
                   (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
                 (set.iloc 1 . 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 1)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
               (push.close
                 (0 0)
                 (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 334914))
                 (push)
                 (apply.gloc.of compile-coreform "./boot/eval.scm" . 334896))
               (push.close
                 (0 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 0)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
               (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 334896))
             (push)
             (extend . 1)
             (push.iloc 8 . 0)
             (push.iloc.0 . 0)
             (subr.gloc.of put-fasl 2 "./boot/eval.scm" . 335913)
             (push.iloc 8 . 0)
             (push.const . "~%")
             (subr.gloc.of format 2 "./boot/eval.scm" . 336937)
             (call
               (touch.gloc.of run-vmi)
               (push.const 1 . 0)
               (iloc.0 . 0)
               (push.cons)
               (apply.gloc.of run-vmi "./boot/eval.scm" . 337961))
             (apply.iloc+ (3 . 0) "./boot/eval.scm" . 338985))
           (apply.iloc+ (0 . 0) "./boot/eval.scm" . 323612))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 1)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 2)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 3)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 323612))
         (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 319544))
       (apply.gloc.of with-exception-handler "./boot/eval.scm" . 310293))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 307215))
   (apply.gloc.of call-with-port "./boot/eval.scm" . 304137))
 (set.gloc.of make-cache\x60;4)
 (close
   (1 1 . load-scheme-library)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #t)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of car "./boot/eval.scm" . 301098))
   (push)
   (extend . 1)
   (extend.enclose
     (1 0 . locate-source)
     (call
       (touch.gloc.of symbol-list->string)
       (push.iloc.0 . 0)
       (push.const . "/")
       (apply.gloc.of symbol-list->string "./boot/eval.scm" . 343063))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.const . "~a/~a~a")
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 4 "./boot/eval.scm" . 346163)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 347176)
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call (apply.gloc.of library-extensions "./boot/eval.scm" . 348191))
         (push)
         (apply.gloc.of any1 "./boot/eval.scm" . 345113))
       (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 349207))
       (push)
       (apply.gloc.of any1 "./boot/eval.scm" . 344081))
     (if.true.ret)
     (iloc 3 . 0)
     (if.false.ret)
     (push.const . load-scheme-library)
     (push.const . "~s not found in scheme-library-paths: ~s")
     (push.iloc.0 . 0)
     (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 351338))
     (push)
     (push.subr.gloc.of format 3 "./boot/eval.scm" . 351282)
     (apply.gloc.of error "./boot/eval.scm" . 351254))
   (call
     (push.iloc 2 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 373771)
     (if.true.ret)
     (push.const . "internal error in load-scheme-library: unrecognized argument: ~s")
     (push.iloc 2 . 0)
     (apply.gloc.of scheme-error "./boot/eval.scm" . 374795))
   (call (push.iloc 2 . 0) (apply.iloc (0 . 0) "./boot/eval.scm" . 376846))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 378903))
     (if.true
       (call
         (touch.gloc.of locate-cache\x60;4)
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of locate-cache\x60;4 "./boot/eval.scm" . 379945))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of load-cache)
         (push.iloc.0 . 0)
         (apply.gloc.of load-cache "./boot/eval.scm" . 381981))
       (push.const . "~a/~a.cache")
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 383045))
       (push)
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc 4 . 0)
         (push.const . ".")
         (apply.gloc.of symbol-list->string "./boot/eval.scm" . 383066))
       (push)
       (push.subr.gloc.of format 3 "./boot/eval.scm" . 383023)
       (extend . 1)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 384036))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; compile ~s~%~!")
         (push.iloc 2 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 384059))
       (call
         (touch.gloc.of make-cache\x60;4)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 2 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 385094))
         (push)
         (apply.gloc.of make-cache\x60;4 "./boot/eval.scm" . 385055))
       (call
         (touch.gloc.of make-file-output-port)
         (push.iloc.0 . 0)
         (push.const . ".time")
         (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 386101)
         (apply.gloc.of make-file-output-port "./boot/eval.scm" . 388133))
       (push)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.const . "~s ~s ~s ~s")
         (subr.gloc.of microsecond 0)
         (push)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 3 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 389217))
         (push)
         (push.iloc 3 . 0)
         (push.gloc.of auto-compile-cache-validation-signature)
         (ret.subr.gloc.of format "./boot/eval.scm" . 389174))
       (apply.gloc.of call-with-port "./boot/eval.scm" . 387105))
     (push.iloc.0 . 0)
     (apply.gloc.of load "./boot/eval.scm" . 390167))
   (ret.const.unspec))
 (set.gloc.of load-scheme-library)
 (ret.const.unspec))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/interaction.scm" . 5144))
 (set.gloc.of dump-condition)
 (ret.const.unspec))
((close
   (1 0 . add-load-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 9228)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 10256)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 11292))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 12323))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 12310)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13364))
       (push.cons)
       (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13334))
     (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 14348))
   (push.const . add-load-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 16432)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 16396))
 (set.gloc.of add-load-path)
 (ret.const.unspec))
((close
   (1 0 . add-library-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 20492)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 21520)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 22556))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 23587))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 23574)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24631))
       (push.cons)
       (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24598))
     (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 25612))
   (push.const . add-library-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 27699)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 27660))
 (set.gloc.of add-library-path)
 (ret.const.unspec))
((close
   (0 0 . home-directory)
   (push.const . "~/")
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 33831)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 33814)
     (if.true
       (call
         (push.const . "HOMEDRIVE")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 34857)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (call
         (push.const . "HOMEPATH")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 35881)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (ret.subr.gloc.of string-append "./boot/interaction.scm" . 34838))
     (push.const . "HOME")
     (ret.subr.gloc.of lookup-process-environment "./boot/interaction.scm" . 36886))
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 31761)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/interaction.scm" . 37900)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of home-directory)
 (ret.const.unspec))
((close
   (1 1 . apply-scheme-proc-assistant)
   (push.const . #t)
   (extend . 1)
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.true.ret)
     (push.const . apply-scheme-proc-assistant)
     (push.const . "scheme continuation interleave with c/c++ continuation")
     (apply.gloc.of assertion-violation "./boot/interaction.scm" . 45076))
   (push.close
     (0 0)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of apply "./boot/interaction.scm" . 47125))
     (push)
     (extend . 1)
     (const . #f)
     (set.iloc 2 . 0)
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.false.ret)
     (touch.gloc.of escape)
     (apply.gloc.of escape "./boot/interaction.scm" . 50197))
   (apply.gloc.of dynamic-wind "./boot/interaction.scm" . 43015))
 (set.gloc.of apply-scheme-proc-assistant)
 (ret.const.unspec))
((close
   (0 0 . nonblock-skip-whitespace)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of nonblock-byte-ready? 1 "./boot/interaction.scm" . 54282)
   (if.false.ret)
   (call
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of lookahead-char 1 "./boot/interaction.scm" . 55316)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 56342)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of char-whitespace? "./boot/interaction.scm" . 57361))
   (if.false.ret)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of get-char 1 "./boot/interaction.scm" . 58378)
   (if.false.ret)
   (touch.gloc.of nonblock-skip-whitespace)
   (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 59402))
 (set.gloc.of nonblock-skip-whitespace)
 (ret.const.unspec))
((close
   (0 0 . read-eval-print-loop)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 63512)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 63559)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 63554)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 63549))
   (push)
   (extend . 1)
   (extend.enclose
     (0 0 . loop)
     (call
       (push.close
         (1 0)
         (push.close
           (1 0)
           (subr.gloc.of current-output-port 0)
           (push)
           (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 69647)
           (touch.gloc.of default-exception-handler)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 70671))
         (push.close
           (0 0)
           (call
             (touch.gloc.of nonblock-skip-whitespace)
             (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 72719))
           (call
             (subr.gloc.of current-environment 0)
             (push)
             (subr.gloc.of interaction-environment 0 "./boot/interaction.scm" . 73774)
             (if.eq?
               (push.const . #t)
               (push.const . "~&> ~!")
               (ret.subr.gloc.of format "./boot/interaction.scm" . 74771))
             (push.const . #t)
             (push.const . "~&~a: ~!")
             (subr.gloc.of current-environment 0)
             (push)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 75795))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 76815))
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 77839)
           (call
             (touch.gloc.of set-port-current-line!)
             (subr.gloc.of current-input-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-line! "./boot/interaction.scm" . 78863))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-output-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 79887))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-error-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 80911))
           (subr.gloc.of current-input-port 0)
           (push)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . read)
           (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 81947)
           (extend . 1)
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 82966)
             (if.false.ret)
             (push.const . 0)
             (ret.subr.gloc.of exit "./boot/interaction.scm" . 82985))
           (call
             (iloc 5 . 0)
             (if.false.ret)
             (push.const . #t)
             (push.const . "~%~!")
             (ret.subr.gloc.of format "./boot/interaction.scm" . 83998))
           (call
             (touch.gloc.of interpret)
             (push.iloc.0 . 0)
             (apply.gloc.of interpret "./boot/interaction.scm" . 85020))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of unspecified? 1 "./boot/interaction.scm" . 86042)
           (if.true.ret)
           (call (push.iloc.0 . 0) (apply.gloc.of pretty-print "./boot/interaction.scm" . 88090))
           (subr.gloc.of current-output-port 0)
           (push)
           (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 89114))
         (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 67596))
       (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 65545))
     (apply.iloc (1 . 0) "./boot/interaction.scm" . 90121))
   (apply.iloc (0 . 0) "./boot/interaction.scm" . 64519))
 (set.gloc.of read-eval-print-loop)
 (ret.const.unspec))
((close
   (0 0)
   (call
     (touch.gloc.of nonblock-skip-whitespace)
     (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 102413))
   (call
     (touch.gloc.of current-macro-expression)
     (push.const . #f)
     (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 103437))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 104461)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . read)
   (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 105497)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 106518)
   (if.true (push.const . 0) (ret.subr.gloc.of exit "./boot/interaction.scm" . 106537))
   (call
     (touch.gloc.of interpret)
     (push.iloc.0 . 0)
     (apply.gloc.of interpret "./boot/interaction.scm" . 108566))
   (subr.gloc.of current-output-port 0)
   (push)
   (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 109590))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (0 0 . loop)
   (call
     (push.gloc.of \x2E;fn5.1\x60;5)
     (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 94213))
   (touch.gloc.of loop\x60;4)
   (apply.gloc.of loop\x60;4 "./boot/interaction.scm" . 110599))
 (set.gloc.of loop\x60;4)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 100405))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (push.gloc.of \x2E;fn3.1\x60;3)
   (push.gloc.of \x2E;fn2.1\x60;2)
   (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 96264))
 (set.gloc.of \x2E;fn5.1\x60;5)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 99341)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 100365))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (0 0 . quiet-read-eval-print-loop)
   (touch.gloc.of loop\x60;4)
   (apply.gloc.of loop\x60;4 "./boot/interaction.scm" . 94213))
 (set.gloc.of quiet-read-eval-print-loop)
 (ret.const.unspec))
((close
   (1 0 . unrename-private-primitives)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;7 "./boot/interaction.scm" . 145415))
 (set.gloc.of \x2E;fn1.2\x60;1)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/interaction.scm" . 147484)
       (apply.gloc.of loop\x60;7 "./boot/interaction.scm" . 147478))
     (push)
     (call
       (touch.gloc.of loop\x60;7)
       (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 147501)
       (apply.gloc.of loop\x60;7 "./boot/interaction.scm" . 147495))
     (ret.cons "./boot/interaction.scm" . 147472))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.const
       (\x2E;LIST . \x2E;list)
       (\x2E;CONS . \x2E;cons)
       (\x2E;CONS* . \x2E;cons*)
       (\x2E;APPEND . \x2E;append)
       (\x2E;VECTOR . \x2E;vector)
       (\x2E;LIST->VECTOR . \x2E;list->vector)
       (\x2E;EQ? . \x2E;eq?)
       (\x2E;EQV? . \x2E;eqv?)
       (\x2E;MEMQ . \x2E;memq)
       (\x2E;MEMV . \x2E;memv)
       (\x2E;CALL-WITH-VALUES . \x2E;call-with-values)
       (\x2E;APPLY . \x2E;apply)
       (\x2E;CDR . \x2E;cdr)
       (\x2E;IDENTIFIER? . \x2E;identifier?)
       (\x2E;MAKE-VARIABLE-TRANSFORMER . \x2E;make-variable-transformer)
       (\x2E;ASSERTION-VIOLATION . \x2E;assertion-violation)
       (\x2E;UNSPECIFIED . \x2E;unspecified)
       (\x2E;QUOTE . quote)
       (\x2E;LET . let)
       (\x2E;LETREC* . letrec*)
       (\x2E;BEGIN . begin)
       (\x2E;LAMBDA . lambda)
       (\x2E;IF . if)
       (\x2E;SET! . set!)
       (\x2E;OR . or)
       (\x2E;COND . cond)
       (\x2E;ELSE . else)
       (\x2E;DEFINE-SYNTAX . define-syntax)
       (\x2E;SYNTAX . syntax)
       (\x2E;SYNTAX-CASE . syntax-case))
     (push.subr.gloc.of assq 2 "./boot/interaction.scm" . 149527)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/interaction.scm" . 149520))
     (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/interaction.scm" . 151568)
   (if.true
     (call
       (push.gloc.of loop\x60;7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/interaction.scm" . 152616)
       (apply.gloc.of map "./boot/interaction.scm" . 152606))
     (push)
     (ret.subr.gloc.of list->vector "./boot/interaction.scm" . 152592))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;7)
 (gloc.of \x2E;fn1.2\x60;1)
 (set.gloc.of unrename-private-primitives)
 (ret.const.unspec))
((close
   (3 0 . display-warning)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . "~a")
   (push.iloc.1 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 158727)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (subr.gloc.of backtrace-line-length 0)
   (push)
   (extend . 5)
   (push.close
     (0 0)
     (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
     (set.iloc 1 . 0)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
     (set.iloc 1 . 1)
     (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
     (set.iloc 1 . 2)
     (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 163849))
     (set.iloc 1 . 3)
     (call
       (push.iloc.1 . 4)
       (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
     (call
       (push.const . 10)
       (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
     (call
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
     (push.const . 5)
     (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 163849))
   (push.close
     (0 0)
     (call
       (iloc 3 . 1)
       (if.true
         (push.iloc 2 . 0)
         (push.const . "~%  >  ")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 164880)
         (call
           (call
             (touch.gloc.of unrename-private-primitives)
             (push.iloc 3 . 1)
             (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 165918))
           (push)
           (push.iloc 2 . 0)
           (apply.gloc.of pretty-print "./boot/interaction.scm" . 165904))
         (iloc 3 . 1)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (push.const . "~%  ~n")
         (push.iloc 3 . 1)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 166946))
       (ret.const.unspec))
     (call
       (iloc 3 . 2)
       (if.true
         (push.iloc 2 . 0)
         (push.const . "~%  >  ")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 168976)
         (call
           (call
             (touch.gloc.of unrename-private-primitives)
             (push.iloc 3 . 2)
             (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 170014))
           (push)
           (push.iloc 2 . 0)
           (apply.gloc.of pretty-print "./boot/interaction.scm" . 170000))
         (iloc 3 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (push.const . "~%  ~n")
         (push.iloc 3 . 2)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 171045))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (push.const . "~%")
     (subr.gloc.of format 2 "./boot/interaction.scm" . 172041)
     (call
       (push.const . "EMACS")
       (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 173084)
       (if.true.ret)
       (subr.gloc.of current-input-port 0)
       (push)
       (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 173131)
       (push.const . char)
       (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 173126)
       (ret.subr.gloc.of not "./boot/interaction.scm" . 173121))
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc 2 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 175155)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 175119))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc 2 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 176181)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 176143))
   (push.close
     (0 0)
     (call
       (push.iloc.1 . 0)
       (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 163849))
     (call
       (push.iloc.1 . 1)
       (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 163849))
     (call
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 163849))
     (push.iloc.1 . 3)
     (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 163849))
   (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 159792))
 (set.gloc.of display-warning)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . "~r")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 202824))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . default-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/interaction.scm" . 180229))
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (call
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of backtrace-line-length 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 186377))
       (set.iloc 1 . 0)
       (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 186377))
       (set.iloc 1 . 1)
       (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 186377))
       (set.iloc 1 . 2)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 186377))
       (call
         (push.const . 10)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 186377))
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 186377))
     (push.close
       (0 0)
       (extend.unbound . 4)
       (push.close
         (0 0 . output-who-message)
         (push.iloc 4 . 0)
         (push.const . "error")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 188429)
         (call
           (call (push.iloc 5 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 189458))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . " in ~u")
           (call (push.iloc 5 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 190504))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 190482))
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of message-condition? "./boot/interaction.scm" . 191506))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . ": ~a")
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of condition-message "./boot/interaction.scm" . 192550))
         (push)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 192530))
       (push.close
         (0 0 . output-irritants)
         (call
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of irritants-condition? "./boot/interaction.scm" . 196633))
           (if.false.ret)
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 196673))
           (ret.pair? "./boot/interaction.scm" . 196666))
         (if.true
           (push.iloc 4 . 0)
           (push.const . "~%~%irritants:")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 197652)
           (push.close
             (1 0)
             (push.iloc 5 . 0)
             (push.const . "~% ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 199712)
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/interaction.scm" . 200743)
             (if.true
               (push.iloc 5 . 0)
               (push.const . " (")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 201767)
               (extend.enclose+
                 (1 0 . loop)
                 (iloc.0 . 0)
                 (if.pair?
                   (push.iloc 7 . 0)
                   (push.const . "~a")
                   (push.car.iloc (0 . 0) "./boot/interaction.scm" . 204866)
                   (subr.gloc.of format 3 "./boot/interaction.scm" . 204848)
                   (cdr.iloc (0 . 0) "./boot/interaction.scm" . 205886)
                   (if.pair?
                     (push.iloc 7 . 0)
                     (push.const . " ")
                     (subr.gloc.of format 2 "./boot/interaction.scm" . 206903)
                     (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 207933)
                     (apply.iloc+ (1 . 0) "./boot/interaction.scm" . 207927))
                   (push.iloc 7 . 0)
                   (push.const . ")")
                   (ret.subr.gloc.of format "./boot/interaction.scm" . 209975))
                 (ret.const.unspec))
               (call
                 (push.gloc.of \x2E;fn2.1\x60;2)
                 (push.iloc.1 . 0)
                 (apply.gloc.of map "./boot/interaction.scm" . 202807))
               (push)
               (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 202791))
             (push.iloc 5 . 0)
             (push.const . " ~r")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 210988))
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 211998))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 196621))
         (ret.const.unspec))
       (push.close+
         (0 0 . output-expansion)
         (call (apply.gloc.of expansion-backtrace "./boot/interaction.scm" . 216082))
         (if.false.ret)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 217106))
         (if.false.ret)
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 219156))
           (set.iloc 1 . 0)
           (push.const . 7)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 219156))
         (push.close
           (0 0)
           (push.iloc 6 . 0)
           (push.const . "~%~%expanding:~%  >  ")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 219156)
           (call
             (call
               (touch.gloc.of unrename-private-primitives)
               (call
                 (touch.gloc.of current-macro-expression)
                 (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 220223))
               (push)
               (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 220194))
             (push)
             (push.iloc 6 . 0)
             (apply.gloc.of pretty-print "./boot/interaction.scm" . 220180))
           (push.iloc 6 . 0)
           (push.const . "~%  ~n")
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 221226))
           (push)
           (subr.gloc.of format 3 "./boot/interaction.scm" . 221204)
           (push.close
             (1 0)
             (push.iloc 7 . 0)
             (push.const . "~%  *  ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 223264)
             (call
               (call
                 (touch.gloc.of unrename-private-primitives)
                 (push.iloc.0 . 0)
                 (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 224302))
               (push)
               (push.iloc 7 . 0)
               (apply.gloc.of pretty-print "./boot/interaction.scm" . 224288))
             (push.iloc 7 . 0)
             (push.const . "~%  ~n")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 225312))
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 226334))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 222228))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 219156))
         (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 219156))
       (push.close
         (1 0 . output-condition)
         (call
           (touch.gloc.of dump-condition)
           (apply.gloc.of dump-condition "./boot/interaction.scm" . 230418))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . "~%~%")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 231442)
         (if.false.ret)
         (touch.gloc.of describe-condition)
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of describe-condition "./boot/interaction.scm" . 232466))
       (enclose . 4)
       (call (push.iloc 4 . 0) (apply.gloc.of syntax-violation? "./boot/interaction.scm" . 234512))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 235536))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 236567))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 239646))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 239646))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  >  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 239646)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 240684))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 240670))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 241712))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 239646))
             (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 239646))
           (ret.const.unspec))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 242711))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 245790))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 245790))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  @  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 245790)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 246828))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 246814))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 247856))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 245790))
             (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 245790))
           (ret.const.unspec))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 248848))
         (call
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 249888))
           (if.not.null?.ret.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 250914))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 250941))
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 251938))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 251965))
           (ret.eq? "./boot/interaction.scm" . 251933))
         (if.true.ret)
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 252948))
       (call
         (push.iloc 4 . 0)
         (apply.gloc.of undefined-violation? "./boot/interaction.scm" . 254992))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unbound variable")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 256016)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 257045))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " ~u")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 258088))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 258069))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 259093))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ", ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 260137))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 260117))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 261136))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 262160))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 263184))
       (call (push.iloc 4 . 0) (apply.gloc.of error? "./boot/interaction.scm" . 265232))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 266256))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 267280))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 268304))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 269328))
       (call (push.iloc 4 . 0) (apply.gloc.of violation? "./boot/interaction.scm" . 271376))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 272400))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 273424))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 274448))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 275472))
       (call (push.iloc 4 . 0) (apply.gloc.of warning? "./boot/interaction.scm" . 277520))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "warning")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 278544)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 279573))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " in ~u")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 280619))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 280597))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 281621))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ": ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 282665))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 282645))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 283664))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 284688))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 285712))
       (call (push.iloc 4 . 0) (apply.gloc.of condition? "./boot/interaction.scm" . 287760))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unknown type of exception caught~%~%irritants:~%~a")
         (call
           (touch.gloc.of describe-condition)
           (push.const . #f)
           (push.iloc 4 . 0)
           (apply.gloc.of describe-condition "./boot/interaction.scm" . 288857))
         (push)
         (subr.gloc.of format 3 "./boot/interaction.scm" . 288784)
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 289808))
         (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 290832))
       (push.iloc 3 . 0)
       (push.const . "error: unknown type of exception caught, ~a")
       (push.iloc 4 . 0)
       (subr.gloc.of format 3 "./boot/interaction.scm" . 293904)
       (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 294928))
       (apply.iloc+ (0 . 2) "./boot/interaction.scm" . 295952))
     (push.close
       (0 0)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 186377))
       (call
         (push.iloc.1 . 1)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 186377))
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 186377))
     (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 182320))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 297991)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 299034)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 299081)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 299076)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 299071))
   (push)
   (extend . 1)
   (call (push.iloc 2 . 0) (apply.gloc.of serious-condition? "./boot/interaction.scm" . 300048))
   (if.true
     (push.iloc.1 . 0)
     (subr.gloc.of display-backtrace 1 "./boot/interaction.scm" . 301072)
     (call
       (iloc.0 . 0)
       (if.true
         (subr.gloc.of current-error-port 0)
         (push)
         (push.const . "~a~!")
         (push.iloc.1 . 0)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 303160)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 303124))
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~%~a~%~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 304188)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 304148))
     (push.const . 10000)
     (subr.gloc.of usleep 1 "./boot/interaction.scm" . 305168)
     (iloc 2 . 1)
     (if.false.ret)
     (apply.iloc (2 . 1) "./boot/interaction.scm" . 306206))
   (call
     (iloc.0 . 0)
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 309304)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 309268))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc.1 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 310330)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 310292))
   (push.const . 10000)
   (ret.subr.gloc.of usleep "./boot/interaction.scm" . 311312))
 (set.gloc.of default-exception-handler)
 (ret.const.unspec))
((close
   (0 0 . init-sys-sitelib)
   (push.const . "~a/sitelib")
   (subr.gloc.of system-share-path 0)
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 322581)
   (extend . 1)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 323600))
   (if.false.ret)
   (push.iloc.0 . 0)
   (apply.gloc.of add-library-path "./boot/interaction.scm" . 323625))
 (set.gloc.of init-sys-sitelib\x60;2)
 (close
   (0 0 . show-info)
   (call
     (touch.gloc.of show-banner\x60;2)
     (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 445449))
   (call
     (push.const . "YPSILON_ACC")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 446480)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_ACC=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 447522))
     (push.const . #t)
     (push.const . ";; YPSILON_ACC unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 448533))
   (call
     (push.const . "YPSILON_SITELIB")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 449552)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_SITELIB=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 450594))
     (push.const . #t)
     (push.const . ";; YPSILON_SITELIB unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 451605))
   (call
     (push.const . "YPSILON_LOADPATH")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 452624)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_LOADPATH=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 453666))
     (push.const . #t)
     (push.const . ";; YPSILON_LOADPATH unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 454677))
   (push.const . #t)
   (push.const . ";; (auto-compile-cache) => ~s~%")
   (call (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 455734))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 455689)
   (push.const . #t)
   (push.const . ";; (scheme-library-paths) => ~s~%")
   (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 456760))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 456713)
   (push.const . #t)
   (push.const . ";; (scheme-load-paths) => ~s~%")
   (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 457781))
   (push)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 457737))
 (set.gloc.of show-info\x60;2)
 (close
   (0 0 . show-usage)
   (push.const . #t)
   (push.const . "usage: ypsilon [options] [--] [file] [arguments]~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 418825)
   (push.const . #t)
   (push.const . "options:~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 419849)
   (push.const . #t)
   (push.const . "  --mute (-m)            suppresses greeting~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 420873)
   (push.const . #t)
   (push.const . "  --quiet (-q)           suppresses greeting, repl prompt, and repl output~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 421897)
   (push.const . #t)
   (push.const . "  --verbose (-v)         prints load and compile activities~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 422921)
   (push.const . #t)
   (push.const . "  --warning (-w)         prints warnings~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 423945)
   (push.const . #t)
   (push.const . "  --interactive (-i)     enters repl after running the script file~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 424969)
   (push.const . #t)
   (push.const . "  --r6rs (-6)            conforms r6rs top-level program syntax~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 425993)
   (push.const . #t)
   (push.const . "  --compatible (-c)      extends lexical syntax for compatibility~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 427017)
   (push.const . #t)
   (push.const . "  --sitelib=path         adds sitelib path (YPSILON_SITELIB)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 428041)
   (push.const . #t)
   (push.const . "  --loadpath=path        adds load search path (YPSILON_LOADPATH)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 429065)
   (push.const . #t)
   (push.const . "  --acc=dir              sets a auto-compile-cache directory (YPSILON_ACC)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 430089)
   (push.const . #t)
   (push.const . "  --heap-limit=mbytes    sets a total heap limit in MBytes~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 431113)
   (push.const . #t)
   (push.const . "  --dump-condition       default exception handler dump condition~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 432137)
   (push.const . #t)
   (push.const . "  --disable-acc          disables auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 433161)
   (push.const . #t)
   (push.const . "  --clean-acc            cleans auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 434185)
   (push.const . #t)
   (push.const . "  --version              prints version and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 435209)
   (push.const . #t)
   (push.const . "  --help                 prints help and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 436233)
   (push.const . #t)
   (push.const . "  --                     indicates no more option to proceed~%")
   (ret.subr.gloc.of format "./boot/interaction.scm" . 437257))
 (set.gloc.of show-usage\x60;2)
 (close
   (0 0 . init-env-sitelib)
   (push.const . "YPSILON_SITELIB")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 351248)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn6.1\x60;6)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 359476)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 359459)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 360483))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 361507))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 359446)
     (apply.gloc.of for-each "./boot/interaction.scm" . 351241))
   (ret.const.unspec))
 (set.gloc.of init-env-sitelib\x60;2)
 (close
   (1 0 . set-opt-acc)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 404515))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 404496))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 405540))
     (push)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 405520))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '--acc=~a': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of format 4 "./boot/interaction.scm" . 407568)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 408592))
 (set.gloc.of set-opt-acc\x60;2)
 (close
   (1 0 . bad-option)
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '~a'~%")
   (push.iloc.0 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 412681)
   (call
     (touch.gloc.of show-usage\x60;2)
     (apply.gloc.of show-usage\x60;2 "./boot/interaction.scm" . 413705))
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 414729))
 (set.gloc.of bad-option\x60;2)
 (close
   (1 0)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 369714))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 369695))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 370734))
     (push)
     (apply.gloc.of add-load-path "./boot/interaction.scm" . 370719))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_LOADPATH': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 372767))
 (set.gloc.of \x2E;fn8.1\x60;8)
 (close
   (0 0 . init-env-loadpath)
   (push.const . "YPSILON_LOADPATH")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 365584)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn8.1\x60;8)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 373812)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 373795)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 374819))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 375843))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 373782)
     (apply.gloc.of for-each "./boot/interaction.scm" . 365577))
   (ret.const.unspec))
 (set.gloc.of init-env-loadpath\x60;2)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 475157)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of \x2E;fn15.1\x60;15)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 476181))
 (set.gloc.of \x2E;fn9.1\x60;9)
 (close
   (1 0 . add-opt-sitelib)
   (push.close
     (1 0)
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 380975))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 380956))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 381998))
       (push)
       (apply.gloc.of add-library-path "./boot/interaction.scm" . 381980))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '--sitelib=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 384028)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 385052))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 386097)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 386080)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 387104))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 388128))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 386067)
   (apply.gloc.of for-each "./boot/interaction.scm" . 378887))
 (set.gloc.of add-opt-sitelib\x60;2)
 (close
   (1 0 . directory-exists?)
   (push.const . "~a/.")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 318487)
   (ret.subr.gloc.of file-exists? "./boot/interaction.scm" . 318473))
 (set.gloc.of directory-exists?\x60;2)
 (close
   (1 0)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 355378))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 355359))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 356401))
     (push)
     (apply.gloc.of add-library-path "./boot/interaction.scm" . 356383))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_SITELIB': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 358431))
 (set.gloc.of \x2E;fn6.1\x60;6)
 (close
   (0 0 . init-sys-acc)
   (push.const . operating-system)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 327713)
   (push.const . "windows")
   (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 327696)
   (if.true
     (push.const . "TEMP")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 328727)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of directory-exists?\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 330787))
       (if.true
         (call
           (call
             (touch.gloc.of directory-exists?\x60;2)
             (push.const . "~//Ypsilon")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/interaction.scm" . 331834)
             (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 331815))
           (if.true.ret)
           (push.const . "~//Ypsilon")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/interaction.scm" . 332857)
           (ret.subr.gloc.of create-directory "./boot/interaction.scm" . 332839))
         (push.const . "~//Ypsilon")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/interaction.scm" . 333879)
         (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 333859))
       (ret.const.unspec))
     (ret.const.unspec))
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 335936))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 335914)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 335895))
   (if.true
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 336961))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 336939)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 336919))
   (ret.const.unspec))
 (set.gloc.of init-sys-acc\x60;2)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 476221))
 (set.gloc.of \x2E;fn15.1\x60;15)
 (close
   (1 0 . add-opt-loadpath)
   (push.close
     (1 0)
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 393263))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 393244))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 394283))
       (push)
       (apply.gloc.of add-load-path "./boot/interaction.scm" . 394268))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '--loadpath=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 396316)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 397340))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 398385)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 398368)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 399392))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 400416))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 398355)
   (apply.gloc.of for-each "./boot/interaction.scm" . 391175))
 (set.gloc.of add-opt-loadpath\x60;2)
 (close
   (0 0 . show-banner)
   (subr.gloc.of current-output-port 0)
   (push)
   (push.const . "Ypsilon 0.9.6-trunk Copyright (c) 2008 Y.Fujita, LittleWing Company Limited.\n")
   (ret.subr.gloc.of put-string "./boot/interaction.scm" . 441353))
 (set.gloc.of show-banner\x60;2)
 (close
   (0 0 . init-env-acc)
   (push.const . "YPSILON_ACC")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 341008)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 343087))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 343068))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 344112))
       (push)
       (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 344092))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in environment variable 'YPSILON_ACC': directory ~s not exist~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/interaction.scm" . 346140)
     (push.const . #f)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 347164))
   (ret.const.unspec))
 (set.gloc.of init-env-acc\x60;2)
 (close
   (0 0 . start-scheme-session)
   (extend.unbound . 9)
   (push.close
     (1 0 . exec-script)
     (subr.gloc.of command-line 0)
     (push)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 461856)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 461880)
     (push.subr.gloc.of - 2 "./boot/interaction.scm" . 461853)
     (subr.gloc.of command-line-shift 1 "./boot/interaction.scm" . 461833)
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 462869)
     (extend . 1)
     (iloc 2 . 4)
     (if.true
       (push.close
         (1 0)
         (subr.gloc.of current-output-port 0)
         (push)
         (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 466965)
         (touch.gloc.of default-exception-handler)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 467989))
       (push.close
         (0 0)
         (call
           (touch.gloc.of auto-compile-cache-update)
           (apply.gloc.of auto-compile-cache-update "./boot/interaction.scm" . 470037))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 471061))
       (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 464914))
     (push.gloc.of \x2E;fn9.1\x60;9)
     (push.close
       (0 0)
       (call
         (touch.gloc.of auto-compile-cache-update)
         (apply.gloc.of auto-compile-cache-update "./boot/interaction.scm" . 478229))
       (call
         (call
           (iloc 3 . 7)
           (if.true.ret)
           (touch.gloc.of load-file-has-r6rs-comment?)
           (push.iloc.1 . 0)
           (apply.gloc.of load-file-has-r6rs-comment? "./boot/interaction.scm" . 479274))
         (if.true
           (touch.gloc.of load-r6rs)
           (push.iloc.1 . 0)
           (apply.gloc.of load-r6rs "./boot/interaction.scm" . 480281))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 481305))
       (subr.gloc.of current-error-port 0)
       (push)
       (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 482325)
       (subr.gloc.of current-output-port 0)
       (push)
       (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 483349))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 473106))
   (push.close
     (0 0 . exec-repl)
     (call
       (iloc.1 . 6)
       (if.true.ret)
       (iloc.1 . 2)
       (if.true
         (touch.gloc.of show-info\x60;2)
         (apply.gloc.of show-info\x60;2 "./boot/interaction.scm" . 488472))
       (touch.gloc.of show-banner\x60;2)
       (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 489493))
     (call
       (iloc.1 . 5)
       (if.true.ret)
       (touch.gloc.of interpret)
       (push.const import (core) (rnrs))
       (apply.gloc.of interpret "./boot/interaction.scm" . 490516))
     (iloc.1 . 3)
     (if.true
       (touch.gloc.of quiet-read-eval-print-loop)
       (apply.gloc.of quiet-read-eval-print-loop "./boot/interaction.scm" . 492557))
     (touch.gloc.of read-eval-print-loop)
     (apply.gloc.of read-eval-print-loop "./boot/interaction.scm" . 493581))
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (enclose . 8)
   (subr.gloc.of command-line 0 "./boot/interaction.scm" . 502818)
   (set.iloc 0 . 8)
   (call
     (touch.gloc.of init-sys-acc\x60;2)
     (apply.gloc.of init-sys-acc\x60;2 "./boot/interaction.scm" . 504837))
   (call
     (touch.gloc.of init-env-acc\x60;2)
     (apply.gloc.of init-env-acc\x60;2 "./boot/interaction.scm" . 505861))
   (call
     (touch.gloc.of init-sys-sitelib\x60;2)
     (apply.gloc.of init-sys-sitelib\x60;2 "./boot/interaction.scm" . 506885))
   (call
     (touch.gloc.of init-env-sitelib\x60;2)
     (apply.gloc.of init-env-sitelib\x60;2 "./boot/interaction.scm" . 507909))
   (call
     (touch.gloc.of init-env-loadpath\x60;2)
     (apply.gloc.of init-env-loadpath\x60;2 "./boot/interaction.scm" . 508933))
   (iloc.0 . 8)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 4)
       (if.true (apply.iloc (2 . 1) "./boot/interaction.scm" . 516121))
       (iloc 2 . 5)
       (if.true.ret)
       (apply.iloc (2 . 1) "./boot/interaction.scm" . 517156))
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 519200)
     (extend . 1)
     (extend.enclose
       (2 0 . opt?)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of string-contains 2 "./boot/interaction.scm" . 523300)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (=n.iloc (0 . 0) 0 "./boot/interaction.scm" . 525353)
         (if.true
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (subr.gloc.of string=? 2 "./boot/interaction.scm" . 526372)
           (if.true.ret.const . "")
           (iloc.1 . 1)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 527430)
           (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 527414)
           (push.const . #\=)
           (subr.gloc.of char=? 2 "./boot/interaction.scm" . 527406)
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 528438)
           (push.const . 1)
           (push.subr.gloc.of + 2 "./boot/interaction.scm" . 528435)
           (push.iloc 3 . 0)
           (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 528462)
           (ret.subr.gloc.of substring "./boot/interaction.scm" . 528420))
         (ret.const . #f))
       (ret.const . #f))
     (call
       (push.const . "--heap-limit")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 531486))
     (if.true
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 531517)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 531511))
     (call
       (push.const . "--heap-limit")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 532510))
     (if.true
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 532541)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 532535))
     (call
       (push.const . "--no-letrec-check")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 533534))
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "** WARNING: '--no-letrec-check' option is deprecated~%")
       (subr.gloc.of format 2 "./boot/interaction.scm" . 534558)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 535588)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 535582))
     (call
       (call
         (push.const . "--warning")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 536610))
       (if.true.ret)
       (push.const . "-w")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 536632))
     (if.true
       (push.const . #t)
       (subr.gloc.of warning-level 1 "./boot/interaction.scm" . 537630)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 538660)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 538654))
     (call
       (push.const . "--version")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 539678))
     (if.true
       (call
         (touch.gloc.of show-banner\x60;2)
         (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 540702))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 541726))
     (call
       (push.const . "--help")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 542750))
     (if.true
       (call
         (touch.gloc.of show-usage\x60;2)
         (apply.gloc.of show-usage\x60;2 "./boot/interaction.scm" . 543774))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 544798))
     (call
       (call
         (push.const . "--r6rs")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 545826))
       (if.true.ret)
       (push.const . "-6")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 545845))
     (if.true
       (push.const . #f)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 546846)
       (const . #t)
       (set.iloc 4 . 7)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 548900)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 548894))
     (call
       (call
         (push.const . "--compatible")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 549922))
       (if.true.ret)
       (push.const . "-c")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 549947))
     (if.true
       (push.const . #t)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 550942)
       (const . #f)
       (set.iloc 4 . 7)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 552996)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 552990))
     (call
       (call
         (push.const . "--verbose")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 554018))
       (if.true.ret)
       (push.const . "-v")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 554040))
     (if.true
       (call
         (push.const . #t)
         (apply.gloc.of scheme-load-verbose "./boot/interaction.scm" . 555038))
       (call
         (push.const . #t)
         (apply.gloc.of auto-compile-verbose "./boot/interaction.scm" . 556062))
       (const . #t)
       (set.iloc 4 . 2)
       (const . #f)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 559140)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 559134))
     (call
       (call
         (push.const . "--mute")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 560162))
       (if.true.ret)
       (push.const . "-m")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 560181))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 563236)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 563230))
     (call
       (call
         (push.const . "--quiet")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 564258))
       (if.true.ret)
       (push.const . "-q")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 564278))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (const . #t)
       (set.iloc 4 . 3)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 568356)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 568350))
     (call
       (call
         (push.const . "--interactive")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 569378))
       (if.true.ret)
       (push.const . "-i")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 569404))
     (if.true
       (const . #t)
       (set.iloc 4 . 4)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 571428)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 571422))
     (call
       (push.const . "--dump-condition")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 572446))
     (if.true
       (call
         (touch.gloc.of dump-condition)
         (push.const . #t)
         (apply.gloc.of dump-condition "./boot/interaction.scm" . 573470))
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 574500)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 574494))
     (call
       (push.const . "--acc")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 575518))
     (if.true
       (call
         (cdr.iloc (2 . 0) "./boot/interaction.scm" . 576553)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc.1 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 576564))
       (call
         (touch.gloc.of set-opt-acc\x60;2)
         (push.cadr.iloc (2 . 0) "./boot/interaction.scm" . 577579)
         (apply.gloc.of set-opt-acc\x60;2 "./boot/interaction.scm" . 577566))
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 578596)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 578590))
     (call
       (push.const . "--acc")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 579614))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 581674)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 2 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 582698))
       (call
         (touch.gloc.of set-opt-acc\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of set-opt-acc\x60;2 "./boot/interaction.scm" . 584746))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 585776)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 585770))
     (call
       (push.const . "--disable-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 586782))
     (if.true
       (call (push.const . #f) (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 587806))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 588836)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 588830))
     (call
       (push.const . "--clean-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 589854))
     (if.true
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/interaction.scm" . 590878))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 591908)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 591902))
     (call
       (push.const . "--sitelib")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 592926))
     (if.true
       (call
         (cdr.iloc (3 . 0) "./boot/interaction.scm" . 593961)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 2 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 593972))
       (call
         (touch.gloc.of add-opt-sitelib\x60;2)
         (push.cadr.iloc (3 . 0) "./boot/interaction.scm" . 594991)
         (apply.gloc.of add-opt-sitelib\x60;2 "./boot/interaction.scm" . 594974))
       (push.cddr.iloc (3 . 0) "./boot/interaction.scm" . 596004)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 595998))
     (call
       (push.const . "--sitelib")
       (push.const . #t)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 597022))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 599082)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 3 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 600106))
       (call
         (touch.gloc.of add-opt-sitelib\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of add-opt-sitelib\x60;2 "./boot/interaction.scm" . 602154))
       (push.cdr.iloc (4 . 0) "./boot/interaction.scm" . 603184)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 603178))
     (call
       (push.const . "--loadpath")
       (push.const . #f)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 604190))
     (if.true
       (call
         (cdr.iloc (4 . 0) "./boot/interaction.scm" . 605225)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 3 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 605236))
       (call
         (touch.gloc.of add-opt-loadpath\x60;2)
         (push.cadr.iloc (4 . 0) "./boot/interaction.scm" . 606256)
         (apply.gloc.of add-opt-loadpath\x60;2 "./boot/interaction.scm" . 606238))
       (push.cddr.iloc (4 . 0) "./boot/interaction.scm" . 607268)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 607262))
     (call
       (push.const . "--loadpath")
       (push.const . #t)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 608286))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 610346)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 4 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 611370))
       (call
         (touch.gloc.of add-opt-loadpath\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of add-opt-loadpath\x60;2 "./boot/interaction.scm" . 613418))
       (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 614448)
       (apply.iloc+ (6 . 0) "./boot/interaction.scm" . 614442))
     (call
       (push.const . "--")
       (push.const . #f)
       (apply.iloc (3 . 0) "./boot/interaction.scm" . 615454))
     (if.true
       (const . #t)
       (set.iloc 7 . 5)
       (call
         (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 617515)
         (apply.iloc (7 . 0) "./boot/interaction.scm" . 617502))
       (iloc 7 . 4)
       (if.false.ret)
       (apply.iloc (7 . 1) "./boot/interaction.scm" . 618543))
     (push.iloc 4 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 619558)
     (push.const . #\-)
     (subr.gloc.of char=? 2 "./boot/interaction.scm" . 619550)
     (if.true
       (touch.gloc.of bad-option\x60;2)
       (push.iloc 4 . 0)
       (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 620574))
     (const . #t)
     (set.iloc 7 . 5)
     (call (push.iloc 5 . 0) (apply.iloc (7 . 0) "./boot/interaction.scm" . 623646))
     (iloc 7 . 4)
     (if.false.ret)
     (apply.iloc (7 . 1) "./boot/interaction.scm" . 624687))
   (push.cdr.iloc (1 . 8) "./boot/interaction.scm" . 513052)
   (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 513036))
 (set.gloc.of start-scheme-session)
 (ret.const.unspec))

;
((subr.gloc.of make-core-hashtable 0 "./boot/libraries.scm" . 5150)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))
((const begin quote define set! lambda let letrec* if or and)
 (set.gloc.of coreform-primitives)
 (ret.const.unspec))
((close
   (2 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 57372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 59425))
   (ret.const.unspec))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 33864))
   (ret.cons "./boot/libraries.scm" . 33856))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . compound-exports)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 68625))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68655))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 69676)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.1 . 1)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68691))
   (push)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 70700)
   (push.subr.gloc.of append 2 "./boot/libraries.scm" . 69668)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 69641))
 (set.gloc.of compound-exports\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 17453)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 17429)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 18453))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (2 0 . setup-intrinsic-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 27665))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 28689))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 29718))
   (push)
   (extend . 3)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 30729)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 31753)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 33837))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 34861)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 33829)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 32804))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 32777))
 (set.gloc.of setup-intrinsic-macros\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 48200))
   (ret.cons "./boot/libraries.scm" . 48192))
 (set.gloc.of \x2E;fn5.1\x60;5)
 (close
   (2 0 . setup-intrinsic-procs)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 1)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 12295)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 13329))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 14353))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 15382))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn3.1\x60;3)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 16393))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 20489)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn12.1\x60;12)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 22573))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 23597)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 22565)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 21540))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 21513))
 (set.gloc.of setup-intrinsic-procs\x60;1)
 (close
   (2 0 . setup-core-primitive-procs)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 38929))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 39953))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 40982))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn8.1\x60;8)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 41993))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 46089)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn5.1\x60;5)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 48173))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 49197)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 48165)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 47140))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 47113))
 (set.gloc.of setup-core-primitive-procs\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 43053)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 43029)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 44053))
 (set.gloc.of \x2E;fn8.1\x60;8)
 (close
   (2 0 . setup-core-primitive-macros)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 53265))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 54289))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 55318))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn1.1\x60;1)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 53255))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 61449)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn10.1\x60;10)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 63533))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 64557)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 63525)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 62500))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 62473))
 (set.gloc.of setup-core-primitive-macros\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 63560))
   (ret.cons "./boot/libraries.scm" . 63552))
 (set.gloc.of \x2E;fn10.1\x60;10)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 22600))
   (ret.cons "./boot/libraries.scm" . 22592))
 (set.gloc.of \x2E;fn12.1\x60;12)
 (call
   (touch.gloc.of setup-intrinsic-macros\x60;1)
   (push.const core intrinsics)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (apply.gloc.of setup-intrinsic-macros\x60;1 "./boot/libraries.scm" . 72707))
 (call
   (touch.gloc.of setup-intrinsic-procs\x60;1)
   (push.const core intrinsics)
   (push.const
     eq?
     eqv?
     equal?
     procedure?
     number?
     complex?
     real?
     rational?
     integer?
     real-valued?
     rational-valued?
     integer-valued?
     exact?
     inexact?
     inexact
     exact
     =
     <
     >
     <=
     >=
     zero?
     positive?
     negative?
     odd?
     even?
     finite?
     infinite?
     nan?
     max
     min
     +
     *
     -
     /
     abs
     div-and-mod
     div
     mod
     div0-and-mod0
     div0
     mod0
     gcd
     lcm
     numerator
     denominator
     floor
     ceiling
     truncate
     round
     rationalize
     exp
     log
     sin
     cos
     tan
     asin
     acos
     atan
     sqrt
     exact-integer-sqrt
     expt
     make-rectangular
     make-polar
     real-part
     imag-part
     magnitude
     angle
     number->string
     string->number
     not
     boolean?
     boolean=?
     pair?
     cons
     car
     cdr
     caar
     cadr
     cdar
     cddr
     caaar
     caadr
     cadar
     caddr
     cdaar
     cdadr
     cddar
     cdddr
     caaaar
     caaadr
     caadar
     caaddr
     cadaar
     cadadr
     caddar
     cadddr
     cdaaar
     cdaadr
     cdadar
     cdaddr
     cddaar
     cddadr
     cdddar
     cddddr
     null?
     list?
     list
     length
     append
     reverse
     list-tail
     list-ref
     map
     for-each
     symbol?
     symbol=?
     symbol->string
     string->symbol
     char?
     char->integer
     integer->char
     char=?
     char<?
     char>?
     char<=?
     char>=?
     string?
     make-string
     string
     string-length
     string-ref
     string=?
     string<?
     string>?
     string<=?
     string>=?
     substring
     string-append
     string->list
     list->string
     string-copy
     string-for-each
     vector?
     make-vector
     vector
     vector-length
     vector-ref
     vector-set!
     vector->list
     list->vector
     vector-fill!
     vector-map
     vector-for-each
     error
     assertion-violation
     apply
     call-with-current-continuation
     call/cc
     values
     call-with-values
     dynamic-wind)
   (apply.gloc.of setup-intrinsic-procs\x60;1 "./boot/libraries.scm" . 84995))
 (call
   (touch.gloc.of setup-core-primitive-macros\x60;1)
   (push.const core primitives)
   (push.const do syntax-case syntax define-macro)
   (apply.gloc.of setup-core-primitive-macros\x60;1 "./boot/libraries.scm" . 131075))
 (call
   (touch.gloc.of setup-core-primitive-procs\x60;1)
   (push.const core primitives)
   (push.const
     environment
     eval
     flonum?
     real->flonum
     fl=?
     fl<?
     fl>?
     fl<=?
     fl>=?
     flinteger?
     flzero?
     flpositive?
     flnegative?
     flodd?
     fleven?
     flfinite?
     flinfinite?
     flnan?
     flmax
     flmin
     fl+
     fl*
     fl-
     fl/
     fldiv
     fldiv0
     flnumerator
     fldenominator
     flfloor
     flceiling
     fltruncate
     flround
     flexp
     flexpt
     fllog
     flsin
     flcos
     fltan
     flasin
     flacos
     flatan
     flabs
     flsqrt
     fixnum->flonum
     fixnum?
     fixnum-width
     least-fixnum
     greatest-fixnum
     fx=?
     fx<?
     fx>?
     fx<=?
     fx>=?
     fxzero?
     fxpositive?
     fxnegative?
     fxodd?
     fxeven?
     fxmax
     fxmin
     fx+
     fx*
     fx-
     fxdiv
     fxdiv0
     fxnot
     fxand
     fxior
     fxxor
     fxif
     fxbit-count
     fxlength
     fxfirst-bit-set
     fxbit-set?
     fxcopy-bit
     fxarithmetic-shift
     fxarithmetic-shift-left
     fxarithmetic-shift-right
     fxbit-field
     fxcopy-bit-field
     &no-infinities
     make-no-infinities-violation
     no-infinities-violation?
     &no-nans
     make-no-nans-violation
     no-nans-violation?
     bitwise-not
     bitwise-and
     bitwise-ior
     bitwise-xor
     bitwise-arithmetic-shift
     bitwise-first-bit-set
     bitwise-length
     bitwise-bit-count
     make-variable-transformer
     identifier?
     bound-identifier=?
     free-identifier=?
     datum->syntax
     syntax->datum
     generate-temporaries
     syntax-violation
     memq
     memv
     member
     assq
     assv
     assoc
     cons*
     list-head
     raise
     raise-continuable
     with-exception-handler
     record?
     record-rtd
     record-type-name
     record-type-parent
     record-type-uid
     record-type-generative?
     record-type-sealed?
     record-type-opaque?
     record-type-field-names
     record-field-mutable?
     make-record-type-descriptor
     record-type-descriptor?
     make-record-constructor-descriptor
     record-constructor
     record-predicate
     record-accessor
     record-mutator
     make-record-type
     record-type?
     record-type-rtd
     record-type-rcd
     condition
     simple-conditions
     condition?
     condition-predicate
     condition-accessor
     &condition
     &message
     make-message-condition
     message-condition?
     condition-message
     &warning
     make-warning
     warning?
     &serious
     make-serious-condition
     serious-condition?
     &error
     make-error
     error?
     &violation
     make-violation
     violation?
     &assertion
     make-assertion-violation
     assertion-violation?
     &irritants
     make-irritants-condition
     irritants-condition?
     condition-irritants
     &who
     make-who-condition
     who-condition?
     condition-who
     &non-continuable
     make-non-continuable-violation
     non-continuable-violation?
     &implementation-restriction
     make-implementation-restriction-violation
     implementation-restriction-violation?
     &lexical
     make-lexical-violation
     lexical-violation?
     &syntax
     make-syntax-violation
     syntax-violation?
     syntax-violation-form
     syntax-violation-subform
     &undefined
     make-undefined-violation
     undefined-violation?
     set-car!
     set-cdr!
     string-set!
     string-fill!
     quotient
     remainder
     modulo
     char-whitespace?
     display
     write
     newline
     read-char
     write-char
     call-with-port
     eof-object
     eof-object?
     standard-input-port
     standard-output-port
     standard-error-port
     current-input-port
     current-output-port
     current-error-port
     input-port?
     output-port?
     port?
     flush-output-port
     output-port-buffer-mode
     close-port
     native-transcoder-descriptor
     port-transcoder-descriptor
     extract-accumulated-bytevector
     extract-accumulated-string
     get-accumulated-string
     open-port
     nonblock-byte-ready?
     lookahead-char
     get-char
     port-has-port-position?
     port-position
     port-has-set-port-position!?
     set-port-position!
     port-eof?
     get-u8
     lookahead-u8
     get-bytevector-n
     get-bytevector-n!
     get-bytevector-all
     get-bytevector-some
     get-string-n
     get-string-n!
     get-string-all
     get-line
     get-datum
     put-u8
     put-bytevector
     put-char
     put-string
     put-datum
     &i/o
     make-i/o-error
     i/o-error?
     &i/o-read
     make-i/o-read-error
     i/o-read-error?
     &i/o-write
     make-i/o-write-error
     i/o-write-error?
     &i/o-invalid-position
     make-i/o-invalid-position-error
     i/o-invalid-position-error?
     i/o-error-position
     &i/o-filename
     make-i/o-filename-error
     i/o-filename-error?
     i/o-error-filename
     &i/o-file-protection
     make-i/o-file-protection-error
     i/o-file-protection-error?
     &i/o-file-is-read-only
     make-i/o-file-is-read-only-error
     i/o-file-is-read-only-error?
     &i/o-file-already-exists
     make-i/o-file-already-exists-error
     i/o-file-already-exists-error?
     &i/o-file-does-not-exist
     make-i/o-file-does-not-exist-error
     i/o-file-does-not-exist-error?
     &i/o-port
     make-i/o-port-error
     i/o-port-error?
     i/o-error-port
     &i/o-decoding
     make-i/o-decoding-error
     i/o-decoding-error?
     &i/o-encoding
     make-i/o-encoding-error
     i/o-encoding-error?
     i/o-encoding-error-char
     file-exists?
     delete-file
     string-hash
     symbol-hash
     equal-hash
     command-line
     exit
     native-endianness
     bytevector?
     make-bytevector
     bytevector-length
     bytevector=?
     bytevector-fill!
     bytevector-copy!
     bytevector-copy
     bytevector-u8-ref
     bytevector-s8-ref
     bytevector-u8-set!
     bytevector-s8-set!
     bytevector->u8-list
     u8-list->bytevector
     bytevector-u16-ref
     bytevector-s16-ref
     bytevector-u16-native-ref
     bytevector-s16-native-ref
     bytevector-u16-set!
     bytevector-s16-set!
     bytevector-u16-native-set!
     bytevector-s16-native-set!
     bytevector-u32-ref
     bytevector-s32-ref
     bytevector-u32-native-ref
     bytevector-s32-native-ref
     bytevector-u32-set!
     bytevector-s32-set!
     bytevector-u32-native-set!
     bytevector-s32-native-set!
     bytevector-u64-ref
     bytevector-s64-ref
     bytevector-u64-native-ref
     bytevector-s64-native-ref
     bytevector-u64-set!
     bytevector-s64-set!
     bytevector-u64-native-set!
     bytevector-s64-native-set!
     bytevector-ieee-single-ref
     bytevector-ieee-single-native-ref
     bytevector-ieee-single-set!
     bytevector-ieee-single-native-set!
     bytevector-ieee-double-ref
     bytevector-ieee-double-native-ref
     bytevector-ieee-double-set!
     bytevector-ieee-double-native-set!
     string->utf8
     utf8->string
     put-fasl
     put-byte
     make-string-output-port
     make-string-input-port
     make-transcoded-port
     make-temporary-file-port
     port-device-subtype
     core-eval
     command-line-shift
     unspecified
     unspecified?
     generate-temporary-symbol
     circular-list?
     circular-tree?
     list-transpose
     list-transpose+
     list-transpose*
     make-parameter
     gensym
     format
     pretty-print
     pretty-print-line-length
     pretty-print-initial-indent
     pretty-print-maximum-lines
     pretty-print-unwrap-syntax
     peek-char
     read
     write-with-shared-structure
     tuple
     tuple?
     make-tuple
     tuple-ref
     tuple-set!
     tuple-length
     tuple-index
     tuple->list
     make-weak-mapping
     weak-mapping?
     weak-mapping-key
     weak-mapping-value
     make-core-hashtable
     core-hashtable?
     make-weak-core-hashtable
     weak-core-hashtable?
     core-hashtable-contains?
     core-hashtable-ref
     core-hashtable-set!
     core-hashtable-delete!
     core-hashtable-clear!
     core-hashtable->alist
     core-hashtable-size
     core-hashtable-copy
     core-hashtable-mutable?
     core-hashtable-equivalence-function
     core-hashtable-hash-function
     usleep
     microsecond
     microsecond->utc
     scheme-error
     architecture-feature
     load-shared-object
     lookup-shared-object
     call-shared-object->void
     call-shared-object->int
     call-shared-object->intptr
     call-shared-object->double
     stdcall-shared-object->void
     stdcall-shared-object->int
     stdcall-shared-object->intptr
     stdcall-shared-object->double
     make-callback
     flonum->float
     string->cstring
     cstring->string
     collect
     collect-notify
     collect-stack-notify
     collect-trip-bytes
     display-heap-statistics
     display-object-statistics
     backtrace
     expansion-backtrace
     backtrace-line-length
     display-backtrace
     warning-level
     restricted-print-line-length
     record-print-nesting-limit
     extend-lexical-syntax
     macro-expand
     compile
     compile-coreform
     closure-code
     current-environment
     current-macro-environment
     current-variable-environment
     current-dynamic-environment
     system-environment
     interaction-environment
     make-environment
     copy-environment-variables!
     copy-environment-macros!
     top-level-bound?
     top-level-value
     set-top-level-value!
     core-read
     current-source-comments
     current-after-expansion-hook
     string-contains
     subr?
     make-bytevector-mapping
     scheme-library-exports
     scheme-library-paths
     scheme-load-paths
     scheme-load-verbose
     add-load-path
     add-library-path
     library-extensions
     auto-compile-verbose
     auto-compile-cache
     directory-list
     current-directory
     create-directory
     home-directory
     time-usage
     decode-flonum
     load
     system-share-path
     system
     process
     process-wait
     lookup-process-environment
     set-current-input-port!
     set-current-output-port!
     set-current-error-port!
     open-builtin-data-input-port)
   (apply.gloc.of setup-core-primitive-procs\x60;1 "./boot/libraries.scm" . 137219))
 (touch.gloc.of compound-exports\x60;1)
 (push.const core primitives)
 (push.const core intrinsics)
 (apply.gloc.of compound-exports\x60;1 "./boot/libraries.scm" . 492547))
((gloc.of assertion-violation) (set.gloc.of \x2E;@assertion-violation) (ret.const.unspec))
((gloc.of undefined-violation) (set.gloc.of \x2E;@undefined-violation) (ret.const.unspec))
((gloc.of lexical-violation) (set.gloc.of \x2E;@lexical-violation) (ret.const.unspec))
((gloc.of error) (set.gloc.of \x2E;@error) (ret.const.unspec))
((gloc.of implementation-restriction-violation)
 (set.gloc.of \x2E;@implementation-restriction-violation)
 (ret.const.unspec))
((gloc.of raise-i/o-read-error) (set.gloc.of \x2E;@raise-i/o-read-error) (ret.const.unspec))
((gloc.of raise-i/o-write-error) (set.gloc.of \x2E;@raise-i/o-write-error) (ret.const.unspec))
((gloc.of raise-i/o-file-protection-error)
 (set.gloc.of \x2E;@raise-i/o-file-protection-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-is-read-only-error)
 (set.gloc.of \x2E;@raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-already-exists-error)
 (set.gloc.of \x2E;@raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-does-not-exist-error)
 (set.gloc.of \x2E;@raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((gloc.of raise-i/o-decoding-error) (set.gloc.of \x2E;@raise-i/o-decoding-error) (ret.const.unspec))
((gloc.of raise-i/o-encoding-error) (set.gloc.of \x2E;@raise-i/o-encoding-error) (ret.const.unspec))
((gloc.of raise-i/o-invalid-position-error)
 (set.gloc.of \x2E;@raise-i/o-invalid-position-error)
 (ret.const.unspec))
((gloc.of raise-i/o-filename-error) (set.gloc.of \x2E;@raise-i/o-filename-error) (ret.const.unspec))
((gloc.of raise-i/o-error) (set.gloc.of \x2E;@raise-i/o-error) (ret.const.unspec))
((gloc.of perform-dynamic-wind) (set.gloc.of \x2E;@perform-dynamic-wind) (ret.const.unspec))
((gloc.of start-scheme-session) (set.gloc.of \x2E;@start-scheme-session) (ret.const.unspec))
((gloc.of apply-scheme-proc-assistant)
 (set.gloc.of \x2E;@apply-scheme-proc-assistant)
 (ret.const.unspec))
((gloc.of pretty-print) (set.gloc.of \x2E;@pretty-print) (ret.const.unspec))
((push.const . \x2E;run-vmi)
 (push.gloc.of run-vmi)
 (ret.subr.gloc.of set-top-level-value! "./boot/libraries.scm" . 518145))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 528409))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const
   \x2E;set-top-level-macro!
   \x2E;require-scheme-library
   \x2E;intern-scheme-library
   \x2E;unintern-scheme-library
   \x2E;patvars
   \x2E;syntax-dispatch
   \x2E;flatten-syntax
   \x2E;transformer-thunk
   \x2E;syntax/i0
   \x2E;syntax/i1
   \x2E;syntax/i2
   \x2E;syntax/i3
   \x2E;syntax/c0
   \x2E;syntax/c1
   \x2E;syntax/c2
   \x2E;syntax/c3
   \x2E;run-vmi)
 (extend . 1)
 (call
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/libraries.scm" . 528387))
 (subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.iloc.0 . 0)
 (ret.subr.gloc.of copy-environment-variables! "./boot/libraries.scm" . 529411))
((subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.const import)
 (ret.subr.gloc.of copy-environment-macros! "./boot/libraries.scm" . 532481))
((push.gloc.of immutable-primitives)
 (subr.gloc.of core-hashtable-copy 1 "./boot/libraries.scm" . 533532)
 (touch.gloc.of immutable-primitives)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))

;
