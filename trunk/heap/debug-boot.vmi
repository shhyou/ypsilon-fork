((push.const . \x2E;list?)
 (push.gloc.of list?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 7171)
 (push.const . \x2E;null?)
 (push.gloc.of null?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 8195)
 (push.const . \x2E;pair?)
 (push.gloc.of pair?)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 9219)
 (push.const . \x2E;car)
 (push.gloc.of car)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 10243)
 (push.const . \x2E;cdr)
 (push.gloc.of cdr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 11267)
 (push.const . \x2E;caar)
 (push.gloc.of caar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 12291)
 (push.const . \x2E;cadr)
 (push.gloc.of cadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 13315)
 (push.const . \x2E;cdar)
 (push.gloc.of cdar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 14339)
 (push.const . \x2E;cddr)
 (push.gloc.of cddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 15363)
 (push.const . \x2E;caaar)
 (push.gloc.of caaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 16387)
 (push.const . \x2E;caadr)
 (push.gloc.of caadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 17411)
 (push.const . \x2E;cadar)
 (push.gloc.of cadar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 18435)
 (push.const . \x2E;caddr)
 (push.gloc.of caddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 19459)
 (push.const . \x2E;cdaar)
 (push.gloc.of cdaar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 20483)
 (push.const . \x2E;cdadr)
 (push.gloc.of cdadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 21507)
 (push.const . \x2E;cddar)
 (push.gloc.of cddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 22531)
 (push.const . \x2E;cdddr)
 (push.gloc.of cdddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 23555)
 (push.const . \x2E;cdddar)
 (push.gloc.of cdddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 24579)
 (push.const . \x2E;caddar)
 (push.gloc.of caddar)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 25603)
 (push.const . \x2E;cddadr)
 (push.gloc.of cddadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 26627)
 (push.const . \x2E;cadadr)
 (push.gloc.of cadadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 27651)
 (push.const . \x2E;caaadr)
 (push.gloc.of caaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 28675)
 (push.const . \x2E;cddddr)
 (push.gloc.of cddddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 29699)
 (push.const . \x2E;cadddr)
 (push.gloc.of cadddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 30723)
 (push.const . \x2E;cdaadr)
 (push.gloc.of cdaadr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 31747)
 (push.const . \x2E;cdaddr)
 (push.gloc.of cdaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 32771)
 (push.const . \x2E;caaddr)
 (push.gloc.of caaddr)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 33795)
 (push.const . \x2E;list)
 (push.gloc.of list)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 34819)
 (push.const . \x2E;cons*)
 (push.gloc.of cons*)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 35843)
 (push.const . \x2E;memq)
 (push.gloc.of memq)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 36867)
 (push.const . \x2E;append)
 (push.gloc.of append)
 (subr.gloc.of set-top-level-value! 2 "./boot/first-load.scm" . 37891)
 (push.const . \x2E;apply)
 (push.gloc.of apply)
 (ret.subr.gloc.of set-top-level-value! "./boot/first-load.scm" . 38915))

;
((close
   (0 1 . max)
   (iloc.0 . 0)
   (if.null?
     (push.const . max)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 8204))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 9242)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 9228)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 12316))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 13347)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 13333)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 14370)
           (>.iloc (0 . 0) "./boot/r6rs-aux.scm" . 14367)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 14387))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 15404)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 15394))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 16411)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 14357))
       (push.const . max)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 18515)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 18479)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 18453))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10270)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10296)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 10286)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 10314)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 10252))
   (push.const . max)
   (push.const . "expected real, but got ~s")
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 20554)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 20518)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 20492))
 (set.gloc.of max)
 (ret.const.unspec))
((close
   (0 1 . min)
   (iloc.0 . 0)
   (if.null?
     (push.const . min)
     (push.const . "required at least 1, but 0 argument given")
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 25612))
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 26650)
   (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 26636)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 2)
       (if.null?
         (iloc.0 . 1)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 29724))
         (ret.iloc 0 . 0))
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 30755)
       (subr.gloc.of real-valued? 1 "./boot/r6rs-aux.scm" . 30741)
       (if.true
         (call
           (car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 31778)
           (<.iloc (0 . 0) "./boot/r6rs-aux.scm" . 31775)
           (if.true (push.iloc.0 . 2) (ret.subr.gloc.of car "./boot/r6rs-aux.scm" . 31795))
           (ret.iloc 0 . 0))
         (push)
         (call
           (iloc.0 . 1)
           (if.true.ret)
           (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 32812)
           (ret.subr.gloc.of inexact? "./boot/r6rs-aux.scm" . 32802))
         (push)
         (push.cdr.iloc (0 . 2) "./boot/r6rs-aux.scm" . 33819)
         (apply.iloc+ (1 . 0) "./boot/r6rs-aux.scm" . 31765))
       (push.const . min)
       (push.const . "expected real, but got ~s")
       (push.car.iloc (0 . 2) "./boot/r6rs-aux.scm" . 35923)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 35887)
       (push.iloc 2 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 35861))
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27678)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27704)
     (push.subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 27694)
     (push.cdr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 27722)
     (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 27660))
   (push.const . min)
   (push.const . "expected real, but got ~s")
   (push.car.iloc (0 . 0) "./boot/r6rs-aux.scm" . 37962)
   (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 37926)
   (push.iloc.0 . 0)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 37900))
 (set.gloc.of min)
 (ret.const.unspec))
((close
   (2 0 . gcd2)
   (=n.iloc (0 . 1) 0 "./boot/r6rs-aux.scm" . 41993)
   (if.true
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of inexact? 1 "./boot/r6rs-aux.scm" . 43026)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of inexact "./boot/r6rs-aux.scm" . 43039))
       (ret.iloc 0 . 0))
     (push)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 43017))
   (touch.gloc.of gcd2)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of remainder 2 "./boot/r6rs-aux.scm" . 44049)
   (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 44041))
 (set.gloc.of gcd2)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 53261)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54292)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 54302)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 54286))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 55315)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 55310))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 0)
   (touch.gloc.of loop\x60;7)
   (call
     (touch.gloc.of gcd2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57377)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57387)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 57371))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 57399)
   (push.cons)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 57359))
 (set.gloc.of loop\x60;7)
 (close
   (0 1 . gcd)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 49173)
       (if.true.ret)
       (push.const . gcd)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 50223)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 50197))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 48133))
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 52229))
 (set.gloc.of gcd)
 (ret.const.unspec))
((close
   (2 0)
   (call
     (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 64529)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 0)
     (ret.subr.gloc.of = "./boot/r6rs-aux.scm" . 64537))
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of exact? 1 "./boot/r6rs-aux.scm" . 65558)
       (if.false.ret)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of exact? "./boot/r6rs-aux.scm" . 65569))
     (if.true.ret.const . 0)
     (ret.const . 0.0))
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of gcd2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of gcd2 "./boot/r6rs-aux.scm" . 66593))
   (push)
   (push.subr.gloc.of quotient 2 "./boot/r6rs-aux.scm" . 66581)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 66578)
   (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 66573))
 (set.gloc.of lcm2\x60;2)
 (close
   (1 0 . loop)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/r6rs-aux.scm" . 73741)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 2)
   (if.eq?
     (touch.gloc.of lcm2\x60;2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74772)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 74782)
     (apply.gloc.of lcm2\x60;2 "./boot/r6rs-aux.scm" . 74766))
   (push.iloc.0 . 0)
   (const . 1)
   (if.eq?
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 75795)
     (ret.subr.gloc.of abs "./boot/r6rs-aux.scm" . 75790))
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?.ret.const . 1)
   (touch.gloc.of loop\x60;9)
   (call
     (touch.gloc.of lcm2\x60;2)
     (push.car.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77857)
     (push.cadr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77867)
     (apply.gloc.of lcm2\x60;2 "./boot/r6rs-aux.scm" . 77851))
   (push)
   (cddr.iloc (1 . 0) "./boot/r6rs-aux.scm" . 77879)
   (push.cons)
   (apply.gloc.of loop\x60;9 "./boot/r6rs-aux.scm" . 77839))
 (set.gloc.of loop\x60;9)
 (close
   (0 1 . lcm)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of integer-valued? 1 "./boot/r6rs-aux.scm" . 69653)
       (if.true.ret)
       (push.const . lcm)
       (push.const . "expected integer, but got ~s")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 70703)
       (push.iloc.1 . 0)
       (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 70677))
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/r6rs-aux.scm" . 68613))
   (touch.gloc.of loop\x60;9)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;9 "./boot/r6rs-aux.scm" . 72709))
 (set.gloc.of lcm)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 93207)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.subr.gloc.of ceiling 1 "./boot/r6rs-aux.scm" . 95264)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 1) "./boot/r6rs-aux.scm" . 96288)
   (if.true (ret.iloc 0 . 0))
   (push.n+.iloc (0 . 0) -1 "./boot/r6rs-aux.scm" . 98345)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1)
   (call
     (touch.gloc.of loop\x60;7)
     (push.const . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 99383)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 99378)
     (push.const . 1)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 99399)
     (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 99394)
     (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 99372))
   (push)
   (push.subr.gloc.of / 2 "./boot/r6rs-aux.scm" . 99367)
   (ret.subr.gloc.of + "./boot/r6rs-aux.scm" . 99362))
 (set.gloc.of loop\x60;7)
 (close
   (2 0 . rationalize)
   (push.iloc.0 . 0)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 81929)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 81973)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 82026)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 81939))
   (push.iloc.0 . 1)
   (subr.gloc.of real? 1 "./boot/r6rs-aux.scm" . 82953)
   (if.false.call
     (push.const . rationalize)
     (push.const . "expected real, but got ~s as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/r6rs-aux.scm" . 82997)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/r6rs-aux.scm" . 83050)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 82963))
   (push.iloc.0 . 1)
   (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 83980)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of infinite? 1 "./boot/r6rs-aux.scm" . 85008)
     (if.true.ret.const . +nan.0)
     (ret.const . 0.0))
   (=n.iloc (0 . 0) 0 "./boot/r6rs-aux.scm" . 86028)
   (if.true (ret.iloc 0 . 0))
   (iloc.0 . 0)
   (=.iloc (0 . 1) "./boot/r6rs-aux.scm" . 87052)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (subr.gloc.of negative? 1 "./boot/r6rs-aux.scm" . 88076)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 1 "./boot/r6rs-aux.scm" . 89116)
       (push.iloc.0 . 1)
       (apply.gloc.of rationalize "./boot/r6rs-aux.scm" . 89103))
     (push)
     (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 89100))
   (push.iloc.0 . 1)
   (push.subr.gloc.of abs 1 "./boot/r6rs-aux.scm" . 91157)
   (extend . 1)
   (touch.gloc.of loop\x60;7)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 92193)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of + 2 "./boot/r6rs-aux.scm" . 92207)
   (apply.gloc.of loop\x60;7 "./boot/r6rs-aux.scm" . 92174))
 (set.gloc.of rationalize)
 (ret.const.unspec))
((close
   (1 0 . string->list)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/r6rs-aux.scm" . 116753)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (push.subr.gloc.of get-char 1 "./boot/r6rs-aux.scm" . 118803)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/r6rs-aux.scm" . 119823)
     (if.true (push.iloc.1 . 0) (ret.subr.gloc.of reverse "./boot/r6rs-aux.scm" . 120847))
     (push.iloc.0 . 0)
     (iloc.1 . 0)
     (push.cons)
     (apply.iloc+ (2 . 0) "./boot/r6rs-aux.scm" . 121871))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/r6rs-aux.scm" . 117767))
 (set.gloc.of string->list)
 (ret.const.unspec))
((close
   (2 0)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 138274)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 138262))
   (push)
   (call
     (touch.gloc.of map-n\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 139298)
     (apply.gloc.of map-n\x60;2 "./boot/r6rs-aux.scm" . 139286))
   (ret.cons "./boot/r6rs-aux.scm" . 138256))
 (set.gloc.of map-n\x60;2)
 (close
   (2 0)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 131100)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 131094))
   (push)
   (call
     (touch.gloc.of map-1\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 132130)
     (apply.gloc.of map-1\x60;2 "./boot/r6rs-aux.scm" . 132118))
   (ret.cons "./boot/r6rs-aux.scm" . 131088))
 (set.gloc.of map-1\x60;2)
 (close
   (2 1 . map)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 142349)
     (if.true
       (touch.gloc.of map-1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of map-1\x60;2 "./boot/r6rs-aux.scm" . 143373))
     (push.const . map)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 144423))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 144474)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 144397))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 145424))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of map-n\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of map-n\x60;2 "./boot/r6rs-aux.scm" . 146465))
   (push.const . map)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 148558)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 148496))
 (set.gloc.of map)
 (ret.const.unspec))
((close
   (2 0)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 156710)
     (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 156704))
   (touch.gloc.of for-each-1\x60;2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 157745)
   (apply.gloc.of for-each-1\x60;2 "./boot/r6rs-aux.scm" . 157728))
 (set.gloc.of for-each-1\x60;2)
 (close
   (2 0)
   (iloc.0 . 1)
   (if.null? (ret.const.unspec))
   (call
     (push.iloc.0 . 0)
     (push.car.iloc (0 . 1) "./boot/r6rs-aux.scm" . 161837)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 161825))
   (touch.gloc.of for-each-n\x60;2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/r6rs-aux.scm" . 162866)
   (apply.gloc.of for-each-n\x60;2 "./boot/r6rs-aux.scm" . 162849))
 (set.gloc.of for-each-n\x60;2)
 (close
   (2 1 . for-each)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/r6rs-aux.scm" . 164877)
     (if.true
       (touch.gloc.of for-each-1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of for-each-1\x60;2 "./boot/r6rs-aux.scm" . 165901))
     (push.const . for-each)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "proper list")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/r6rs-aux.scm" . 166956))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 167007)
     (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 166925))
   (call
     (push.gloc.of list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 167952))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of for-each-n\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each-n\x60;2 "./boot/r6rs-aux.scm" . 168993))
   (push.const . for-each)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.subr.gloc.of cons* 3 "./boot/r6rs-aux.scm" . 171091)
   (apply.gloc.of assertion-violation "./boot/r6rs-aux.scm" . 171024))
 (set.gloc.of for-each)
 (ret.const.unspec))
((close
   (2 1 . vector-map)
   (call
     (push.gloc.of map)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 176150)
     (call
       (push.gloc.of vector->list)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/r6rs-aux.scm" . 177165))
     (push)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 176134))
   (push)
   (ret.subr.gloc.of list->vector "./boot/r6rs-aux.scm" . 175109))
 (set.gloc.of vector-map)
 (ret.const.unspec))
((close
   (2 1 . vector-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of vector->list 1 "./boot/r6rs-aux.scm" . 181274)
   (call
     (push.gloc.of vector->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 182284))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 181253))
 (set.gloc.of vector-for-each)
 (ret.const.unspec))
((close
   (2 1 . string-for-each)
   (push.gloc.of for-each)
   (push.iloc.0 . 0)
   (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/r6rs-aux.scm" . 186394))
   (push)
   (call
     (push.gloc.of string->list)
     (push.iloc.0 . 2)
     (apply.gloc.of map "./boot/r6rs-aux.scm" . 187404))
   (push)
   (apply.gloc.of apply "./boot/r6rs-aux.scm" . 186373))
 (set.gloc.of string-for-each)
 (ret.const.unspec))
((close
   (2 0 . call-with-values)
   (touch.gloc.of apply-values)
   (push.iloc.0 . 1)
   (call (apply.iloc (0 . 0) "./boot/r6rs-aux.scm" . 191516))
   (push)
   (apply.gloc.of apply-values "./boot/r6rs-aux.scm" . 191493))
 (set.gloc.of call-with-values)
 (ret.const.unspec))
((close
   (2 0 . call-with-port)
   (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (1 . 1) "./boot/r6rs-aux.scm" . 196625))
   (push.close
     (0 1)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/r6rs-aux.scm" . 198664)
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/r6rs-aux.scm" . 199688))
   (apply.gloc.of call-with-values "./boot/r6rs-aux.scm" . 195589))
 (set.gloc.of call-with-port)
 (ret.const.unspec))
((close
   (2 0 . mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 203789)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 203786)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 203781))
 (set.gloc.of mod)
 (ret.const.unspec))
((close
   (2 0 . div-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div 2 "./boot/r6rs-aux.scm" . 207886)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 208918)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 208913)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 208903))
 (set.gloc.of div-and-mod)
 (ret.const.unspec))
((close
   (2 0 . mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 213005)
   (push.iloc.0 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 213002)
   (ret.subr.gloc.of - "./boot/r6rs-aux.scm" . 212997))
 (set.gloc.of mod0)
 (ret.const.unspec))
((close
   (2 0 . div0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of div0 2 "./boot/r6rs-aux.scm" . 217103)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of * 2 "./boot/r6rs-aux.scm" . 218135)
   (push.subr.gloc.of - 2 "./boot/r6rs-aux.scm" . 218130)
   (ret.subr.gloc.of values "./boot/r6rs-aux.scm" . 218119))
 (set.gloc.of div0-and-mod0)
 (ret.const.unspec))

;
((close
   (1 0 . top-level-unbound?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-bound? 1 "./boot/common.scm" . 7178)
   (ret.subr.gloc.of not "./boot/common.scm" . 7173))
 (set.gloc.of top-level-unbound?)
 (ret.const.unspec))
((close
   (3 0 . acons)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (ret.cons "./boot/common.scm" . 11269))
 (set.gloc.of acons)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 16413)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 16423)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 16407))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . count-pair)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 15365))
 (set.gloc.of count-pair)
 (ret.const.unspec))
((close
   (1 0 . circular-tree?)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (2 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/common.scm" . 22546)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/common.scm" . 23570))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 25625)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/common.scm" . 27685)
           (push.iloc.0 . 0)
           (apply.iloc (2 . 0) "./boot/common.scm" . 27679))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/common.scm" . 28709)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/common.scm" . 28703))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/common.scm" . 29721)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 30745)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.iloc (3 . 0) "./boot/common.scm" . 32813))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/common.scm" . 32832)
         (apply.gloc.of any1 "./boot/common.scm" . 32795))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/common.scm" . 33817)
       (if.false.ret)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (subr.gloc.of core-hashtable-set! 3 "./boot/common.scm" . 34841)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (extend . 1)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.iloc (3 . 0) "./boot/common.scm" . 36909))
       (push.iloc.1 . 0)
       (push.subr.gloc.of tuple->list 1 "./boot/common.scm" . 36928)
       (apply.gloc.of any1 "./boot/common.scm" . 36891))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc (0 . 0) "./boot/common.scm" . 21516))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of circular-tree?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 45073)
     (push.n+.iloc (0 . 1) 1 "./boot/common.scm" . 45083)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 45067))
   (call (iloc.0 . 0) (if.not.null?.ret.const . #f) (ret.iloc 0 . 1))
   (if.true.ret)
   (ret.const . -1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . safe-length)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 43013))
 (set.gloc.of safe-length)
 (ret.const.unspec))
((close
   (2 0 . split-at)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-head 2 "./boot/common.scm" . 50191)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-tail 2 "./boot/common.scm" . 50209)
   (ret.subr.gloc.of values "./boot/common.scm" . 50183))
 (set.gloc.of split-at)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/common.scm" . 57384)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 58400)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 58410)
   (subr.gloc.of memq 2 "./boot/common.scm" . 58394)
   (if.true.ret)
   (touch.gloc.of loop\x60;5)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 59424)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 59418))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . unique-id-list?)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 54282)
   (if.false.ret)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;5 "./boot/common.scm" . 55311))
   (push)
   (ret.subr.gloc.of not "./boot/common.scm" . 54277))
 (set.gloc.of unique-id-list?)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/common.scm" . 66587)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 66597)
   (subr.gloc.of memq 2 "./boot/common.scm" . 66581)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/common.scm" . 67605))
   (touch.gloc.of loop\x60;5)
   (push.cdr.iloc (0 . 0) "./boot/common.scm" . 68635)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 68629))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . find-duplicates)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/common.scm" . 63498)
   (if.false.ret)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;5 "./boot/common.scm" . 64522))
 (set.gloc.of find-duplicates)
 (ret.const.unspec))
((close
   (2 0 . every1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/common.scm" . 74768))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 76826)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 76837)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 76820))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 73754)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 73771)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 73737))
 (set.gloc.of every1)
 (ret.const.unspec))
((close
   (3 0 . every2)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 2)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (4 0 . loop)
     (call (push.iloc.0 . 0) (push.iloc.0 . 2) (apply.iloc (2 . 0) "./boot/common.scm" . 83984))
     (if.false.ret)
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 3)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "./boot/common.scm" . 87066)
     (push.cdr.iloc (0 . 1) "./boot/common.scm" . 87078)
     (push.car.iloc (0 . 3) "./boot/common.scm" . 87090)
     (push.cdr.iloc (0 . 3) "./boot/common.scm" . 87102)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 87060))
   (push.car.iloc (1 . 1) "./boot/common.scm" . 82971)
   (push.cdr.iloc (1 . 1) "./boot/common.scm" . 82990)
   (push.car.iloc (1 . 2) "./boot/common.scm" . 83009)
   (push.cdr.iloc (1 . 2) "./boot/common.scm" . 83028)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 82953))
 (set.gloc.of every2)
 (ret.const.unspec))
((close
   (2 0 . any1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 92180)
     (apply.iloc (0 . 0) "./boot/common.scm" . 92174))
   (if.true.ret)
   (touch.gloc.of any1)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 92202)
   (apply.gloc.of any1 "./boot/common.scm" . 92191))
 (set.gloc.of any1)
 (ret.const.unspec))
((close
   (3 0 . any2)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 2)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "./boot/common.scm" . 98324)
     (push.car.iloc (0 . 2) "./boot/common.scm" . 98335)
     (apply.iloc (0 . 0) "./boot/common.scm" . 98318))
   (if.true.ret)
   (touch.gloc.of any2)
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "./boot/common.scm" . 99353)
   (push.cdr.iloc (0 . 2) "./boot/common.scm" . 99364)
   (apply.gloc.of any2 "./boot/common.scm" . 99342))
 (set.gloc.of any2)
 (ret.const.unspec))
((close
   (2 0 . filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105492)
       (apply.iloc (2 . 0) "./boot/common.scm" . 105486))
     (if.true
       (push.car.iloc (0 . 0) "./boot/common.scm" . 105509)
       (call
         (push.cdr.iloc (0 . 0) "./boot/common.scm" . 105525)
         (apply.iloc+ (1 . 0) "./boot/common.scm" . 105519))
       (ret.cons "./boot/common.scm" . 105503))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 106521)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 106515))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 103429))
 (set.gloc.of filter)
 (ret.const.unspec))
((close
   (2 0 . partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111650)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/common.scm" . 111665)
       (ret.subr.gloc.of values "./boot/common.scm" . 111642))
     (call
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112660)
       (apply.iloc (2 . 0) "./boot/common.scm" . 112654))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/common.scm" . 112677)
       (push.car.iloc (0 . 0) "./boot/common.scm" . 112693)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 112671))
     (push.cdr.iloc (0 . 0) "./boot/common.scm" . 113689)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/common.scm" . 113710)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/common.scm" . 113683))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 110597))
 (set.gloc.of partition)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of make-string-input-port 1 "./boot/common.scm" . 120851)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop1)
     (extend.enclose+
       (1 0 . loop2)
       (push.iloc.0 . 0)
       (subr.gloc.of eof-object? 1 "./boot/common.scm" . 124950)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 125983)
         (extend . 1)
         (push.iloc.0 . 0)
         (push.const . "")
         (subr.gloc.of string=? 2 "./boot/common.scm" . 127004)
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of reverse "./boot/common.scm" . 128028))
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (push.cons)
         (ret.subr.gloc.of reverse "./boot/common.scm" . 129052))
       (call (push.iloc.0 . 0) (apply.iloc (5 . 1) "./boot/common.scm" . 130070))
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/common.scm" . 131107)
         (iloc 2 . 0)
         (push.cons)
         (apply.iloc+ (3 . 0) "./boot/common.scm" . 131094))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of put-char 2 "./boot/common.scm" . 133142)
       (push.iloc 4 . 0)
       (push.subr.gloc.of get-char 1 "./boot/common.scm" . 134173)
       (apply.iloc+ (1 . 0) "./boot/common.scm" . 134166))
     (push.iloc 3 . 0)
     (push.subr.gloc.of get-char 1 "./boot/common.scm" . 123932)
     (apply.iloc+ (0 . 0) "./boot/common.scm" . 123917))
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/common.scm" . 122891))
 (set.gloc.of split->list\x60;2)
 (close
   (2 0 . string-split)
   (push.iloc.0 . 1)
   (subr.gloc.of char? 1 "./boot/common.scm" . 136204)
   (if.true
     (touch.gloc.of split->list\x60;2)
     (push.iloc.0 . 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of char=? "./boot/common.scm" . 137257))
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 137228))
   (push.iloc.0 . 1)
   (subr.gloc.of string? 1 "./boot/common.scm" . 138252)
   (if.true
     (call (push.iloc.0 . 1) (apply.gloc.of string->list "./boot/common.scm" . 139287))
     (push)
     (extend . 1)
     (touch.gloc.of split->list\x60;2)
     (push.iloc.1 . 0)
     (push.close
       (1 0)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of char=? "./boot/common.scm" . 140349))
       (push.iloc.1 . 0)
       (apply.gloc.of any1 "./boot/common.scm" . 140331))
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 140302))
   (push.iloc.0 . 1)
   (subr.gloc.of procedure? 1 "./boot/common.scm" . 141324)
   (if.true
     (touch.gloc.of split->list\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of split->list\x60;2 "./boot/common.scm" . 142348))
   (ret.const.unspec))
 (set.gloc.of string-split)
 (ret.const.unspec))
((close
   (2 1 . wrong-type-argument-message)
   (iloc.0 . 2)
   (if.null?
     (push.const . "expected ~a, but got ~a")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of format "./boot/common.scm" . 147465))
   (push.const . "expected ~a, but got ~a, as argument ~a")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.car.iloc (0 . 2) "./boot/common.scm" . 148550)
   (ret.subr.gloc.of format "./boot/common.scm" . 148489))
 (set.gloc.of wrong-type-argument-message)
 (ret.const.unspec))

;
((close
   (1 1 . make-parameter)
   (call
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of parameter-proc-0)
       (subr.gloc.of gensym 0)
       (push)
       (apply.gloc.of parameter-proc-0 "./boot/parameter.scm" . 8218))
     (touch.gloc.of parameter-proc-1)
     (subr.gloc.of gensym 0)
     (push)
     (push.car.iloc (0 . 1) "./boot/parameter.scm" . 9269)
     (apply.gloc.of parameter-proc-1 "./boot/parameter.scm" . 9242))
   (push)
   (extend . 1)
   (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/parameter.scm" . 10254))
   (ret.iloc 0 . 0))
 (set.gloc.of make-parameter)
 (ret.const.unspec))
((close
   (1 0 . parameter-proc-0)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 16395))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (0 . 0) "./boot/parameter.scm" . 17474)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 17419)))
 (set.gloc.of parameter-proc-0)
 (ret.const.unspec))
((close
   (2 0 . parameter-proc-1)
   (ret.close
     (0 1)
     (iloc.0 . 0)
     (if.null?
       (subr.gloc.of current-dynamic-environment 0)
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/parameter.scm" . 23563))
     (subr.gloc.of current-dynamic-environment 0)
     (push)
     (push.iloc.1 . 0)
     (call
       (push.car.iloc (0 . 0) "./boot/parameter.scm" . 24648)
       (apply.iloc (1 . 1) "./boot/parameter.scm" . 24642))
     (push)
     (ret.subr.gloc.of core-hashtable-set! "./boot/parameter.scm" . 24587)))
 (set.gloc.of parameter-proc-1)
 (ret.const.unspec))

;
((call (push.const . 5) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 5149))
 (set.gloc.of expansion-backtrace)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 6175))
 (set.gloc.of expansion-trace-stack)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 7199))
 (set.gloc.of expansion-trace-level)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 8231))
 (set.gloc.of current-immutable-identifiers)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 9248))
 (set.gloc.of current-expansion-mode)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 10279))
 (set.gloc.of current-expansion-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 11298))
 (set.gloc.of current-macro-expression)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 12329))
 (set.gloc.of current-transformer-environment)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 13345))
 (set.gloc.of unexpect-top-level-form)
 (ret.const.unspec))
((close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 14374))
 (set.gloc.of current-after-expansion-hook)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 15393))
 (set.gloc.of current-temporary-count)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 16414))
 (set.gloc.of current-rename-count)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 17442))
 (set.gloc.of current-closure-comments)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/macro/initial.scm" . 18468))
 (set.gloc.of current-top-level-exterior)
 (ret.const.unspec))
((close
   (4 0)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/initial.scm" . 22538)
     (if.false.ret)
     (push.iloc.0 . 1)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 23562))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (const . syntax)
     (if.eq?
       (touch.gloc.of make-macro)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of make-macro "./boot/macro/initial.scm" . 28701))
     (push.iloc.0 . 0)
     (const . variable)
     (if.eq?
       (push.iloc.0 . 2)
       (subr.gloc.of procedure? 1 "./boot/macro/initial.scm" . 30756)
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 31780))
       (call
         (touch.gloc.of variable-transformer-token?)
         (push.iloc.0 . 2)
         (apply.gloc.of variable-transformer-token? "./boot/macro/initial.scm" . 32804))
       (if.true
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/initial.scm" . 33849)
         (push.iloc.0 . 3)
         (apply.gloc.of make-macro-variable "./boot/macro/initial.scm" . 33828))
       (push.const
         .
         "internal error in .set-top-level-macro!: bad transformer type:~s keyword:~s datum:~s")
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of scheme-error "./boot/macro/initial.scm" . 35876))
     (ret.const.unspec))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 21507))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;set-top-level-macro!)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/initial.scm" . 21507))
((close
   (1 0 . core-primitive-name)
   (push.const . "~a~a")
   (subr.gloc.of current-primitive-prefix 0)
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 3 "./boot/macro/initial.scm" . 39957)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 39941))
 (set.gloc.of core-primitive-name)
 (ret.const.unspec))
((close
   (2 0 . generate-global-id)
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (subr.gloc.of current-library-suffix 0)
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 44053)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 44037))
 (set.gloc.of generate-global-id)
 (ret.const.unspec))
((close
   (0 0 . generate-temporary-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 48146))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 49184)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 49159))
   (push.const . ".L~a")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/initial.scm" . 50199)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 50183))
 (set.gloc.of generate-temporary-symbol)
 (ret.const.unspec))
((close
   (1 0 . generate-local-macro-symbol)
   (call
     (touch.gloc.of current-temporary-count)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 54290))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-temporary-count)
     (push.n+.iloc (0 . 0) 1 "./boot/macro/initial.scm" . 55328)
     (apply.gloc.of current-temporary-count "./boot/macro/initial.scm" . 55303))
   (push.const . ".LOCAL-MACRO-~a.~a~a~a")
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (subr.gloc.of current-rename-delimiter 0)
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 56412))
   (push)
   (push.subr.gloc.of format 5 "./boot/macro/initial.scm" . 56343)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 56327))
 (set.gloc.of generate-local-macro-symbol)
 (ret.const.unspec))
((close
   (1 0 . local-macro-symbol?)
   (push.iloc.0 . 0)
   (push.const . ".LOCAL-MACRO-")
   (push.subr.gloc.of symbol-contains 2 "./boot/macro/initial.scm" . 60426)
   (const . 0)
   (ret.eq? "./boot/macro/initial.scm" . 60421))
 (set.gloc.of local-macro-symbol?)
 (ret.const.unspec))
((close
   (0 0 . fresh-rename-count)
   (call
     (touch.gloc.of current-rename-count)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 64542))
     (push)
     (push.const . 1)
     (push.subr.gloc.of + 2 "./boot/macro/initial.scm" . 64539)
     (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 64517))
   (touch.gloc.of current-rename-count)
   (apply.gloc.of current-rename-count "./boot/macro/initial.scm" . 65541))
 (set.gloc.of fresh-rename-count)
 (ret.const.unspec))
((close
   (2 0 . rename-id)
   (push.const . "~a~a~a")
   (push.iloc.0 . 0)
   (subr.gloc.of current-rename-delimiter 0)
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 4 "./boot/macro/initial.scm" . 69653)
   (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 69637))
 (set.gloc.of rename-id)
 (ret.const.unspec))
((close
   (1 0 . renamed-id?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of current-rename-delimiter 0)
   (push)
   (ret.subr.gloc.of symbol-contains "./boot/macro/initial.scm" . 74762))
 (set.gloc.of renamed-id?)
 (ret.const.unspec))
((close
   (1 0 . original-id)
   (push.iloc.0 . 0)
   (subr.gloc.of current-rename-delimiter 0)
   (push)
   (push.subr.gloc.of symbol-contains 2 "./boot/macro/initial.scm" . 78860)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 79929)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of substring 3 "./boot/macro/initial.scm" . 79918)
     (ret.subr.gloc.of string->symbol "./boot/macro/initial.scm" . 79902))
   (ret.iloc 1 . 0))
 (set.gloc.of original-id)
 (ret.const.unspec))
((close
   (1 0 . strip-rename-suffix)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 86058)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 86037))
     (push)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 87082)
       (apply.gloc.of strip-rename-suffix "./boot/macro/initial.scm" . 87061))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/initial.scm" . 88097)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/initial.scm" . 88115)
       (ret.eq? "./boot/macro/initial.scm" . 88108))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/initial.scm" . 89114))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of original-id)
     (push.iloc.0 . 0)
     (apply.gloc.of original-id "./boot/macro/initial.scm" . 90138))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/initial.scm" . 91148)
   (if.true
     (call
       (push.gloc.of strip-rename-suffix)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/initial.scm" . 91201)
       (apply.gloc.of map "./boot/macro/initial.scm" . 91176))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/initial.scm" . 91162))
   (ret.iloc 0 . 0))
 (set.gloc.of strip-rename-suffix)
 (ret.const.unspec))
((close
   (1 0 . retrieve-rename-suffix)
   (push.iloc.0 . 0)
   (subr.gloc.of current-rename-delimiter 0)
   (push)
   (push.subr.gloc.of symbol-contains 2 "./boot/macro/initial.scm" . 96268)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of symbol->string 1 "./boot/macro/initial.scm" . 98333)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/macro/initial.scm" . 99368)
     (ret.subr.gloc.of substring "./boot/macro/initial.scm" . 99347))
   (ret.const . ""))
 (set.gloc.of retrieve-rename-suffix)
 (ret.const.unspec))
((close
   (2 0 . set-closure-comment!)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 104458))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 105503))
   (push)
   (push.iloc.0 . 0)
   (push.const . heap)
   (iloc.0 . 1)
   (push.cons)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 105482))
 (set.gloc.of set-closure-comment!)
 (ret.const.unspec))
((close
   (2 1 . annotate-closure)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 109578))
   (if.false.ret)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 110629))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 110609)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.1 . 2)
     (if.null?
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 113711))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 113690))
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 114735))
     (push)
     (push.iloc.1 . 0)
     (push.car.iloc (1 . 2) "./boot/macro/initial.scm" . 114773)
     (cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 114784)
     (push.cons)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 114714))
   (ret.const.unspec))
 (set.gloc.of annotate-closure)
 (ret.const.unspec))
((close
   (1 0 . annotated?)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 118794)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 119818)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of annotated?)
 (ret.const.unspec))
((close
   (1 0 . get-annotation)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 125962)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 126986))
 (set.gloc.of get-annotation)
 (ret.const.unspec))
((close
   (2 0 . put-annotation)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 132106)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 133130))
   (ret.iloc 0 . 0))
 (set.gloc.of put-annotation)
 (ret.const.unspec))
((close
   (2 0)
   (iloc.0 . 1)
   (if.false.ret)
   (extend.enclose
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/initial.scm" . 143381)
     (if.false.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 144409)
     (if.true.ret)
     (subr.gloc.of current-source-comments 0)
     (push)
     (push.iloc.0 . 0)
     (push.iloc 2 . 1)
     (subr.gloc.of core-hashtable-set! 3 "./boot/macro/initial.scm" . 146459)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of for-each "./boot/macro/initial.scm" . 147483))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/initial.scm" . 142350))
 (set.gloc.of put-note!\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of core-hashtable-ref 3 "./boot/macro/initial.scm" . 153620)
   (if.true.ret)
   (call
     (touch.gloc.of loop\x60;15)
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 154650)
     (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 154644))
   (if.true.ret)
   (touch.gloc.of loop\x60;15)
   (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 155674)
   (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 155668))
 (set.gloc.of loop\x60;15)
 (close
   (1 0)
   (touch.gloc.of loop\x60;15)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;15 "./boot/macro/initial.scm" . 151561))
 (set.gloc.of get-note\x60;2)
 (close
   (2 0 . annotate)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (if.eq?.ret.const . #f)
     (call
       (call
         (subr.gloc.of current-source-comments 0 "./boot/macro/initial.scm" . 161816)
         (if.false.ret)
         (touch.gloc.of get-note\x60;2)
         (push.iloc.0 . 1)
         (apply.gloc.of get-note\x60;2 "./boot/macro/initial.scm" . 161842))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of put-note!\x60;2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of put-note!\x60;2 "./boot/macro/initial.scm" . 162850))
       (ret.const.unspec))
     (call
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 163864))
       (if.false.ret)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 163911))
       (push)
       (push.iloc.0 . 1)
       (push.const . #f)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/initial.scm" . 163891))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/macro/initial.scm" . 164919))
       (push)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/initial.scm" . 164898))
     (ret.const.unspec))
   (ret.iloc 0 . 0))
 (set.gloc.of annotate)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 173071)
     (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 173080))
     (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 174106)
     (call
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 174122)
       (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 174132)
       (apply.gloc.of loop\x60;5 "./boot/macro/initial.scm" . 174116))
     (ret.cons "./boot/macro/initial.scm" . 174100))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;5)
 (close
   (2 0 . abbreviated-take)
   (touch.gloc.of annotate)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;5 "./boot/macro/initial.scm" . 171014))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 171014))
 (set.gloc.of abbreviated-take)
 (ret.const.unspec))
((close
   (3 0 . abbreviated-take-form)
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (3 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (<=n.iloc (0 . 1) 0 "./boot/macro/initial.scm" . 182291)
           (if.true.ret)
           (push.iloc.0 . 2)
           (push.const . 0)
           (ret.subr.gloc.of <= "./boot/macro/initial.scm" . 182301))
         (if.true (push.const . ...) (ret.subr.gloc.of list "./boot/macro/initial.scm" . 182312))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/initial.scm" . 183328)
           (push.n+.iloc (0 . 1) -1 "./boot/macro/initial.scm" . 183338)
           (push.iloc.0 . 2)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 183322))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/initial.scm" . 183357)
           (push.iloc 2 . 1)
           (push.n+.iloc (0 . 2) -1 "./boot/macro/initial.scm" . 183372)
           (apply.iloc+ (1 . 0) "./boot/macro/initial.scm" . 183351))
         (ret.cons "./boot/macro/initial.scm" . 183316))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.iloc+ (0 . 0) "./boot/macro/initial.scm" . 180230))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/initial.scm" . 178179))
 (set.gloc.of abbreviated-take-form)
 (ret.const.unspec))

;
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 9234)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 9259)
       (apply.gloc.of formals->list "./boot/macro/expand.scm" . 9244))
     (ret.cons "./boot/macro/expand.scm" . 9228))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/macro/expand.scm" . 11276))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . collect-lambda-formals)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/macro/expand.scm" . 15377))
   (push)
   (extend . 1)
   (call
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/expand.scm" . 16395))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 17437)
     (push.const . "malformed formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 17419))
   (call
     (call
       (touch.gloc.of unique-id-list?)
       (push.iloc.0 . 0)
       (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 18443))
     (if.true.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 19485)
     (push.const . "duplicate formals")
     (push.iloc.1 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 19467))
   (ret.iloc 0 . 0))
 (set.gloc.of collect-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . rename-lambda-formals)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 26653)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 26647)
     (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 26642)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 27689)
       (push.iloc.0 . 1)
       (apply.gloc.of rename-lambda-formals "./boot/macro/expand.scm" . 27666))
     (ret.cons "./boot/macro/expand.scm" . 26636))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 29713)
   (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 29708))
 (set.gloc.of rename-lambda-formals)
 (ret.const.unspec))
((close
   (2 0 . check-let*-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 33801)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 34843)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 34825))
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.0 . 0)
         (apply.gloc.of safe-length "./boot/macro/expand.scm" . 36893))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/expand.scm" . 36890)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 36927)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 36918))
     (if.true.ret)
     (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 37927)
     (push.const . "expected each binding consist of symbol and expression")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 37909))
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/expand.scm" . 35845))
 (set.gloc.of check-let*-bindings)
 (ret.const.unspec))
((close
   (2 0 . check-let-bindings)
   (call
     (push.iloc.0 . 1)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 43017)
     (if.true.ret)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 44059)
     (push.const . "malformed bindings")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 44041))
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.close
         (1 0)
         (call
           (call
             (touch.gloc.of safe-length)
             (push.iloc.0 . 0)
             (apply.gloc.of safe-length "./boot/macro/expand.scm" . 47133))
           (push)
           (push.const . 2)
           (subr.gloc.of = 2 "./boot/macro/expand.scm" . 47130)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 47167)
           (if.not.symbol?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 47182))
         (if.true.ret)
         (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 48167)
         (push.const . "expected each binding consist of symbol and expression")
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 48149))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 46090))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 45065))
   (if.true.ret)
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 50203)
   (push.const . "duplicate bindings")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 50185))
 (set.gloc.of check-let-bindings)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 59416)
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 60446)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 60440))
     (push)
     (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 59410))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 62489)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 63518))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;7)
 (close
   (1 0)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 57353))
 (set.gloc.of filter-unique-ids\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 72738)
     (push.const . quote)
     (push.subr.gloc.of eq? 2 "./boot/macro/expand.scm" . 72733)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 72728))
   (if.true
     (push.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 73747))
   (ret.const))
 (set.gloc.of loop\x60;15)
 (close
   (1 0)
   (touch.gloc.of filter-unique-ids\x60;2)
   (call
     (touch.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;15 "./boot/macro/expand.scm" . 69642))
   (push)
   (apply.gloc.of filter-unique-ids\x60;2 "./boot/macro/expand.scm" . 57353))
 (set.gloc.of collect-ids\x60;2)
 (close
   (2 0 . check-internal-def-contract-violation)
   (call
     (touch.gloc.of collect-ids\x60;2)
     (push.iloc.0 . 1)
     (apply.gloc.of collect-ids\x60;2 "./boot/macro/expand.scm" . 76816))
   (push)
   (extend . 1)
   (touch.gloc.of any1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 77855)
     (if.false.ret)
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.gloc.of any1 "./boot/macro/expand.scm" . 77831))
 (set.gloc.of check-internal-def-contract-violation)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 87064)
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 88094)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 88088))
     (push)
     (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 87058))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 90137)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 91166))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;7)
 (close
   (1 0)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/macro/expand.scm" . 85001))
 (set.gloc.of filter-unique-ids\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 100387)
     (push.const lambda quote)
     (push.subr.gloc.of memq 2 "./boot/macro/expand.scm" . 100381)
     (ret.subr.gloc.of not "./boot/macro/expand.scm" . 100376))
   (if.true
     (push.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 101395))
   (ret.const))
 (set.gloc.of loop\x60;15)
 (close
   (1 0)
   (touch.gloc.of filter-unique-ids\x60;2)
   (call
     (touch.gloc.of loop\x60;15)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;15 "./boot/macro/expand.scm" . 97290))
   (push)
   (apply.gloc.of filter-unique-ids\x60;2 "./boot/macro/expand.scm" . 85001))
 (set.gloc.of collect-ids\x60;2)
 (close
   (2 0 . check-rec-contract-violation)
   (call
     (touch.gloc.of collect-ids\x60;2)
     (push.iloc.0 . 1)
     (apply.gloc.of collect-ids\x60;2 "./boot/macro/expand.scm" . 104464))
   (push)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 107543)
       (push.iloc 2 . 0)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 107537)
       (if.true
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 108567)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 108584)
         (iloc.0 . 1)
         (push.cons)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 108561))
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 109591)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 109585))
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of reverse "./boot/macro/expand.scm" . 110622))
   (push.iloc 2 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 105479))
 (set.gloc.of check-rec-contract-violation)
 (ret.const.unspec))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc.0 . 0)
       (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 116786)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 116751))
     (if.true
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 117781)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 117792)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 117810)
       (iloc.0 . 2)
       (push.cons)
       (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 117775))
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 118805)
     (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 118816)
     (push.iloc.0 . 2)
     (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 118799))
   (iloc.0 . 2)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of reverse "./boot/macro/expand.scm" . 119836))
 (set.gloc.of loop\x60;5)
 (close
   (2 0 . check-rec*-contract-violation)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of loop\x60;5 "./boot/macro/expand.scm" . 114693))
 (set.gloc.of check-rec*-contract-violation)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/expand.scm" . 131079))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . rewrite-letrec*-bindings)
   (push.close
     (0 0)
     (touch.gloc.of partition)
     (push.close
       (1 0)
       (cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 125995)
       (if.pair?
         (call
           (touch.gloc.of denote-quote?)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 127035)
           (apply.gloc.of denote-quote? "./boot/macro/expand.scm" . 127016))
         (if.true.ret)
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caadr 1 "./boot/macro/expand.scm" . 128060)
         (apply.gloc.of denote-lambda? "./boot/macro/expand.scm" . 128040))
       (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 129074)
       (push.subr.gloc.of symbol? 1 "./boot/macro/expand.scm" . 129065)
       (ret.subr.gloc.of not "./boot/macro/expand.scm" . 129060))
     (push.iloc.1 . 0)
     (apply.gloc.of partition "./boot/macro/expand.scm" . 124947))
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 122883))
 (set.gloc.of rewrite-letrec*-bindings)
 (ret.const.unspec))
((close
   (2 0 . flatten-begin)
   (extend.enclose
     (1 0)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 138261)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 139297)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 139278))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 144399))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 145429)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 146459)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 146453))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 145423))
       (iloc.0 . 1)
       (if.null? (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of append "./boot/macro/expand.scm" . 150550))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 142342))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 136197))
 (set.gloc.of flatten-begin)
 (ret.const.unspec))
((close
   (2 0 . flatten-top-level-begin)
   (extend.enclose
     (1 0)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 158741)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of denote-begin?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 159777)
     (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 159758))
   (touch.gloc.of annotate)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 164879))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 165909)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 166939)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 166933))
         (push)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 165903))
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 168981)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 170011)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 170005))
       (ret.cons "./boot/macro/expand.scm" . 168975))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 162822))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 156677))
 (set.gloc.of flatten-top-level-begin)
 (ret.const.unspec))
((close
   (3 0 . compile-macro)
   (extend.unbound . 2)
   (push.close
     (2 0)
     (push.const . \x2E;transformer-thunk)
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (call
             (touch.gloc.of make-out-of-context)
             (push.const . #f)
             (apply.gloc.of make-out-of-context "./boot/macro/expand.scm" . 179255))
           (push)
           (extend . 2)
           (call
             (push.close
               (1 0)
               (car.iloc (0 . 0) "./boot/macro/expand.scm" . 181292)
               (if.not.symbol?.ret.const . #f)
               (call
                 (touch.gloc.of renamed-id?)
                 (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 182320)
                 (apply.gloc.of renamed-id? "./boot/macro/expand.scm" . 182307))
               (if.false.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 183358)
               (push.const . #f)
               (subr.gloc.of core-hashtable-ref 3 "./boot/macro/expand.scm" . 183335)
               (if.true.ret)
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 184383)
               (push.iloc.1 . 1)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/expand.scm" . 184359))
             (push.iloc.1 . 1)
             (apply.gloc.of for-each "./boot/macro/expand.scm" . 180242))
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable->alist "./boot/macro/expand.scm" . 186386))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 187462))
       (push)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 187437))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/expand.scm" . 187409)
     (extend . 1)
     (call
       (touch.gloc.of interpret-coreform)
       (push.iloc.0 . 0)
       (apply.gloc.of interpret-coreform "./boot/macro/expand.scm" . 188441))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 189462)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 189480))
     (call
       (touch.gloc.of variable-transformer-token?)
       (push.iloc.0 . 0)
       (apply.gloc.of variable-transformer-token? "./boot/macro/expand.scm" . 190486))
     (if.true
       (call
         (touch.gloc.of make-macro-variable)
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of tuple-ref 2 "./boot/macro/expand.scm" . 191539)
         (push.iloc 2 . 1)
         (apply.gloc.of make-macro-variable "./boot/macro/expand.scm" . 191518))
       (push)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/macro/expand.scm" . 191510))
     (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 193576)
     (push.const . "invalid transformer expression")
     (push.iloc 4 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 193558))
   (push.close
     (1 0)
     (touch.gloc.of denote-syntax-rules?)
     (push.iloc 2 . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-syntax-rules? "./boot/macro/expand.scm" . 197641))
   (enclose . 2)
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (if.not.null?.ret.const . #f)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 176133))
   (if.true
     (push.const . syntax-rules)
     (push.const . "expected literals and rules")
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
   (call
     (iloc.1 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 176133)
     (if.false.ret)
     (push.car.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (apply.iloc (0 . 1) "./boot/macro/expand.scm" . 176133))
   (if.true
     (push.cddr.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (push.cadr.iloc (1 . 1) "./boot/macro/expand.scm" . 176133)
     (extend . 2)
     (call
       (call
         (push.iloc.0 . 1)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 176133)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 1)
         (apply.gloc.of every1 "./boot/macro/expand.scm" . 176133))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "invalid literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 1)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 176133))
       (if.true.ret)
       (push.const . syntax-rules)
       (push.const . "duplicate literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
     (call
       (push.const . _)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 176133)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "_ in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
     (call
       (push.const . ...)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 176133)
       (if.false.ret)
       (push.const . syntax-rules)
       (push.const . "... in literals")
       (push.iloc 2 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/expand.scm" . 176133)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 176133)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 176133)
           (ret.null? "./boot/macro/expand.scm" . 176133))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 176133)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 176133))
         (if.true.ret.const . #t)
         (iloc.0 . 0)
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected identifer for first subform of pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 176133)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/expand.scm" . 176133)
           (ret.null? "./boot/macro/expand.scm" . 176133))
         (if.true
           (push.const . syntax-rules)
           (push.const . "expected list for pattern")
           (push.iloc 4 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
         (push.const . syntax-rules)
         (push.const . "expected (pattern template) for each rule")
         (push.iloc 4 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 176133))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/expand.scm" . 176133))
     (touch.gloc.of compile-syntax-rules)
     (push.iloc 2 . 1)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 2 . 2)
     (apply.gloc.of compile-syntax-rules "./boot/macro/expand.scm" . 176133))
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 176133))
 (set.gloc.of compile-macro)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 237623))
   (ret.cons "./boot/macro/expand.scm" . 237611))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (3 0 . expand-let-syntax-bindings)
   (call
     (push.gloc.of car)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 229393))
   (push)
   (extend . 1)
   (touch.gloc.of extend-env)
   (call
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 233526))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 234534))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 3 . 2)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 235563))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 232475))
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 230418))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 232456))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn1.1\x60;1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 237586))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 238610))
     (push)
     (ret.subr.gloc.of append "./boot/macro/expand.scm" . 237578))
   (push)
   (push.iloc.1 . 2)
   (apply.gloc.of extend-env "./boot/macro/expand.scm" . 229381))
 (set.gloc.of expand-let-syntax-bindings)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-local-macro-symbol)
     (push.iloc.0 . 1)
     (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 253010))
   (ret.cons "./boot/macro/expand.scm" . 252990))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (3 0 . expand-letrec-syntax-bindings)
   (extend.enclose
     (1 0)
     (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 246811)
     (push.const . "attempt to reference uninitialized syntactic keyword")
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 246793))
   (call
     (push.gloc.of car)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 248849))
   (push)
   (call
     (push.gloc.of cadr)
     (push.iloc.1 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 249874))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of make-macro)
       (push.iloc 2 . 0)
       (push.const)
       (apply.gloc.of make-macro "./boot/macro/expand.scm" . 250929))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/expand.scm" . 250909))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 252957))
     (push)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 253981))
     (push)
     (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 252949)
     (push.iloc 3 . 2)
     (apply.gloc.of extend-env "./boot/macro/expand.scm" . 251924))
   (push)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 261173))
       (push)
       (push.cdr.iloc (0 . 1) "./boot/macro/expand.scm" . 261194)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 261163))
     (push.iloc 2 . 0)
     (call
       (push.close
         (1 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 6 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 257081))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 258089))
           (if.true (ret.iloc 0 . 0))
           (touch.gloc.of make-macro)
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (apply.gloc.of make-macro "./boot/macro/expand.scm" . 259118))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 256030))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 256011))
     (push)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 261133))
   (ret.iloc 0 . 0))
 (set.gloc.of expand-letrec-syntax-bindings)
 (ret.const.unspec))
((close
   (3 0 . expand-macro-use)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 267269))
   (call
     (touch.gloc.of current-macro-expression)
     (push.iloc.0 . 0)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 268293))
   (push.const . #f)
   (push.const . #f)
   (push.cddr.iloc (0 . 2) "./boot/macro/expand.scm" . 269401)
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 270343))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-transformer-environment)
       (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 270343))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 270343))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 2)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 270343))
   (push.close
     (0 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 270359)
     (subr.gloc.of procedure? 1 "./boot/macro/expand.scm" . 270347)
     (if.true (push.iloc 2 . 0) (cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 271372) (apply))
     (touch.gloc.of transcribe-syntax-rules)
     (push.iloc 2 . 0)
     (push.cadr.iloc (2 . 2) "./boot/macro/expand.scm" . 272425)
     (apply.gloc.of transcribe-syntax-rules "./boot/macro/expand.scm" . 272395))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-expansion-environment)
       (push.iloc.1 . 0)
       (apply.gloc.of current-expansion-environment "./boot/macro/expand.scm" . 270343))
     (touch.gloc.of current-transformer-environment)
     (push.iloc.1 . 1)
     (apply.gloc.of current-transformer-environment "./boot/macro/expand.scm" . 270343))
   (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 270343))
 (set.gloc.of expand-macro-use)
 (ret.const.unspec))
((close
   (2 0)
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 291863)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 291856))
     (ret.iloc 1 . 0))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 294928)
   (if.true
     (touch.gloc.of annotate)
     (call
       (touch.gloc.of rewrite-form-each\x60;2)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form-each\x60;2 "./boot/macro/expand.scm" . 295962))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 295952))
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 298020)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 298006))
     (push)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 298052)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 298038))
     (ret.cons "./boot/macro/expand.scm" . 298000))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/expand.scm" . 299024)
   (if.true
     (call
       (touch.gloc.of rewrite-form-each\x60;2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/expand.scm" . 300081)
       (push.iloc.0 . 1)
       (apply.gloc.of rewrite-form-each\x60;2 "./boot/macro/expand.scm" . 300062))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/expand.scm" . 300048))
   (ret.iloc 0 . 0))
 (set.gloc.of rewrite-form\x60;2)
 (close
   (2 0)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
     (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 320521)
     (if.false.ret)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 320521))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 320521))
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 320521))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 320521))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 320521))
         (ret.cons "./boot/macro/expand.scm" . 320521))
       (call
         (push.gloc.of car)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 320521))
       (push)
       (apply.gloc.of map "./boot/macro/expand.scm" . 320521))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (touch.gloc.of rewrite-form\x60;2)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 320521))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/expand.scm" . 320521))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 320521))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 320521))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 320521)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 320521))
 (set.gloc.of rewrite-letrec-syntax\x60;2)
 (close
   (2 0)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 305161)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 305161)
     (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 305161))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 305161)
     (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 305161)
     (extend . 2)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/expand.scm" . 305161))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 305161))
     (push)
     (call
       (push.gloc.of cadr)
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 305161))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 305161))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/expand.scm" . 305161))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/expand.scm" . 305161))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of list)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 305161))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/expand.scm" . 305161))
     (push)
     (extend . 1)
     (push.const . begin)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.iloc 3 . 0)
       (call
         (push.gloc.of cons)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/expand.scm" . 305161))
       (push)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 305161))
     (push.cons)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 305161))
   (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 305161)
   (push.const . "missing clause")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 305161))
 (set.gloc.of rewrite-let-syntax\x60;2)
 (close
   (2 0)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (touch.gloc.of rewrite-form\x60;2)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 282666)
       (push.iloc 2 . 1)
       (apply.gloc.of rewrite-form\x60;2 "./boot/macro/expand.scm" . 282652))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 283682)
       (apply.iloc+ (1 . 0) "./boot/macro/expand.scm" . 283676))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/expand.scm" . 284709)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 284728)
       (ret.eq? "./boot/macro/expand.scm" . 284720))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/expand.scm" . 286744))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/expand.scm" . 279561))
 (set.gloc.of rewrite-form-each\x60;2)
 (close
   (2 0 . expand-initial-forms)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 332839)
     (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 332830))
   (if.true
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 333864)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 333848))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (gloc.of denote-let-syntax)
     (if.eq?
       (touch.gloc.of rewrite-let-syntax\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rewrite-let-syntax\x60;2 "./boot/macro/expand.scm" . 335893))
     (push.iloc.0 . 0)
     (gloc.of denote-letrec-syntax)
     (if.eq?
       (touch.gloc.of rewrite-letrec-syntax\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rewrite-letrec-syntax\x60;2 "./boot/macro/expand.scm" . 337941))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 338965))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 340018))
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 341028))
         (push)
         (ret.subr.gloc.of values "./boot/macro/expand.scm" . 341015))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 333836))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of values "./boot/macro/expand.scm" . 343061))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of values "./boot/macro/expand.scm" . 345100))
 (set.gloc.of expand-initial-forms)
 (ret.const.unspec))
((close
   (3 0 . expand-body)
   (extend.unbound . 6)
   (push.const)
   (push.const)
   (push.const)
   (push.close
     (2 0)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 356383)
       (push.iloc 2 . 2)
       (apply.gloc.of extend-env "./boot/macro/expand.scm" . 356371))
     (set.iloc 2 . 2)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 357390))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/expand.scm" . 359457))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 1)
         (call
           (touch.gloc.of generate-local-macro-symbol)
           (push.iloc.0 . 0)
           (apply.gloc.of generate-local-macro-symbol "./boot/macro/expand.scm" . 360505))
         (push.cons)
         (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 360486)
         (push.iloc 2 . 2)
         (apply.gloc.of extend-env "./boot/macro/expand.scm" . 360474))
       (set.iloc 2 . 2)
       (ret.const.unspec))
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/expand.scm" . 361513)
       (push.iloc 3 . 2)
       (ret.subr.gloc.of set-cdr! "./boot/macro/expand.scm" . 361503))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/expand.scm" . 361481))
   (push.close
     (1 0)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 366613)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/expand.scm" . 367639)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 368682)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 368666))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 369684))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/expand.scm" . 373780))
   (push.close
     (3 0)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (iloc.0 . 1)
     (if.null?
       (touch.gloc.of annotate)
       (call
         (touch.gloc.of expand-each)
         (push.iloc.0 . 0)
         (push.iloc 2 . 2)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 379930))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of annotate "./boot/macro/expand.scm" . 379920))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 381989))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/expand.scm" . 381972))
       (if.true.ret)
       (call
         (touch.gloc.of find-duplicates)
         (call
           (push.gloc.of car)
           (push.iloc.0 . 2)
           (apply.gloc.of map "./boot/macro/expand.scm" . 383023))
         (push)
         (apply.gloc.of find-duplicates "./boot/macro/expand.scm" . 383006))
       (push)
       (extend . 1)
       (push.const . define)
       (push.const . "duplicate definitions")
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 386097)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 386114))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 387130)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 387121)
         (extend . 1)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 387148))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 384022))
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 388153)
         (push.iloc.1 . 2)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 388147)
         (ret.subr.gloc.of cdr "./boot/macro/expand.scm" . 388142))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 388123))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/expand.scm" . 389179)
         (push.iloc 3 . 2)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 389166))
       (push.iloc.0 . 1)
       (apply.gloc.of map "./boot/macro/expand.scm" . 389147))
     (push)
     (extend . 2)
     (call
       (touch.gloc.of check-rec*-contract-violation)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-rec*-contract-violation "./boot/macro/expand.scm" . 390169))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 392260)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 392268)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of car "./boot/macro/expand.scm" . 392279))
         (push.iloc 2 . 2)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 392232))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 393248))
       (push.const . define)
       (push.const . "attempt to reference uninitialized variable ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 395314)
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of check-rec-contract-violation)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 397405)
             (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 397415)
             (apply.gloc.of check-rec-contract-violation "./boot/macro/expand.scm" . 397375))
           (if.false.ret)
           (touch.gloc.of annotate)
           (push.const . define)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 0)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 398399))
         (push.iloc 3 . 1)
         (apply.gloc.of any1 "./boot/macro/expand.scm" . 396338))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 394272))
     (call
       (touch.gloc.of check-internal-def-contract-violation)
       (call
         (push.gloc.of car)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 400448))
       (push)
       (push.iloc 3 . 1)
       (apply.gloc.of check-internal-def-contract-violation "./boot/macro/expand.scm" . 400409))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc 5 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 402462))
       (push.const . define)
       (push.const
         .
         "identifier ~u already used to determine the meaning of undeferred portions of definition")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 404528)
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.subr.gloc.of assq 2 "./boot/macro/expand.scm" . 405559)
         (extend . 1)
         (iloc.0 . 0)
         (if.false.ret)
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/expand.scm" . 405589))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 390162))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of map "./boot/macro/expand.scm" . 409664))
       (push)
       (push.iloc 5 . 2)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/expand.scm" . 409638))
     (push)
     (call
       (touch.gloc.of expand-each)
       (push.iloc 3 . 0)
       (push.iloc 5 . 2)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 409690))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/expand.scm" . 408601)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/expand.scm" . 408601)
     (push.iloc 5 . 1)
     (apply.gloc.of annotate "./boot/macro/expand.scm" . 408601))
   (enclose . 6)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/expand.scm" . 412691))
   (push)
   (extend . 1)
   (extend.enclose
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (car.iloc (0 . 0) "./boot/macro/expand.scm" . 415772)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 415793)
       (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 415784))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 416808)
       (push.iloc 3 . 2)
       (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 416802)
       (set.iloc 3 . 2)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 4 . 2)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 417836)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 417820))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 419871))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/macro/expand.scm" . 419865))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/expand.scm" . 421913)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdar 1 "./boot/macro/expand.scm" . 421913)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cddar 1 "./boot/macro/expand.scm" . 421913)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdddar 1 "./boot/macro/expand.scm" . 421913)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/expand.scm" . 421913)
           (ret.subr.gloc.of list? "./boot/macro/expand.scm" . 421913))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/expand.scm" . 421913)
           (ret.subr.gloc.of symbol? "./boot/macro/expand.scm" . 421913))
         (if.true
           (push.cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 421913)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddar 1 "./boot/macro/expand.scm" . 421913)
           (push.iloc 2 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/expand.scm" . 421913)
           (extend . 3)
           (call
             (push.close
               (0 0)
               (touch.gloc.of compile-macro)
               (push.car.iloc (4 . 0) "./boot/macro/expand.scm" . 421913)
               (push.iloc.1 . 1)
               (push.iloc 8 . 2)
               (apply.gloc.of compile-macro "./boot/macro/expand.scm" . 421913))
             (push.close
               (1 1)
               (call
                 (iloc.0 . 1)
                 (if.not.pair?.ret.const . #f)
                 (push.car.iloc (0 . 1) "./boot/macro/expand.scm" . 421913)
                 (push.iloc 7 . 1)
                 (subr.gloc.of cons 2 "./boot/macro/expand.scm" . 421913)
                 (set.iloc 7 . 1)
                 (ret.const.unspec))
               (call
                 (touch.gloc.of macro-variable?)
                 (push.iloc.0 . 0)
                 (apply.gloc.of macro-variable? "./boot/macro/expand.scm" . 421913))
               (if.true
                 (push.iloc.1 . 2)
                 (push.iloc.0 . 0)
                 (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 421913))
               (push.iloc.1 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.0 . 0)
                 (push.iloc 8 . 2)
                 (apply.gloc.of make-macro "./boot/macro/expand.scm" . 421913))
               (push)
               (apply.iloc (7 . 3) "./boot/macro/expand.scm" . 421913))
             (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 421913))
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (call
             (touch.gloc.of acons)
             (push.iloc.0 . 2)
             (push.const . #f)
             (push.iloc 3 . 2)
             (apply.gloc.of acons "./boot/macro/expand.scm" . 421913))
           (push)
           (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 421913))
         (iloc.0 . 0)
         (if.true
           (push.iloc 2 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 421913)
           (push.const . "expected symbol for first clause")
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 421913)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 421913))
         (push.iloc 2 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/expand.scm" . 421913)
         (push.const . "expected symbol and transformer expression")
         (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 421913)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 421913))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 437315)
             (apply.gloc.of desugar-define "./boot/macro/expand.scm" . 437299))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/expand.scm" . 437294)
           (push.car.iloc (1 . 0) "./boot/macro/expand.scm" . 437328)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 437284))
         (push)
         (extend . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 438310)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 438337)
           (push.iloc 4 . 0)
           (apply.gloc.of rename-id "./boot/macro/expand.scm" . 438326))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 2)
           (subr.gloc.of memq 2 "./boot/macro/expand.scm" . 439332)
           (if.true
             (call
               (touch.gloc.of current-macro-expression)
               (push.iloc 7 . 0)
               (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 441385))
             (push.const . define)
             (push.const
               .
               "identifier ~u already used to determine the meaning of undeferred portions of definition")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 443451)
             (push.car.iloc (3 . 0) "./boot/macro/expand.scm" . 444475)
             (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 442409))
           (ret.const.unspec))
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (6 . 3) "./boot/macro/expand.scm" . 445469))
         (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 446499)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of acons "./boot/macro/expand.scm" . 446526))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 446493))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/expand.scm" . 447517))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/expand.scm" . 449565))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/expand.scm" . 450632)
           (push.iloc 6 . 2)
           (apply.gloc.of expand-initial-forms "./boot/macro/expand.scm" . 450610))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 6 . 2)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/expand.scm" . 452667)
             (push.iloc 6 . 2)
             (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 452652))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 454698)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 454692))
           (call (push.iloc.0 . 0) (apply.iloc (6 . 4) "./boot/macro/expand.scm" . 455716))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 456764)
             (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 456746)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (apply.iloc (4 . 0) "./boot/macro/expand.scm" . 456740))
           (push.iloc.0 . 0)
           (push.cdr.iloc (3 . 0) "./boot/macro/expand.scm" . 458820)
           (push.subr.gloc.of append 2 "./boot/macro/expand.scm" . 458802)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 458832)
           (push.iloc 3 . 2)
           (apply.iloc (6 . 5) "./boot/macro/expand.scm" . 458788))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 417808))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 460844)
       (push.iloc.1 . 2)
       (apply.iloc (4 . 5) "./boot/macro/expand.scm" . 460825))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/expand.scm" . 462883)
     (push.iloc.0 . 2)
     (apply.iloc (3 . 5) "./boot/macro/expand.scm" . 462864))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of flatten-begin "./boot/macro/expand.scm" . 413720))
   (push)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/expand.scm" . 413703))
 (set.gloc.of expand-body)
 (ret.const.unspec))
((close
   (2 0 . expand-each)
   (call
     (touch.gloc.of current-macro-expression)
     (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 466961))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (call
     (push.close
       (1 0)
       (call
         (touch.gloc.of current-macro-expression)
         (push.iloc.1 . 0)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 469016))
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 470040))
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/expand.scm" . 467985))
   (push)
   (push.iloc.1 . 0)
   (apply.gloc.of annotate "./boot/macro/expand.scm" . 467975))
 (set.gloc.of expand-each)
 (ret.const.unspec))
((close
   (2 0 . expand-form)
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 477208))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.symbol? (ret.iloc 0 . 0))
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/expand.scm" . 479253))
     (if.true
       (push.close
         (0 0)
         (call
           (touch.gloc.of expansion-trace-level)
           (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 481322))
         (push)
         (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 481346))
         (push)
         (subr.gloc.of < 2 "./boot/macro/expand.scm" . 481319)
         (if.true
           (push.const . #f)
           (push.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 482387))
           (push)
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 482414))
           (push.cons)
           (push.const . 1)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 483410))
           (push)
           (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 483405)
           (extend . 4)
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 484393))
             (set.iloc 1 . 0)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 484393))
             (set.iloc 1 . 1)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 2)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 484393))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 3)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 484393))
           (push.close
             (0 0)
             (touch.gloc.of expand-macro-use)
             (push.iloc 4 . 0)
             (push.iloc 4 . 1)
             (push.iloc 3 . 0)
             (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 484393))
           (push.close
             (0 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (push.iloc.1 . 0)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 484393))
             (touch.gloc.of expansion-trace-level)
             (push.iloc.1 . 1)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 484393))
           (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 484393))
         (touch.gloc.of expand-macro-use)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 485415))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 2 . 1)
           (apply.gloc.of extend-env "./boot/macro/expand.scm" . 486441))
         (push)
         (apply.gloc.of expand-form "./boot/macro/expand.scm" . 486423))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 477196))
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/expand.scm" . 487445))
     (if.true
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound identifier ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 489521)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 490545))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/expand.scm" . 488469))
     (call
       (touch.gloc.of out-of-context?)
       (push.iloc.0 . 0)
       (apply.gloc.of out-of-context? "./boot/macro/expand.scm" . 491541))
     (if.true
       (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 492569)
       (if.true
         (push.const . #f)
         (push.const . "identifer ~u out of context")
         (push.iloc.1 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 494635)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 495659))
         (push)
         (call
           (touch.gloc.of annotate)
           (push.const . syntax)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 496707)
           (push.subr.gloc.of list 2 "./boot/macro/expand.scm" . 496693)
           (push.cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 496719)
           (apply.gloc.of annotate "./boot/macro/expand.scm" . 496683))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 493593))
       (push.const . #f)
       (push.const . "identifer ~u out of context")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 498731)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 499755))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 497689))
     (call
       (touch.gloc.of special?)
       (push.iloc.0 . 0)
       (apply.gloc.of special? "./boot/macro/expand.scm" . 500757))
     (if.true
       (push.const . #f)
       (push.const . "misplaced syntactic keyword ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 501802)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 501849))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 501781))
     (call
       (touch.gloc.of pattern-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of pattern-variable? "./boot/macro/expand.scm" . 502805))
     (if.true
       (push.const . #f)
       (push.const . "misplaced pattern variable ~u")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/expand.scm" . 503850)
       (call
         (touch.gloc.of current-macro-expression)
         (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 503896))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 503829))
     (ret.iloc 1 . 0))
   (iloc.0 . 0)
   (if.null?
     (push.const . #f)
     (push.const . "invalid expression")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 506892))
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.0 . 0)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 508940))
     (car.iloc (0 . 0) "./boot/macro/expand.scm" . 509980)
     (if.symbol?
       (call
         (touch.gloc.of env-lookup)
         (push.iloc.0 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/expand.scm" . 511023)
         (apply.gloc.of env-lookup "./boot/macro/expand.scm" . 511007))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/expand.scm" . 512028))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-macro-use)
           (push.iloc 2 . 0)
           (push.iloc 2 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of expand-macro-use "./boot/macro/expand.scm" . 513081))
         (push.close
           (2 0)
           (call
             (touch.gloc.of expansion-trace-level)
             (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 514085))
           (push)
           (call (apply.gloc.of expansion-backtrace "./boot/macro/expand.scm" . 514109))
           (push)
           (subr.gloc.of < 2 "./boot/macro/expand.scm" . 514082)
           (if.true
             (push.const . #f)
             (push.const . #f)
             (push.iloc 2 . 0)
             (call
               (touch.gloc.of expansion-trace-stack)
               (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 515155))
             (push.cons)
             (push.const . 1)
             (call
               (touch.gloc.of expansion-trace-level)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 516173))
             (push)
             (push.subr.gloc.of + 2 "./boot/macro/expand.scm" . 516168)
             (extend . 4)
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 517156))
               (set.iloc 1 . 0)
               (call
                 (touch.gloc.of expansion-trace-level)
                 (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 517156))
               (set.iloc 1 . 1)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 2)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 517156))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 3)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 517156))
             (push.close
               (0 0)
               (touch.gloc.of expand-form)
               (push.iloc 2 . 0)
               (call
                 (touch.gloc.of extend-env)
                 (push.iloc 2 . 1)
                 (push.iloc 4 . 1)
                 (apply.gloc.of extend-env "./boot/macro/expand.scm" . 517174))
               (push)
               (apply.gloc.of expand-form "./boot/macro/expand.scm" . 517156))
             (push.close
               (0 0)
               (call
                 (touch.gloc.of expansion-trace-stack)
                 (push.iloc.1 . 0)
                 (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 517156))
               (touch.gloc.of expansion-trace-level)
               (push.iloc.1 . 1)
               (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 517156))
             (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 517156))
           (touch.gloc.of expand-form)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of extend-env)
             (push.iloc.0 . 1)
             (push.iloc 2 . 1)
             (apply.gloc.of extend-env "./boot/macro/expand.scm" . 518196))
           (push)
           (apply.gloc.of expand-form "./boot/macro/expand.scm" . 518178))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/expand.scm" . 510995))
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/expand.scm" . 519196))
       (if.true
         (call
           (push.iloc.1 . 0)
           (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 520224)
           (if.true.ret)
           (push.const . #f)
           (push.const . "expression is not a proper list")
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 520237))
         (call
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 521252))
           (if.true.ret)
           (push.gloc.of denote-begin)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-import)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-macro)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-define-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-let-syntax)
           (iloc.0 . 0)
           (if.eq?.ret.const . #t)
           (push.gloc.of denote-letrec-syntax)
           (iloc.0 . 0)
           (ret.eq? "./boot/macro/expand.scm" . 528420))
         (if.true
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 529441)
           (apply))
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call
             (touch.gloc.of unexpect-top-level-form)
             (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
           (set.iloc 1 . 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.const . #t)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
         (push.close
           (0 0)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (cdr.iloc (2 . 0) "./boot/macro/expand.scm" . 531491)
           (apply))
         (push.close
           (0 0)
           (touch.gloc.of unexpect-top-level-form)
           (push.iloc.1 . 0)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 531490))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 531490))
       (call
         (push.iloc.1 . 0)
         (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 533536)
         (if.true.ret)
         (push.const . #f)
         (push.const . "expression is not a proper list")
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 533549))
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 534560))
       (if.true
         (touch.gloc.of expand-each)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 535584))
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537634))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537634))
       (push.close
         (0 0)
         (touch.gloc.of expand-each)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-each "./boot/macro/expand.scm" . 537634))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 537634))
       (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 537634))
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/expand.scm" . 539671)
       (if.true.ret)
       (push.const . #f)
       (push.const . "expression is not a proper list")
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 539684))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 540695))
     (if.true
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 541719))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 543769))
       (set.iloc 1 . 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #t)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 543769))
     (push.close
       (0 0)
       (touch.gloc.of expand-each)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-each "./boot/macro/expand.scm" . 543769))
     (push.close
       (0 0)
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 0)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 543769))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 543769))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/expand.scm" . 544784)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/expand.scm" . 544800)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/expand.scm" . 544815)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/expand.scm" . 544828)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of bytevector? "./boot/macro/expand.scm" . 544843))
   (if.true (ret.iloc 0 . 0))
   (push.const . #f)
   (push.const . "invalid expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/expand.scm" . 546828))
 (set.gloc.of expand-form)
 (ret.const.unspec))
((close
   (1 1 . macro-expand)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const)
   (extend . 9)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-rename-count)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of current-macro-expression)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 2)
     (call
       (touch.gloc.of current-expansion-mode)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 3)
     (call
       (touch.gloc.of current-top-level-exterior)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 4)
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 5)
     (call
       (touch.gloc.of expansion-trace-level)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 6)
     (call
       (touch.gloc.of expansion-trace-stack)
       (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 559111))
     (set.iloc 1 . 7)
     (call
       (touch.gloc.of current-temporary-count)
       (push.const . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-rename-count)
       (push.const . 0)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-macro-expression)
       (push.const . #f)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc 2 . 1)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.const . #f)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.const . #f)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.const . 0)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 559111))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 8)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 559111))
   (push.close
     (0 0)
     (call
       (call
         (touch.gloc.of denote-begin?)
         (push.const)
         (push.const . begin)
         (apply.gloc.of denote-begin? "./boot/macro/expand.scm" . 559127))
       (if.true
         (touch.gloc.of flatten-top-level-begin)
         (push.const . begin)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/expand.scm" . 560151)
         (push.gloc.of private-primitives-environment)
         (apply.gloc.of flatten-top-level-begin "./boot/macro/expand.scm" . 560151))
       (ret.iloc 2 . 0))
     (push)
     (extend . 1)
     (cdr.iloc (0 . 0) "./boot/macro/expand.scm" . 562196)
     (if.null? (ret.const.unspec))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.0 . 0)
       (push.gloc.of private-primitives-environment)
       (apply.gloc.of expand-form "./boot/macro/expand.scm" . 564269))
     (push)
     (push.gloc.of annotate)
     (push.gloc.of annotate-closure)
     (call (apply.gloc.of current-after-expansion-hook "./boot/macro/expand.scm" . 564238))
     (apply))
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-temporary-count)
       (push.iloc.1 . 0)
       (apply.gloc.of current-temporary-count "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-rename-count)
       (push.iloc.1 . 1)
       (apply.gloc.of current-rename-count "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-macro-expression)
       (push.iloc.1 . 2)
       (apply.gloc.of current-macro-expression "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-expansion-mode)
       (push.iloc.1 . 3)
       (apply.gloc.of current-expansion-mode "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 4)
       (apply.gloc.of current-top-level-exterior "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of unexpect-top-level-form)
       (push.iloc.1 . 5)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/expand.scm" . 559111))
     (call
       (touch.gloc.of expansion-trace-level)
       (push.iloc.1 . 6)
       (apply.gloc.of expansion-trace-level "./boot/macro/expand.scm" . 559111))
     (touch.gloc.of expansion-trace-stack)
     (push.iloc.1 . 7)
     (apply.gloc.of expansion-trace-stack "./boot/macro/expand.scm" . 559111))
   (apply.gloc.of \x2E;dynamic-wind "./boot/macro/expand.scm" . 558100))
 (set.gloc.of macro-expand)
 (ret.const.unspec))

;
((close
   (2 0 . expand-lambda)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 7183))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/base.scm" . 7180)
   (if.true
     (call
       (touch.gloc.of collect-lambda-formals)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 8240)
       (push.iloc.0 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/base.scm" . 8216))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 9245))
     (push)
     (extend . 1)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (touch.gloc.of rename-id)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of rename-id "./boot/macro/base.scm" . 10303))
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/macro/base.scm" . 10285))
       (push)
       (apply.gloc.of map "./boot/macro/base.scm" . 10270))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 3 . 0)
       (push.cddr.iloc (3 . 0) "./boot/macro/base.scm" . 11309)
       (call
         (touch.gloc.of extend-env)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of extend-env "./boot/macro/base.scm" . 11321))
       (push)
       (apply.gloc.of expand-body "./boot/macro/base.scm" . 11291))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.const . lambda)
       (push.const . "empty body")
       (push.iloc 4 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 13332))
     (touch.gloc.of annotate)
     (push.const . lambda)
     (call
       (touch.gloc.of rename-lambda-formals)
       (push.cadr.iloc (4 . 0) "./boot/macro/base.scm" . 14399)
       (push.iloc.1 . 0)
       (apply.gloc.of rename-lambda-formals "./boot/macro/base.scm" . 14376))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/base.scm" . 14356)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 14356))
   (push.const . lambda)
   (push.const . "expected formals and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 16396))
 (set.gloc.of expand-lambda)
 (ret.const.unspec))
((close
   (2 0 . expand-quote)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/base.scm" . 20492))
   (push)
   (push.const . 2)
   (subr.gloc.of = 2 "./boot/macro/base.scm" . 20489)
   (if.true
     (touch.gloc.of annotate)
     (push.const . quote)
     (call
       (touch.gloc.of strip-rename-suffix)
       (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 21553)
       (apply.gloc.of strip-rename-suffix "./boot/macro/base.scm" . 21532))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/base.scm" . 21513)
     (push.iloc.0 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 21513))
   (push.const . quote)
   (push.const . "expected single datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 22537))
 (set.gloc.of expand-quote)
 (ret.const.unspec))
((close
   (2 0 . expand-begin)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 26634))
     (if.false.ret)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 27669)
     (if.pair?.ret.const . #t)
     (push.const . begin)
     (push.const . "misplaced empty begin")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 28686))
   (touch.gloc.of annotate)
   (push.const . begin)
   (call
     (touch.gloc.of flatten-begin)
     (call
       (touch.gloc.of expand-each)
       (push.cdr.iloc (0 . 0) "./boot/macro/base.scm" . 29749)
       (push.iloc.0 . 1)
       (apply.gloc.of expand-each "./boot/macro/base.scm" . 29736))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of flatten-begin "./boot/macro/base.scm" . 29721))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 29701))
 (set.gloc.of expand-begin)
 (ret.const.unspec))
((close
   (2 0 . expand-if)
   (touch.gloc.of annotate)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 33797)
       (ret.pair? "./boot/macro/base.scm" . 33797))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 33797)
       (extend . 1)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of \x2E;list "./boot/macro/base.scm" . 33797))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 33797)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of cddddr 1 "./boot/macro/base.scm" . 33797)
       (ret.null? "./boot/macro/base.scm" . 33797))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadddr 1 "./boot/macro/base.scm" . 33797)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 33797)
       (extend . 2)
       (push.const . if)
       (call
         (touch.gloc.of expand-form)
         (push.cadr.iloc (2 . 0) "./boot/macro/base.scm" . 33797)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 1)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (call
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 33797))
       (push)
       (ret.subr.gloc.of \x2E;list "./boot/macro/base.scm" . 33797))
     (push.const . if)
     (push.const . "expected 2 or 3 expressions")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 33797))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 32771))
 (set.gloc.of expand-if)
 (ret.const.unspec))
((close
   (2 0 . expand-set!)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 48133)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 48133))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 48133)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
     (extend . 2)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro-variable?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of expand-macro-use)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of expand-macro-use "./boot/macro/base.scm" . 48133))
       (push.close
         (2 0)
         (touch.gloc.of expand-form)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of extend-env)
           (push.iloc.0 . 1)
           (push.iloc 3 . 1)
           (apply.gloc.of extend-env "./boot/macro/base.scm" . 48133))
         (push)
         (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/base.scm" . 48133))
       (if.true.ret)
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/base.scm" . 48133))
     (if.true
       (push.const . set!)
       (push.const . "misplaced syntactic keyword as variable")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (push.gloc.of immutable-primitives)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (call
         (touch.gloc.of renamed-id?)
         (push.iloc.0 . 0)
         (apply.gloc.of renamed-id? "./boot/macro/base.scm" . 48133))
       (if.true.ret.const . #f)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/base.scm" . 48133))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/macro/base.scm" . 48133)
       (if.false.ret)
       (push.const . set!)
       (push.const . "attempt to modify immutable variable")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
     (call
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 48133))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (call
         (touch.gloc.of denote-lambda?)
         (push.iloc 4 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 48133)
         (apply.gloc.of denote-lambda? "./boot/macro/base.scm" . 48133))
       (if.false.ret)
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 48133))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 48133))
     (touch.gloc.of annotate)
     (push.const . set!)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/base.scm" . 48133)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/base.scm" . 48133))
   (push.const . set!)
   (push.const . "expected variable and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 48133))
 (set.gloc.of expand-set!)
 (ret.const.unspec))
((close
   (2 0 . expand-let-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (ret.subr.gloc.of list? "./boot/macro/base.scm" . 74757))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 74757)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 74757))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 74757))
     (touch.gloc.of expand-form)
     (push.const . \x2E;BEGIN)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-let-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-let-syntax-bindings "./boot/macro/base.scm" . 74757))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 74757))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 74757)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 74757))
 (set.gloc.of expand-let-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (ret.subr.gloc.of list? "./boot/macro/base.scm" . 87045))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 87045)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/base.scm" . 87045))
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/base.scm" . 87045))
     (touch.gloc.of expand-form)
     (push.const . \x2E;BEGIN)
     (iloc.0 . 0)
     (push.cons)
     (call
       (touch.gloc.of expand-letrec-syntax-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-letrec-syntax-bindings "./boot/macro/base.scm" . 87045))
     (push)
     (apply.gloc.of expand-form "./boot/macro/base.scm" . 87045))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 87045)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 87045))
 (set.gloc.of expand-letrec-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-define-syntax)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99338))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 100380)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 100362))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 99333)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (ret.subr.gloc.of symbol? "./boot/macro/base.scm" . 99333))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 99333)
     (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
     (extend . 2)
     (call
       (push.const . #f)
       (extend . 1)
       (push.close
         (0 0)
         (call
           (touch.gloc.of unexpect-top-level-form)
           (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
         (set.iloc 1 . 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (push.close
           (0 0)
           (touch.gloc.of compile-macro)
           (push.iloc 4 . 0)
           (push.iloc 3 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-macro "./boot/macro/base.scm" . 99333))
         (push.close
           (1 1)
           (call
             (touch.gloc.of macro-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of macro-variable? "./boot/macro/base.scm" . 99333))
           (if.true
             (push.const . variable)
             (push.iloc 3 . 1)
             (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
             (push.iloc 4 . 1)
             (apply.gloc.of \x2E;set-top-level-macro! "./boot/macro/base.scm" . 99333))
           (push.const . syntax)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of \x2E;set-top-level-macro! "./boot/macro/base.scm" . 99333))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/base.scm" . 99333))
       (push.close
         (0 0)
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 99333))
       (apply.gloc.of \x2E;dynamic-wind "./boot/macro/base.scm" . 99333))
     (call
       (touch.gloc.of env-delete!)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (apply.gloc.of env-delete! "./boot/macro/base.scm" . 99333))
     (ret.const begin))
   (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 99333)
   (push.const . "expected symbol and single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 99333))
 (set.gloc.of expand-define-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/base.scm" . 119821)
   (if.true.ret)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (ret.subr.gloc.of memq "./boot/macro/base.scm" . 120845))
 (set.gloc.of immutable?\x60;2)
 (close
   (2 0 . expand-define)
   (extend.enclose
     (1 0)
     (touch.gloc.of denote-let?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-let? "./boot/macro/base.scm" . 131081))
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 133130))
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/base.scm" . 134172)
     (push.const . "misplaced definition")
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 134154))
   (call
     (touch.gloc.of desugar-define)
     (push.iloc.1 . 0)
     (apply.gloc.of desugar-define "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 135194)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 135194)
   (push.cadr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
   (extend . 2)
   (call
     (call
       (touch.gloc.of immutable?\x60;2)
       (push.iloc.0 . 1)
       (apply.gloc.of immutable?\x60;2 "./boot/macro/base.scm" . 135194))
     (if.false.ret)
     (push.car.iloc (3 . 0) "./boot/macro/base.scm" . 135194)
     (push.const . "attempt to modify immutable binding")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/base.scm" . 135194))
   (call
     (push.const . #f)
     (push.const . #f)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 0)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
       (set.iloc 1 . 1)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.const . #t)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc 2 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (touch.gloc.of expand-form)
       (push.iloc 2 . 0)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/base.scm" . 135194))
     (push.close
       (0 0)
       (call
         (touch.gloc.of unexpect-top-level-form)
         (push.iloc.1 . 0)
         (apply.gloc.of unexpect-top-level-form "./boot/macro/base.scm" . 135194))
       (touch.gloc.of current-top-level-exterior)
       (push.iloc.1 . 1)
       (apply.gloc.of current-top-level-exterior "./boot/macro/base.scm" . 135194))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/base.scm" . 135194))
   (push)
   (extend . 1)
   (call
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of cdddr 1 "./boot/macro/base.scm" . 135194)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/base.scm" . 135194)
       (apply.iloc (3 . 0) "./boot/macro/base.scm" . 135194))
     (if.true
       (touch.gloc.of set-closure-comment!)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/macro/base.scm" . 135194)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
       (push)
       (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of original-id)
       (push.iloc.1 . 1)
       (apply.gloc.of original-id "./boot/macro/base.scm" . 135194))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/base.scm" . 135194))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/base.scm" . 135194)
   (call
     (touch.gloc.of env-delete!)
     (push.iloc 4 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-delete! "./boot/macro/base.scm" . 135194))
   (touch.gloc.of annotate)
   (push.const . define)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/base.scm" . 135194)
   (push.iloc 4 . 0)
   (apply.gloc.of annotate "./boot/macro/base.scm" . 135194))
 (set.gloc.of expand-define)
 (ret.const.unspec))

;
((close
   (3 0 . annotate-bindings)
   (push.close
     (2 0)
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of denote-lambda?)
       (push.iloc.1 . 2)
       (push.car.iloc (0 . 1) "./boot/macro/derived.scm" . 9258)
       (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 9238))
     (if.false.ret)
     (touch.gloc.of set-closure-comment!)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of original-id)
       (push.iloc.0 . 0)
       (apply.gloc.of original-id "./boot/macro/derived.scm" . 10289))
     (push)
     (apply.gloc.of set-closure-comment! "./boot/macro/derived.scm" . 10262))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of for-each "./boot/macro/derived.scm" . 7173))
 (set.gloc.of annotate-bindings)
 (ret.const.unspec))
((close
   (3 0 . warning-contract-violation)
   (push.close
     (1 0)
     (touch.gloc.of display-warning)
     (push.const . "warning: binding construct may attempt to reference uninitialized variable ~u")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 18441)
     (push.iloc.1 . 0)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (call
           (touch.gloc.of check-rec-contract-violation)
           (push.iloc.1 . 0)
           (push.subr.gloc.of list 1 "./boot/macro/derived.scm" . 20542)
           (push.iloc.0 . 0)
           (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 20512))
         (if.false.ret)
         (ret.iloc 0 . 0))
       (push.iloc.1 . 1)
       (apply.gloc.of any1 "./boot/macro/derived.scm" . 20489))
     (push)
     (apply.gloc.of display-warning "./boot/macro/derived.scm" . 17416))
   (push.iloc.0 . 2)
   (apply.gloc.of for-each "./boot/macro/derived.scm" . 15365))
 (set.gloc.of warning-contract-violation)
 (ret.const.unspec))
((close
   (2 0 . expand-let)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 25605)
     (ret.pair? "./boot/macro/derived.scm" . 25605))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 25605)
     (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 25605)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 25605)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 25605))
   (if.true
     (push.iloc.1 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 25605)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 25605)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (extend . 3)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 25605))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 1)
       (push.const . \x2E;LETREC*)
       (push.iloc.0 . 2)
       (push.const . \x2E;LAMBDA)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 25605)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 25605)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 25605)
       (push.iloc.0 . 2)
       (call
         (push.gloc.of car)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
       (push.cons)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 25605)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 25605)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 25605))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 25605))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 25605))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 25605))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 25605)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 25605))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 25605)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 25605))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 25605))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
     (extend . 1)
     (call
       (touch.gloc.of check-let-bindings)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 25605))
     (call
       (push.gloc.of car)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
     (push)
     (call
       (push.close
         (1 0)
         (touch.gloc.of expand-form)
         (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 25605)
         (push.iloc 3 . 1)
         (apply.gloc.of expand-form "./boot/macro/derived.scm" . 25605))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
     (push)
     (call
       (touch.gloc.of fresh-rename-count)
       (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 25605))
     (push)
     (extend . 3)
     (call
       (push.close
         (1 0)
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.gloc.of rename-id "./boot/macro/derived.scm" . 25605))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of expand-body)
       (push.iloc 4 . 0)
       (push.cddr.iloc (4 . 0) "./boot/macro/derived.scm" . 25605)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of cons)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
         (push)
         (push.iloc 4 . 1)
         (apply.gloc.of extend-env "./boot/macro/derived.scm" . 25605))
       (push)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 25605))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 25605)
       (push.const . "empty body")
       (push.iloc 5 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 25605))
     (call
       (touch.gloc.of annotate-bindings)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of annotate-bindings "./boot/macro/derived.scm" . 25605))
     (touch.gloc.of annotate)
     (push.const . let)
     (call
       (push.gloc.of list)
       (push.iloc.1 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/derived.scm" . 25605))
     (push)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 25605)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 25605))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 25605)
   (push.const . "expected bindings and body")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 25605))
 (set.gloc.of expand-let)
 (ret.const.unspec))
((close
   (2 0 . expand-letrec*)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 58373)
     (ret.pair? "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 58373)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 58373)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 58373))
   (if.true
     (call
       (touch.gloc.of expand-body)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 58373)
       (push.iloc.1 . 1)
       (apply.gloc.of expand-body "./boot/macro/derived.scm" . 58373))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 58373)
       (push.const . "empty body")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 58373))
     (touch.gloc.of annotate)
     (push.const . let)
     (push.const)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 58373)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 58373))
   (iloc.0 . 0)
   (if.false.ret)
   (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 58373)
   (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 58373)
   (if.false.ret)
   (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 58373)
   (extend . 1)
   (call
     (touch.gloc.of check-let-bindings)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 58373))
   (call
     (push.gloc.of car)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
   (push)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of rename-id)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rename-id "./boot/macro/derived.scm" . 58373))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
     (push)
     (push.iloc 4 . 1)
     (apply.gloc.of extend-env "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (touch.gloc.of expand-form)
       (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 58373)
       (push.iloc.1 . 0)
       (apply.gloc.of expand-form "./boot/macro/derived.scm" . 58373))
     (push.iloc 3 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
   (push)
   (call
     (touch.gloc.of expand-body)
     (push.iloc 5 . 0)
     (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 58373)
     (push.iloc.0 . 0)
     (apply.gloc.of expand-body "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of annotate-bindings)
     (push.iloc 3 . 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate-bindings "./boot/macro/derived.scm" . 58373))
   (iloc.0 . 1)
   (if.null?
     (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 58373)
     (push.const . "empty body")
     (push.iloc 6 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 58373))
   (call
     (touch.gloc.of check-rec*-contract-violation)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of check-rec*-contract-violation "./boot/macro/derived.scm" . 58373))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (subr.gloc.of warning-level 0 "./boot/macro/derived.scm" . 58373)
       (if.false.ret)
       (touch.gloc.of warning-contract-violation)
       (push.iloc 7 . 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of warning-contract-violation "./boot/macro/derived.scm" . 58373))
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (push.gloc.of list)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
     (push)
     (push.iloc.1 . 1)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 58373)
     (push.iloc 7 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 58373))
   (touch.gloc.of annotate)
   (push.const . letrec*)
   (call
     (touch.gloc.of rewrite-letrec*-bindings)
     (call
       (push.gloc.of list)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 58373))
     (push)
     (push.iloc 2 . 0)
     (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 58373))
   (push)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 58373)
   (push.iloc 7 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 58373))
 (set.gloc.of expand-letrec*)
 (ret.const.unspec))
((close
   (2 0)
   (push.const . set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 83973))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . \x2E;&UNDEF)
   (ret.subr.gloc.of list "./boot/macro/derived.scm" . 83973))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . expand-letrec)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 83973)
     (ret.pair? "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 83973))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.const)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 83973)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 83973))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 83973))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of cdaadr 1 "./boot/macro/derived.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cdaadr 1 "./boot/macro/derived.scm" . 83973)
     (subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.iloc.1 . 0)
     (subr.gloc.of cdadr 1 "./boot/macro/derived.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 83973))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LETREC*)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caaadr 1 "./boot/macro/derived.scm" . 83973)
       (push.iloc.1 . 0)
       (push.subr.gloc.of cdaadr 1 "./boot/macro/derived.scm" . 83973)
       (push.subr.gloc.of car 1 "./boot/macro/derived.scm" . 83973)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 83973)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 83973)
       (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 83973)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 83973))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 83973))
   (iloc.0 . 0)
   (if.false.ret)
   (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
   (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 83973)
   (if.false.ret)
   (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 83973)
   (extend . 1)
   (call
     (touch.gloc.of check-let-bindings)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of check-let-bindings "./boot/macro/derived.scm" . 83973))
   (call
     (push.gloc.of car)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (call
     (touch.gloc.of fresh-rename-count)
     (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (touch.gloc.of rename-id)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of rename-id "./boot/macro/derived.scm" . 83973))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of extend-env)
     (call
       (push.gloc.of cons)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
     (push)
     (push.iloc 4 . 1)
     (apply.gloc.of extend-env "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (touch.gloc.of expand-form)
       (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 83973)
       (push.iloc.1 . 0)
       (apply.gloc.of expand-form "./boot/macro/derived.scm" . 83973))
     (push.iloc 3 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (call
     (touch.gloc.of expand-body)
     (push.iloc 5 . 0)
     (push.cddr.iloc (5 . 0) "./boot/macro/derived.scm" . 83973)
     (push.iloc.0 . 0)
     (apply.gloc.of expand-body "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of annotate-bindings)
     (push.iloc 3 . 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate-bindings "./boot/macro/derived.scm" . 83973))
   (call
     (iloc.0 . 1)
     (if.null?
       (push.car.iloc (6 . 0) "./boot/macro/derived.scm" . 83973)
       (push.const . "empty body")
       (push.iloc 6 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 83973))
     (call
       (touch.gloc.of check-rec-contract-violation)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-rec-contract-violation "./boot/macro/derived.scm" . 83973))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (subr.gloc.of warning-level 0 "./boot/macro/derived.scm" . 83973)
       (if.false.ret)
       (touch.gloc.of warning-contract-violation)
       (push.iloc 7 . 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of warning-contract-violation "./boot/macro/derived.scm" . 83973))
     (ret.const.unspec))
   (call
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (iloc.0 . 0)
       (if.pair?
         (touch.gloc.of denote-lambda?)
         (push.iloc 2 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 83973)
         (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 83973))
       (push.iloc.0 . 0)
       (push.subr.gloc.of symbol? 1 "./boot/macro/derived.scm" . 83973)
       (ret.subr.gloc.of not "./boot/macro/derived.scm" . 83973))
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/derived.scm" . 83973))
   (if.true
     (touch.gloc.of annotate)
     (push.const . letrec*)
     (call
       (touch.gloc.of rewrite-letrec*-bindings)
       (call
         (push.gloc.of list)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of rewrite-letrec*-bindings "./boot/macro/derived.scm" . 83973))
     (push)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 83973)
     (push.iloc 6 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 83973))
   (call
     (push.close
       (1 0)
       (touch.gloc.of rename-id)
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 83973))
       (push)
       (push.iloc 4 . 1)
       (apply.gloc.of rename-id "./boot/macro/derived.scm" . 83973))
     (push.iloc 4 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (extend . 1)
   (push.const . let)
   (call
     (push.gloc.of \x2E;fn2.1\x60;2)
     (push.iloc 3 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (push.const . let)
   (call
     (push.gloc.of list)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (call
     (push.gloc.of \x2E;fn3.1\x60;3)
     (push.iloc 3 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/derived.scm" . 83973))
   (push)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;append 2 "./boot/macro/derived.scm" . 83973)
   (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 83973)
   (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 83973))
 (set.gloc.of expand-letrec)
 (ret.const.unspec))
((close
   (2 0 . expand-let*)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 111628))
   (push)
   (push.const . 2)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 111625)
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 112665)
     (extend . 1)
     (call
       (touch.gloc.of check-let*-bindings)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-let*-bindings "./boot/macro/derived.scm" . 113675))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . \x2E;LET)
             (push.const)
             (push.cddr.iloc (3 . 0) "./boot/macro/derived.scm" . 118815)
             (ret.subr.gloc.of \x2E;cons* "./boot/macro/derived.scm" . 117775))
           (push.const . \x2E;LET)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 119836)
           (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 117775)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 119854)
             (apply.iloc+ (1 . 0) "./boot/macro/derived.scm" . 119848))
           (push)
           (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 117775))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 116749))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 112649))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 112649))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 122907)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 122889))
 (set.gloc.of expand-let*)
 (ret.const.unspec))
((close
   (2 0 . expand-let-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 126981))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 126981)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "expected bindings and body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (call
           (push.gloc.of append)
           (call
             (push.close
               (1 0)
               (call
                 (iloc.0 . 0)
                 (if.not.pair?.ret.const . #f)
                 (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (if.not.pair?.ret.const . #f)
                 (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (ret.null? "./boot/macro/derived.scm" . 126981))
               (if.true
                 (touch.gloc.of collect-lambda-formals)
                 (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
                 (push.iloc 2 . 0)
                 (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 126981))
               (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 126981)
               (push.const . "expected each binding consist of formals and expression")
               (push.iloc 2 . 0)
               (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
             (push.iloc.0 . 1)
             (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
           (push)
           (apply.gloc.of apply "./boot/macro/derived.scm" . 126981))
         (push)
         (apply.gloc.of unique-id-list? "./boot/macro/derived.scm" . 126981))
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 126981)
       (push.const . "duplicate formals")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
     (touch.gloc.of annotate)
     (call
       (extend.enclose
         (2 0 . loop)
         (iloc.0 . 0)
         (if.null?
           (touch.gloc.of expand-form)
           (push.const . \x2E;LET)
           (push.const)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 126981)
           (push.iloc.0 . 1)
           (apply.gloc.of expand-form "./boot/macro/derived.scm" . 126981))
         (call
           (car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 126981)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (subr.gloc.of cddr 1 "./boot/macro/derived.scm" . 126981)
           (ret.null? "./boot/macro/derived.scm" . 126981))
         (if.true
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (push.subr.gloc.of cadr 1 "./boot/macro/derived.scm" . 126981)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
           (push.subr.gloc.of car 1 "./boot/macro/derived.scm" . 126981)
           (extend . 2)
           (call
             (touch.gloc.of collect-lambda-formals)
             (push.iloc.0 . 1)
             (push.iloc 4 . 0)
             (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of fresh-rename-count)
             (apply.gloc.of fresh-rename-count "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (call
             (push.gloc.of cons)
             (push.iloc.1 . 0)
             (call
               (push.close
                 (1 0)
                 (touch.gloc.of rename-id)
                 (push.iloc.0 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of rename-id "./boot/macro/derived.scm" . 126981))
               (push.iloc.1 . 0)
               (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
             (push)
             (apply.gloc.of map "./boot/macro/derived.scm" . 126981))
           (push)
           (extend . 1)
           (push.const . \x2E;call-with-values)
           (push.const . lambda)
           (push.const)
           (call
             (touch.gloc.of expand-form)
             (push.iloc 3 . 0)
             (push.iloc 7 . 1)
             (apply.gloc.of expand-form "./boot/macro/derived.scm" . 126981))
           (push)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 126981)
           (push.const . lambda)
           (call
             (touch.gloc.of rename-lambda-formals)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of rename-lambda-formals "./boot/macro/derived.scm" . 126981))
           (push)
           (call
             (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 126981)
             (call
               (touch.gloc.of extend-env)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of extend-env "./boot/macro/derived.scm" . 126981))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/derived.scm" . 126981))
           (push)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 126981)
           (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 126981))
         (push.const . "internal error: let-values: ~m")
         (push.iloc 3 . 0)
         (apply.gloc.of scheme-error "./boot/macro/derived.scm" . 126981))
       (push.iloc.1 . 1)
       (push.iloc 2 . 1)
       (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 126981))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 126981))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 126981)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 126981))
 (set.gloc.of expand-let-values)
 (ret.const.unspec))
((close
   (2 0 . expand-do)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 168965)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 168965)
     (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 168965)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 168965)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 168965))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 168965)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 168965)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 168965)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 168965)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
       (push.const . "malformed (variable init update)")
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 168965))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
           (ret.pair? "./boot/macro/derived.scm" . 168965))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
           (ret.null? "./boot/macro/derived.scm" . 168965))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of car "./boot/macro/derived.scm" . 168965))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 168965)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 168965)
           (ret.null? "./boot/macro/derived.scm" . 168965))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of caddr "./boot/macro/derived.scm" . 168965))
         (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 168965)
         (push.const . "malformed (variable init update)")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
       (push.iloc.0 . 3)
       (apply.gloc.of map "./boot/macro/derived.scm" . 168965))
     (push)
     (extend . 2)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 0)
       (call
         (push.close
           (1 0)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 168965))
           (if.true
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
             (ret.subr.gloc.of list "./boot/macro/derived.scm" . 168965))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 168965)
           (push.const . "malformed (variable init update)")
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
         (push.iloc.1 . 3)
         (apply.gloc.of map "./boot/macro/derived.scm" . 168965))
       (push)
       (push.const . \x2E;IF)
       (push.iloc.1 . 2)
       (call
         (iloc.1 . 1)
         (if.null? (ret.const \x2E;UNSPECIFIED))
         (push.const . \x2E;BEGIN)
         (iloc.1 . 1)
         (ret.cons "./boot/macro/derived.scm" . 168965))
       (push)
       (push.const . \x2E;BEGIN)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 168965)
       (subr.gloc.of \x2E;append 2 "./boot/macro/derived.scm" . 168965)
       (push.cons)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 168965)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 168965)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 168965))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 168965))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 168965)
   (push.const . "expected (variable init update), test, and command")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 168965))
 (set.gloc.of expand-do)
 (ret.const.unspec))
((close
   (2 0 . expand-let*-values)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (if.not.pair?.ret.const . #f)
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 201733))
   (if.true
     (push.cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
     (extend . 2)
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 201733)
       (if.true.ret)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 201733)
       (push.const . "malformed bindings")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
     (call
       (iloc.0 . 0)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 201733)
       (push.const . "missing body")
       (push.iloc.1 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?
             (push.const . \x2E;LET)
             (push.const)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;cons* "./boot/macro/derived.scm" . 201733))
           (call
             (car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 201733)
             (if.not.pair?.ret.const . #f)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (subr.gloc.of cddr 1 "./boot/macro/derived.scm" . 201733)
             (ret.null? "./boot/macro/derived.scm" . 201733))
           (if.true
             (push.const . \x2E;CALL-WITH-VALUES)
             (push.const . \x2E;LAMBDA)
             (push.const)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of cadr 1 "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 201733)
             (push.const . \x2E;LAMBDA)
             (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
             (push.subr.gloc.of car 1 "./boot/macro/derived.scm" . 201733)
             (call
               (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
               (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 201733))
             (push)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 201733)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 201733))
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 201733)
           (push.const . "expected each binding consist of formals and expression")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
         (push.iloc.1 . 1)
         (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 201733))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 201733))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 201733))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 201733)
   (push.const . "expected bindings and body")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 201733))
 (set.gloc.of expand-let*-values)
 (ret.const.unspec))
((close
   (2 0 . expand-cond)
   (extend.unbound . 3)
   (push.close
     (1 0)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 230432))
   (push.close
     (1 0)
     (touch.gloc.of denote-=>?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-=>? "./boot/macro/derived.scm" . 231454))
   (push.close
     (1 0)
     (touch.gloc.of denote-lambda?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-lambda? "./boot/macro/derived.scm" . 232482))
   (enclose . 3)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.1 . 0)
     (apply.gloc.of safe-length "./boot/macro/derived.scm" . 234511))
   (push)
   (push.const . 1)
   (subr.gloc.of > 2 "./boot/macro/derived.scm" . 234508)
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (call
         (extend.enclose+
           (1 0 . loop)
           (iloc.0 . 0)
           (if.null?.ret.const \x2E;UNSPECIFIED)
           (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 240674)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.pair? "./boot/macro/derived.scm" . 241686))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (call
               (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc (4 . 0) "./boot/macro/derived.scm" . 241686))
             (if.false.ret)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.pair? "./boot/macro/derived.scm" . 241686))
           (if.true
             (cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
             (if.null?
               (push.const . \x2E;BEGIN)
               (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (ret.cons "./boot/macro/derived.scm" . 241686))
             (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 241686)
             (push.const . "misplaced else")
             (push.iloc 5 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of car 1 "./boot/macro/derived.scm" . 241686)
             (if.not.pair?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.iloc.1 . 0)
             (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 241686)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 241686)
             (if.false.ret)
             (call
               (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc (4 . 1) "./boot/macro/derived.scm" . 241686))
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 241686)
             (apply.iloc (4 . 2) "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 241686)
             (push.iloc.1 . 0)
             (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of caar 1 "./boot/macro/derived.scm" . 241686)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (extend . 3)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 241686))
             (push)
             (extend . 1)
             (push.const . \x2E;LET)
             (push.iloc.0 . 0)
             (push.iloc.1 . 2)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;IF)
             (push.iloc.0 . 0)
             (push.const . \x2E;LET)
             (push.iloc.1 . 1)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 241686)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 241686)
             (if.not.null?.ret.const . #f)
             (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (apply.iloc (4 . 1) "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.iloc.1 . 0)
             (push.subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 241686)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (extend . 2)
             (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 241686))
             (push)
             (extend . 1)
             (push.const . \x2E;LET)
             (push.iloc.0 . 0)
             (push.iloc.1 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;IF)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (4 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (5 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (push.subr.gloc.of \x2E;list 4 "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.null? "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.const . \x2E;OR)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 241686))
           (if.true
             (push.const . \x2E;IF)
             (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (push.const . \x2E;BEGIN)
             (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 241686)
             (push.cons)
             (call
               (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 241686)
               (apply.iloc+ (3 . 0) "./boot/macro/derived.scm" . 241686))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/derived.scm" . 241686))
           (push.car.iloc (5 . 0) "./boot/macro/derived.scm" . 241686)
           (push.const . "malformed cond clause")
           (push.iloc 5 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 241686))
         (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 237598)
         (apply.iloc+ (0 . 0) "./boot/macro/derived.scm" . 237582))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 230405))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 230405))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 270366)
   (push.const . "expected cond clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 270348))
 (set.gloc.of expand-cond)
 (ret.const.unspec))
((close
   (2 0)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (call (push.iloc.0 . 1) (apply.iloc (0 . 0) "./boot/macro/derived.scm" . 280603))
   (push)
   (call
     (touch.gloc.of maplist\x60;2)
     (push.iloc.0 . 0)
     (push.cdr.iloc (0 . 1) "./boot/macro/derived.scm" . 280628)
     (apply.gloc.of maplist\x60;2 "./boot/macro/derived.scm" . 280614))
   (ret.cons "./boot/macro/derived.scm" . 280597))
 (set.gloc.of maplist\x60;2)
 (close
   (2 0 . expand-case)
   (extend.enclose
     (1 0)
     (touch.gloc.of denote-else?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-else? "./boot/macro/derived.scm" . 275488))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
     (ret.pair? "./boot/macro/derived.scm" . 301112))
   (if.true
     (push.cddr.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
     (push.cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
     (extend . 2)
     (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 301112))
     (push)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LET)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 301112)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 301112)
       (push.const . \x2E;COND)
       (call
         (touch.gloc.of maplist\x60;2)
         (push.close
           (1 0)
           (push.gloc.of pair?)
           (extend . 1)
           (call
             (iloc.1 . 0)
             (if.not.pair?.ret.const . #f)
             (car.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
             (ret.pair? "./boot/macro/derived.scm" . 301112))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.cdr.iloc (2 . 0) "./boot/macro/derived.scm" . 301112)
             (ret.subr.gloc.of list? "./boot/macro/derived.scm" . 301112))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (call
               (push.iloc 3 . 0)
               (push.subr.gloc.of caar 1 "./boot/macro/derived.scm" . 301112)
               (apply.iloc (6 . 0) "./boot/macro/derived.scm" . 301112))
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 301112))
           (if.true
             (cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 301112)
             (if.null?
               (push.const . \x2E;ELSE)
               (push.iloc 3 . 0)
               (subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
               (ret.cons "./boot/macro/derived.scm" . 301112))
             (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 301112)
             (push.const . "misplaced else")
             (push.iloc 7 . 0)
             (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 301112)
             (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 301112))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (subr.gloc.of caar 1 "./boot/macro/derived.scm" . 301112)
             (if.not.pair?.ret.const . #f)
             (push.iloc 3 . 0)
             (subr.gloc.of cdaar 1 "./boot/macro/derived.scm" . 301112)
             (if.not.null?.ret.const . #f)
             (push.cdr.iloc (3 . 0) "./boot/macro/derived.scm" . 301112)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 301112)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 301112))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
             (push.iloc 3 . 0)
             (push.subr.gloc.of caaar 1 "./boot/macro/derived.scm" . 301112)
             (extend . 2)
             (call
               (iloc.0 . 1)
               (if.symbol?.ret.const . #t)
               (push.iloc.0 . 1)
               (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 301112)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 301112)
               (if.true.ret)
               (push.iloc.0 . 1)
               (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 301112)
               (if.true.ret)
               (iloc.0 . 1)
               (ret.null? "./boot/macro/derived.scm" . 301112))
             (if.true
               (push.const . \x2E;EQ?)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 301112)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 301112)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 301112))
             (push.const . \x2E;EQV?)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 301112)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 301112)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 301112))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of caar 1 "./boot/macro/derived.scm" . 301112)
             (subr.gloc.of list? 1 "./boot/macro/derived.scm" . 301112)
             (if.false.ret)
             (push.iloc 3 . 0)
             (push.subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
             (apply.iloc (2 . 0) "./boot/macro/derived.scm" . 301112))
           (if.true
             (push.iloc 3 . 0)
             (push.subr.gloc.of cdar 1 "./boot/macro/derived.scm" . 301112)
             (push.iloc 3 . 0)
             (push.subr.gloc.of caar 1 "./boot/macro/derived.scm" . 301112)
             (extend . 2)
             (iloc.0 . 1)
             (if.null?.ret.const #f)
             (call
               (touch.gloc.of every1)
               (push.close
                 (1 0)
                 (iloc.0 . 0)
                 (if.symbol?.ret.const . #t)
                 (push.iloc.0 . 0)
                 (subr.gloc.of fixnum? 1 "./boot/macro/derived.scm" . 301112)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of char? 1 "./boot/macro/derived.scm" . 301112)
                 (if.true.ret)
                 (push.iloc.0 . 0)
                 (subr.gloc.of boolean? 1 "./boot/macro/derived.scm" . 301112)
                 (if.true.ret)
                 (iloc.1 . 1)
                 (ret.null? "./boot/macro/derived.scm" . 301112))
               (push.iloc.0 . 1)
               (apply.gloc.of every1 "./boot/macro/derived.scm" . 301112))
             (if.true
               (push.const . \x2E;MEMQ)
               (push.iloc 5 . 0)
               (push.const . quote)
               (push.iloc.0 . 1)
               (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 301112)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 301112)
               (iloc.0 . 0)
               (ret.cons "./boot/macro/derived.scm" . 301112))
             (push.const . \x2E;MEMV)
             (push.iloc 5 . 0)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 301112)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 301112)
             (iloc.0 . 0)
             (ret.cons "./boot/macro/derived.scm" . 301112))
           (push.car.iloc (7 . 0) "./boot/macro/derived.scm" . 301112)
           (push.const . "malformed case clause")
           (push.iloc 7 . 0)
           (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 301112)
           (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 301112))
         (push.iloc.1 . 0)
         (apply.gloc.of maplist\x60;2 "./boot/macro/derived.scm" . 301112))
       (push.cons)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 301112)
       (push.iloc 3 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 301112))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 301112))
   (push.car.iloc (1 . 0) "./boot/macro/derived.scm" . 301112)
   (push.const . "expected case clause")
   (push.iloc.1 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 301112))
 (set.gloc.of expand-case)
 (ret.const.unspec))
((close
   (2 0 . expand-and)
   (touch.gloc.of annotate)
   (push.const . and)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 315428)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 315415))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 315397))
 (set.gloc.of expand-and)
 (ret.const.unspec))
((close
   (2 0 . expand-or)
   (touch.gloc.of annotate)
   (push.const . or)
   (call
     (touch.gloc.of expand-each)
     (push.cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 319523)
     (push.iloc.0 . 1)
     (apply.gloc.of expand-each "./boot/macro/derived.scm" . 319510))
   (push.cons)
   (push.iloc.0 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 319493))
 (set.gloc.of expand-or)
 (ret.const.unspec))
((close
   (1 0 . desugar-define)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 341005)
     (ret.pair? "./boot/macro/derived.scm" . 341005))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 341005)
     (ret.pair? "./boot/macro/derived.scm" . 341005))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 341005)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 341005))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 341005))
   (if.true
     (touch.gloc.of annotate)
     (push.const . define)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (push.const (\x2E;UNSPECIFIED))
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 341005)
     (push.iloc 2 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 341005))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (if.not.null?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 341005)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 341005))
   (if.true
     (push.iloc 2 . 0)
     (push.subr.gloc.of cdadr 1 "./boot/macro/derived.scm" . 341005)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 341005)
     (extend . 2)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 341005))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 341005))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 1)
     (push.const . lambda)
     (push.iloc.0 . 0)
     (push.const (\x2E;UNSPECIFIED))
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 341005)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 341005)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 341005))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 341005)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (ret.pair? "./boot/macro/derived.scm" . 341005))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (push.iloc 2 . 0)
     (push.subr.gloc.of cdadr 1 "./boot/macro/derived.scm" . 341005)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 341005)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 341005))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 341005))
     (touch.gloc.of annotate)
     (push.const . define)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 341005)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 341005)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 341005))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 341005)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 341005)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 341005))
   (push.iloc 2 . 0)
   (push.subr.gloc.of length 1 "./boot/macro/derived.scm" . 341005)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/derived.scm" . 341005)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . 0)
   (if.eq?
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 341005)
     (push.const . "expected 1 or 2, but no clause given")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 341005))
   (push.iloc.0 . 0)
   (push.const 1 2)
   (subr.gloc.of \x2E;memq 2 "./boot/macro/derived.scm" . 341005)
   (if.true
     (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 341005)
     (push.const . "expected symbol for first clause")
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 341005))
   (push.car.iloc (3 . 0) "./boot/macro/derived.scm" . 341005)
   (push.const . "expected 1 or 2, but ~a clauses given")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 341005)
   (push.iloc 3 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 341005))
 (set.gloc.of desugar-define)
 (ret.const.unspec))
((close
   (1 0 . desugar-define-macro)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 347141)
     (ret.pair? "./boot/macro/derived.scm" . 347141))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cadr.iloc (1 . 0) "./boot/macro/derived.scm" . 347141)
     (ret.pair? "./boot/macro/derived.scm" . 347141))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 347141)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
     (ret.subr.gloc.of symbol? "./boot/macro/derived.scm" . 347141))
   (if.true (ret.iloc 2 . 0))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 2 . 0)
     (subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 347141)
     (if.not.symbol?.ret.const . #f)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
     (ret.pair? "./boot/macro/derived.scm" . 347141))
   (if.true
     (push.cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
     (push.iloc 2 . 0)
     (push.subr.gloc.of cdadr 1 "./boot/macro/derived.scm" . 347141)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 347141)
     (extend . 3)
     (call
       (touch.gloc.of collect-lambda-formals)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (apply.gloc.of annotate "./boot/macro/derived.scm" . 347141))
       (push)
       (push.iloc 3 . 0)
       (apply.gloc.of collect-lambda-formals "./boot/macro/derived.scm" . 347141))
     (touch.gloc.of annotate)
     (push.const . define-macro)
     (push.iloc.0 . 2)
     (push.const . lambda)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/derived.scm" . 347141)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 347141)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 347141))
   (iloc.0 . 0)
   (if.true
     (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
     (push.const . "invalid syntax")
     (push.iloc 2 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 347141)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 347141))
   (push.car.iloc (2 . 0) "./boot/macro/derived.scm" . 347141)
   (push.const . "expected symbol and expression")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 347141))
 (set.gloc.of desugar-define-macro)
 (ret.const.unspec))
((close
   (1 0 . rewrite-define-macro)
   (call
     (touch.gloc.of desugar-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of desugar-define-macro "./boot/macro/derived.scm" . 360474))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 360474)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 360474)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 360474)
   (if.not.null?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 360474)
   (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 360474)
   (extend . 2)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/derived.scm" . 360474))
   (push)
   (extend . 1)
   (touch.gloc.of annotate)
   (push.const . \x2E;DEFINE-SYNTAX)
   (push.iloc.1 . 1)
   (push.const . \x2E;LAMBDA)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 1 "./boot/macro/derived.scm" . 360474)
   (push.const . \x2E;APPLY)
   (push.iloc.1 . 0)
   (push.const . \x2E;CDR)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 360474)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 360474)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 360474)
   (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 360474)
   (push.iloc 3 . 0)
   (apply.gloc.of annotate "./boot/macro/derived.scm" . 360474))
 (set.gloc.of rewrite-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-define-macro)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/derived.scm" . 367626))
     (if.false.ret)
     (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 368668)
     (push.const . "misplaced definition")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 368650))
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of rewrite-define-macro)
     (push.iloc.0 . 0)
     (apply.gloc.of rewrite-define-macro "./boot/macro/derived.scm" . 369682))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 369669))
 (set.gloc.of expand-define-macro)
 (ret.const.unspec))
((close
   (2 0 . expand-identifier-syntax)
   (extend.enclose
     (1 0)
     (touch.gloc.of denote-set!?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-set!? "./boot/macro/derived.scm" . 374816))
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (1 . 0) "./boot/macro/derived.scm" . 374789)
     (ret.pair? "./boot/macro/derived.scm" . 374789))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 374789)
     (ret.null? "./boot/macro/derived.scm" . 374789))
   (if.true
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;LAMBDA)
       (push.const x)
       (push.const . \x2E;SYNTAX-CASE)
       (push.const . x)
       (push.const)
       (push.const . id)
       (push.const \x2E;IDENTIFIER? (\x2E;SYNTAX id))
       (push.const . \x2E;SYNTAX)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 374789)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 374789)
       (push.const _ x ...)
       (push.const . \x2E;SYNTAX)
       (push.cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 374789)
       (const x ...)
       (push.cons)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
       (push.subr.gloc.of \x2E;list 5 "./boot/macro/derived.scm" . 374789)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 374789)
       (push.iloc 2 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 374789))
     (push)
     (push.iloc 2 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 374789))
   (iloc.0 . 0)
   (if.false.ret)
   (cadr.iloc (2 . 0) "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of cdadr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (2 . 0) "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
   (subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
   (subr.gloc.of cddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of cddadr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
   (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 374789)
   (subr.gloc.of cdr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.null?.ret.const . #f)
   (push.iloc 2 . 0)
   (subr.gloc.of cdddr 1 "./boot/macro/derived.scm" . 374789)
   (if.not.null?.ret.const . #f)
   (call
     (push.iloc 2 . 0)
     (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of car 1 "./boot/macro/derived.scm" . 374789)
     (apply.iloc (1 . 0) "./boot/macro/derived.scm" . 374789))
   (if.false.ret)
   (push.iloc 2 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/macro/derived.scm" . 374789)
   (push.iloc 2 . 0)
   (push.subr.gloc.of caadr 1 "./boot/macro/derived.scm" . 374789)
   (extend . 2)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (push.const . \x2E;MAKE-VARIABLE-TRANSFORMER)
     (push.const . \x2E;LAMBDA)
     (push.const x)
     (push.const . \x2E;SYNTAX-CASE)
     (push.const . x)
     (push.const set!)
     (push.const . set!)
     (push.iloc 3 . 0)
     (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of cadr 1 "./boot/macro/derived.scm" . 374789)
     (push.iloc 3 . 0)
     (push.subr.gloc.of caaddr 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of caddr 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 374789)
     (push.const . \x2E;SYNTAX)
     (push.iloc 3 . 0)
     (push.subr.gloc.of cdaddr 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of car 1 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.iloc.0 . 1)
     (const x ...)
     (push.cons)
     (push.const . \x2E;SYNTAX)
     (push.iloc.0 . 0)
     (const x ...)
     (push.cons)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.iloc.0 . 1)
     (push.const \x2E;IDENTIFIER? (\x2E;SYNTAX id))
     (push.const . \x2E;SYNTAX)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 6 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 374789)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 374789)
     (push.iloc 3 . 0)
     (apply.gloc.of annotate "./boot/macro/derived.scm" . 374789))
   (push)
   (push.iloc 3 . 1)
   (apply.gloc.of expand-form "./boot/macro/derived.scm" . 374789))
 (set.gloc.of expand-identifier-syntax)
 (ret.const.unspec))
((close
   (2 0 . expand-assert)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/derived.scm" . 401413)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/derived.scm" . 401413)
     (ret.null? "./boot/macro/derived.scm" . 401413))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/derived.scm" . 401413)
     (extend . 1)
     (touch.gloc.of expand-form)
     (call
       (touch.gloc.of annotate)
       (push.const . \x2E;OR)
       (push.iloc.0 . 0)
       (push.const . assertion-violation)
       (push.const . quote)
       (call
         (touch.gloc.of current-top-level-exterior)
         (apply.gloc.of current-top-level-exterior "./boot/macro/derived.scm" . 401413))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/derived.scm" . 401413)
       (push.const . "assertion failed in expression ~u")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/derived.scm" . 401413)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 401413)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/derived.scm" . 401413)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/derived.scm" . 401413))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of expand-form "./boot/macro/derived.scm" . 401413))
   (push.car.iloc (0 . 0) "./boot/macro/derived.scm" . 401413)
   (push.const . "expected single expression")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/derived.scm" . 401413))
 (set.gloc.of expand-assert)
 (ret.const.unspec))

;
((close
   (2 0 . expand-quasiquote)
   (extend.unbound . 12)
   (push.close
     (1 0)
     (touch.gloc.of denote-unquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 8228))
   (push.close
     (1 0)
     (touch.gloc.of denote-quasiquote?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 9255))
   (push.close
     (1 0)
     (touch.gloc.of denote-unquote-splicing?)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 10285))
   (push.close
     (1 0)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 15381)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/quasi.scm" . 16405)
     (if.not.null?.ret.const . #f)
     (touch.gloc.of denote-quote?)
     (push.iloc 2 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 17441)
     (apply.gloc.of denote-quote? "./boot/macro/quasi.scm" . 17422))
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (subr.gloc.of boolean? 1 "./boot/macro/quasi.scm" . 21517)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of number? 1 "./boot/macro/quasi.scm" . 22541)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of char? 1 "./boot/macro/quasi.scm" . 23565)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of string? 1 "./boot/macro/quasi.scm" . 24589)
     (if.true.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of bytevector? 1 "./boot/macro/quasi.scm" . 25613)
     (if.true.ret)
     (push.iloc.0 . 0)
     (apply.iloc (1 . 3) "./boot/macro/quasi.scm" . 26637))
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.iloc (1 . 3) "./boot/macro/quasi.scm" . 30736))
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 30748))
     (ret.iloc 0 . 0))
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.iloc (1 . 3) "./boot/macro/quasi.scm" . 35854))
     (if.false.ret)
     (cadr.iloc (0 . 0) "./boot/macro/quasi.scm" . 36885)
     (ret.null? "./boot/macro/quasi.scm" . 36878))
   (push.close
     (2 0)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc (1 . 6) "./boot/macro/quasi.scm" . 42000))
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 43031)
       (push.const . 1)
       (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 43028)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of car "./boot/macro/quasi.scm" . 43048))
       (push.const . \x2E;APPEND)
       (iloc.0 . 0)
       (ret.cons "./boot/macro/quasi.scm" . 43024))
     (push.const . \x2E;APPEND)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/quasi.scm" . 44047)
     (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 44047)
     (ret.cons "./boot/macro/quasi.scm" . 44047))
   (push.close
     (2 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/macro/quasi.scm" . 49168)
     (push.const . 1)
     (subr.gloc.of = 2 "./boot/macro/quasi.scm" . 49165)
     (if.true
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 50200)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 9) "./boot/macro/quasi.scm" . 50189))
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (call (push.iloc.0 . 1) (apply.iloc (1 . 6) "./boot/macro/quasi.scm" . 52244))
     (if.true (push.const . \x2E;LIST) (iloc.0 . 0) (ret.cons "./boot/macro/quasi.scm" . 52243))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 54315)
       (const . \x2E;LIST)
       (ret.eq? "./boot/macro/quasi.scm" . 54310))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 55333)
       (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 54291)
       (ret.cons "./boot/macro/quasi.scm" . 54291))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56367)
       (const . \x2E;CONS)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 56391)
       (const . \x2E;CONS*)
       (ret.eq? "./boot/macro/quasi.scm" . 56386))
     (if.true
       (push.const . \x2E;CONS*)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 57382)
       (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 56339)
       (ret.cons "./boot/macro/quasi.scm" . 56339))
     (push.const . \x2E;CONS*)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/quasi.scm" . 58387)
     (subr.gloc.of \x2E;append 2 "./boot/macro/quasi.scm" . 58387)
     (ret.cons "./boot/macro/quasi.scm" . 58387))
   (push.close
     (2 0)
     (call
       (call (push.iloc.0 . 0) (apply.iloc (1 . 4) "./boot/macro/quasi.scm" . 63506))
       (if.false.ret)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 4) "./boot/macro/quasi.scm" . 63523))
     (if.true
       (push.const . \x2E;QUOTE)
       (call (push.iloc.0 . 0) (apply.iloc (1 . 5) "./boot/macro/quasi.scm" . 64545))
       (push)
       (call (push.iloc.0 . 1) (apply.iloc (1 . 5) "./boot/macro/quasi.scm" . 64567))
       (push.cons)
       (ret.subr.gloc.of list "./boot/macro/quasi.scm" . 64525))
     (call (push.iloc.0 . 1) (apply.iloc (1 . 6) "./boot/macro/quasi.scm" . 65556))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 65555))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 67627)
       (const . \x2E;LIST)
       (ret.eq? "./boot/macro/quasi.scm" . 67622))
     (if.true
       (push.const . \x2E;LIST)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 68644)
       (ret.subr.gloc.of \x2E;cons* "./boot/macro/quasi.scm" . 67603))
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69679)
       (const . \x2E;CONS)
       (if.eq?.ret.const . #t)
       (push.car.iloc (0 . 1) "./boot/macro/quasi.scm" . 69703)
       (const . \x2E;CONS*)
       (ret.eq? "./boot/macro/quasi.scm" . 69698))
     (if.true
       (push.const . \x2E;CONS*)
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "./boot/macro/quasi.scm" . 70693)
       (ret.subr.gloc.of \x2E;cons* "./boot/macro/quasi.scm" . 69651))
     (push.const . \x2E;CONS)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 71699))
   (push.close
     (2 0)
     (call
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/quasi.scm" . 76828)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 11) "./boot/macro/quasi.scm" . 76820))
     (push)
     (extend . 1)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 6) "./boot/macro/quasi.scm" . 77842))
     (if.true.ret.const \x2E;QUOTE #())
     (call (push.iloc.0 . 0) (apply.iloc (2 . 4) "./boot/macro/quasi.scm" . 79890))
     (if.true
       (push.const . \x2E;QUOTE)
       (call (push.iloc.0 . 0) (apply.iloc (2 . 5) "./boot/macro/quasi.scm" . 80938))
       (push)
       (push.subr.gloc.of list->vector 1 "./boot/macro/quasi.scm" . 80924)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 79889))
     (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 81943)
     (const . \x2E;LIST)
     (if.eq?
       (push.const . \x2E;VECTOR)
       (cdr.iloc (0 . 0) "./boot/macro/quasi.scm" . 82974)
       (ret.cons "./boot/macro/quasi.scm" . 81937))
     (push.const . \x2E;LIST->VECTOR)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 83985))
   (push.close
     (2 0)
     (iloc.0 . 0)
     (if.pair?
       (=n.iloc (0 . 1) 0 "./boot/macro/quasi.scm" . 90132)
       (if.true
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (0 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 0)
           (push.subr.gloc.of cdar 1 "./boot/macro/quasi.scm" . 90128)
           (ret.subr.gloc.of list? "./boot/macro/quasi.scm" . 90128))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of cdar 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc (2 . 8) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of caar 1 "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.iloc.1 . 0)
           (push.subr.gloc.of cdar 1 "./boot/macro/quasi.scm" . 90128)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 0)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc (2 . 7) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (subr.gloc.of list? 1 "./boot/macro/quasi.scm" . 90128)
           (if.false.ret)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (call
             (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (call
             (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
             (push.const . 1)
             (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
           (push)
           (apply.iloc (2 . 9) "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (if.not.null?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true (push.iloc.1 . 0) (ret.subr.gloc.of cadr "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 0) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 1) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "nested quasiquote appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (apply.iloc (2 . 2) "./boot/macro/quasi.scm" . 90128))
         (if.true
           (push.const . quasiquote)
           (push.const . "unquote-splicing appear in bad context")
           (push.iloc 3 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/quasi.scm" . 90128))
         (call
           (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 90128)
           (push.const . 0)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 90128))
         (push)
         (apply.iloc (2 . 9) "./boot/macro/quasi.scm" . 90128))
       (push.car.iloc (0 . 0) "./boot/macro/quasi.scm" . 108575)
       (extend . 1)
       (call
         (call
           (touch.gloc.of denote-unquote?)
           (push.iloc 3 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of denote-unquote? "./boot/macro/quasi.scm" . 109601))
         (if.true.ret)
         (touch.gloc.of denote-unquote-splicing?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-unquote-splicing? "./boot/macro/quasi.scm" . 109627))
       (if.true
         (push.const . \x2E;QUOTE)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/quasi.scm" . 110621)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 111664)
           (push.n+.iloc (1 . 1) -1 "./boot/macro/quasi.scm" . 111675)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 111656))
         (push)
         (apply.iloc (2 . 9) "./boot/macro/quasi.scm" . 110621))
       (call
         (touch.gloc.of denote-quasiquote?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of denote-quasiquote? "./boot/macro/quasi.scm" . 112669))
       (if.true
         (push.const . \x2E;QUOTE)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/quasi.scm" . 113693)
         (call
           (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 114736)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/quasi.scm" . 114747)
           (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 114728))
         (push)
         (apply.iloc (2 . 9) "./boot/macro/quasi.scm" . 113693))
       (call
         (push.car.iloc (1 . 0) "./boot/macro/quasi.scm" . 116784)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 116776))
       (push)
       (call
         (push.cdr.iloc (1 . 0) "./boot/macro/quasi.scm" . 117808)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 11) "./boot/macro/quasi.scm" . 117800))
       (push)
       (apply.iloc (2 . 9) "./boot/macro/quasi.scm" . 116765))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/quasi.scm" . 118800)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 10) "./boot/macro/quasi.scm" . 119824))
     (iloc.0 . 0)
     (if.symbol?
       (push.const . \x2E;QUOTE)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of \x2E;list "./boot/macro/quasi.scm" . 120847))
     (iloc.0 . 0)
     (if.null?.ret.const \x2E;QUOTE ())
     (ret.iloc 0 . 0))
   (enclose . 12)
   (touch.gloc.of expand-form)
   (call
     (touch.gloc.of annotate)
     (call
       (push.cadr.iloc (1 . 0) "./boot/macro/quasi.scm" . 127012)
       (push.const . 0)
       (apply.iloc (0 . 11) "./boot/macro/quasi.scm" . 127004))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of annotate "./boot/macro/quasi.scm" . 126994))
   (push)
   (push.iloc.1 . 1)
   (apply.gloc.of expand-form "./boot/macro/quasi.scm" . 126981))
 (set.gloc.of expand-quasiquote)
 (ret.const.unspec))

;
((close
   (1 0 . ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 8209)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 9231)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 9226))
 (set.gloc.of ellipsis-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-splicing-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 14353)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/macro/synpat.scm" . 15375)
   (const . ...)
   (if.not.eq?.ret.const . #f)
   (cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 16401)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/macro/synpat.scm" . 17423)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 17418))
 (set.gloc.of ellipsis-splicing-pair?)
 (ret.const.unspec))
((close
   (1 0 . ellipsis-quote?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 22545)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 23567)
   (const . ...)
   (ret.eq? "./boot/macro/synpat.scm" . 23562))
 (set.gloc.of ellipsis-quote?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;5)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 29716)
     (call
       (touch.gloc.of loop\x60;5)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 30746)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 30740))
     (push)
     (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 29710))
   (push.iloc.0 . 0)
   (const . ...)
   (if.eq? (ret.iloc 0 . 1))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 33810)
     (if.true (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/synpat.scm" . 33829))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 34830)
   (if.true
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 35860)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 35854))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . collect-unique-ids)
   (touch.gloc.of loop\x60;5)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;5 "./boot/macro/synpat.scm" . 27653))
 (set.gloc.of collect-unique-ids)
 (ret.const.unspec))
((close
   (4 0 . collect-vars-ranks)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 3))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 43024)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of acons)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of acons "./boot/macro/synpat.scm" . 45072))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 0)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 46092))
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.cddr.iloc (0 . 0) "./boot/macro/synpat.scm" . 47136)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 48173)
       (if.symbol?
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 49195)
         (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 49205)
         (push.iloc.0 . 3)
         (apply.gloc.of acons "./boot/macro/synpat.scm" . 49188))
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 50232)
       (push.iloc.0 . 1)
       (push.n+.iloc (0 . 2) 1 "./boot/macro/synpat.scm" . 50248)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 50212))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 47116))
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of collect-vars-ranks)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 52256)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of collect-vars-ranks)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 53300)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 53280))
     (push)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 52236))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 54284)
   (if.true
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 55328)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synpat.scm" . 55308))
   (ret.iloc 0 . 3))
 (set.gloc.of collect-vars-ranks)
 (ret.const.unspec))
((close
   (2 0)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 65560)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 66590)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 66584))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 65554))
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq? (ret.iloc 0 . 1))
     (push.iloc.0 . 0)
     (const . _)
     (if.eq? (ret.iloc 0 . 1))
     (iloc.0 . 0)
     (if.symbol?
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 70678)
       (if.true (ret.iloc 0 . 1))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 72730)
       (if.true
         (push.const . "syntax pattern")
         (push.const . "duplicate pattern variables")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 73754))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synpat.scm" . 74778))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 75794)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 76824)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 76818))
     (ret.iloc 0 . 1))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 63497))
 (set.gloc.of check-duplicate-variable\x60;2)
 (close
   (2 0)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (const . ...)
     (if.eq?
       (push.const . "syntax pattern")
       (push.const . "improper use of ellipsis")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 83986))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 85010))
     (if.true
       (call
         (car.iloc (0 . 0) "./boot/macro/synpat.scm" . 86048)
         (if.not.symbol?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 87069)
         (push.iloc 2 . 1)
         (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 87063)
         (if.false.ret)
         (push.const . "syntax pattern")
         (push.const . "ellipsis following literal")
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 88087))
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 91170)
         (const . ...)
         (if.eq?
           (push.const . "syntax pattern")
           (push.const . "ambiguous use of ellipsis")
           (push.iloc 4 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/synpat.scm" . 92189))
         (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 93219)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 93213))
       (push.cddr.iloc (1 . 0) "./boot/macro/synpat.scm" . 89122)
       (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 89106))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 95260)
         (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95254))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 95277)
       (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 95271))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 96274)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 97304)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 97298))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 81929))
 (set.gloc.of check-misplaced-ellipsis\x60;2)
 (close
   (2 0 . check-pattern)
   (call
     (touch.gloc.of check-misplaced-ellipsis\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of check-misplaced-ellipsis\x60;2 "./boot/macro/synpat.scm" . 100357))
   (touch.gloc.of check-duplicate-variable\x60;2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of check-duplicate-variable\x60;2 "./boot/macro/synpat.scm" . 101381))
 (set.gloc.of check-pattern)
 (ret.const.unspec))
((close
   (3 0 . match-ellipsis?)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 107550)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 107561)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 107534))
   (if.false.ret)
   (touch.gloc.of match-ellipsis?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 108575)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 108558))
 (set.gloc.of match-ellipsis?)
 (ret.const.unspec))
((close
   (4 0 . match-ellipsis-n?)
   (=n.iloc (0 . 2) 0 "./boot/macro/synpat.scm" . 112649)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (touch.gloc.of match-pattern?)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 114718)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 114729)
     (push.iloc.0 . 3)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 114702))
   (if.false.ret)
   (touch.gloc.of match-ellipsis-n?)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 115745)
   (push.iloc.0 . 1)
   (push.n+.iloc (0 . 2) -1 "./boot/macro/synpat.scm" . 115760)
   (push.iloc.0 . 3)
   (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 115726))
 (set.gloc.of match-ellipsis-n?)
 (ret.const.unspec))
((close
   (3 0 . match-pattern?)
   (push.iloc.0 . 1)
   (const . _)
   (if.eq?.ret.const . #t)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 121875)
     (if.true
       (call
         (iloc.0 . 0)
         (if.symbol?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of identifier? "./boot/macro/synpat.scm" . 123932))
       (if.false.ret)
       (touch.gloc.of free-id=?)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of free-id=? "./boot/macro/synpat.scm" . 124952))
     (ret.const . #t))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 126988))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 128028)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 128040))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 129053)
       (if.symbol?.ret.const . #t)
       (touch.gloc.of match-ellipsis?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of match-ellipsis? "./boot/macro/synpat.scm" . 130068))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131100))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 131130)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 131118))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 131097)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 132118)
     (if.true
       (touch.gloc.of match-pattern?)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 133163)
       (push.iloc.1 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 133142))
     (>n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 134171)
     (if.false.ret)
     (call
       (touch.gloc.of match-ellipsis-n?)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of match-ellipsis-n? "./boot/macro/synpat.scm" . 135195))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 136235)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 136254)
     (push.iloc.1 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 136219))
   (iloc.0 . 1)
   (if.pair?
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of match-pattern?)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 139297)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 139308)
       (push.iloc.0 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 139281))
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 140321)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 140332)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 140305))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 141324)
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 142353)
     (if.false.ret)
     (touch.gloc.of match-pattern?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143393)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 143413)
     (push.iloc.0 . 2)
     (apply.gloc.of match-pattern? "./boot/macro/synpat.scm" . 143377))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of equal? "./boot/macro/synpat.scm" . 144401))
 (set.gloc.of match-pattern?)
 (ret.const.unspec))
((close
   (2 0 . union-vars)
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (touch.gloc.of union-vars)
   (call
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/macro/synpat.scm" . 150560)
     (push.iloc.0 . 1)
     (push.subr.gloc.of cdar 1 "./boot/macro/synpat.scm" . 150582)
     (push.subr.gloc.of reverse 1 "./boot/macro/synpat.scm" . 150573)
     (push.iloc.0 . 0)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 150549))
   (push)
   (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 151573)
   (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 150537))
 (set.gloc.of union-vars)
 (ret.const.unspec))
((close
   (3 0 . bind-var!)
   (push.iloc.0 . 0)
   (const . _)
   (if.eq? (ret.iloc 0 . 2))
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (push.subr.gloc.of assq 2 "./boot/macro/synpat.scm" . 157720)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 159795)
     (push.cons)
     (subr.gloc.of set-cdr! 2 "./boot/macro/synpat.scm" . 159769)
     (ret.iloc 1 . 2))
   (touch.gloc.of acons)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of list 1 "./boot/macro/synpat.scm" . 160797)
   (push.iloc.1 . 2)
   (apply.gloc.of acons "./boot/macro/synpat.scm" . 160786))
 (set.gloc.of bind-var!)
 (ret.const.unspec))
((close
   (3 0 . bind-null-ellipsis)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 167953)
     (call
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 168987)
       (push.iloc 2 . 1)
       (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 168981)
       (if.true (ret.iloc 0 . 1))
       (touch.gloc.of bind-var!)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 171040)
       (push.const)
       (push.iloc.0 . 1)
       (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 171029))
     (push)
     (apply.iloc+ (1 . 0) "./boot/macro/synpat.scm" . 167947))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.car.iloc (1 . 0) "./boot/macro/synpat.scm" . 164905)
     (apply.gloc.of collect-unique-ids "./boot/macro/synpat.scm" . 164885))
   (push)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "./boot/macro/synpat.scm" . 164869))
 (set.gloc.of bind-null-ellipsis)
 (ret.const.unspec))
((close
   (5 0 . bind-ellipsis)
   (iloc.0 . 0)
   (if.null?
     (iloc.0 . 4)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 177165))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 178189))
   (touch.gloc.of bind-ellipsis)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 179224)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 180262)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 180273)
     (push.iloc.0 . 2)
     (push.iloc.0 . 4)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 180248))
   (push)
   (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 179209))
 (set.gloc.of bind-ellipsis)
 (ret.const.unspec))
((close
   (6 0 . bind-ellipsis-n)
   (=n.iloc (0 . 3) 0 "./boot/macro/synpat.scm" . 184329)
   (if.true
     (iloc.0 . 5)
     (if.null?
       (touch.gloc.of bind-null-ellipsis)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 4)
       (apply.gloc.of bind-null-ellipsis "./boot/macro/synpat.scm" . 186381))
     (touch.gloc.of union-vars)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (apply.gloc.of union-vars "./boot/macro/synpat.scm" . 187405))
   (touch.gloc.of bind-ellipsis-n)
   (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 188442)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.n+.iloc (0 . 3) -1 "./boot/macro/synpat.scm" . 188463)
   (push.iloc.0 . 4)
   (call
     (touch.gloc.of bind-pattern)
     (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 189480)
     (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 189491)
     (push.iloc.0 . 2)
     (push.iloc.0 . 5)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 189466))
   (push)
   (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 188425))
 (set.gloc.of bind-ellipsis-n)
 (ret.const.unspec))
((close
   (4 0 . bind-pattern)
   (iloc.0 . 1)
   (if.symbol?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (subr.gloc.of memq 2 "./boot/macro/synpat.scm" . 194576)
     (if.true (ret.iloc 0 . 3))
     (touch.gloc.of bind-var!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 196624))
   (call
     (touch.gloc.of ellipsis-pair?)
     (push.iloc.0 . 1)
     (apply.gloc.of ellipsis-pair? "./boot/macro/synpat.scm" . 197644))
   (if.true
     (call
       (cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 198684)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of list? "./boot/macro/synpat.scm" . 198696))
     (if.true
       (car.iloc (0 . 1) "./boot/macro/synpat.scm" . 199709)
       (if.symbol?
         (touch.gloc.of bind-var!)
         (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 200735)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 200724))
       (touch.gloc.of bind-ellipsis)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis "./boot/macro/synpat.scm" . 201748))
     (call
       (touch.gloc.of count-pair)
       (push.iloc.0 . 0)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 202780))
     (push)
     (call
       (touch.gloc.of count-pair)
       (push.cddr.iloc (0 . 1) "./boot/macro/synpat.scm" . 202810)
       (apply.gloc.of count-pair "./boot/macro/synpat.scm" . 202798))
     (push)
     (push.subr.gloc.of - 2 "./boot/macro/synpat.scm" . 202777)
     (extend . 1)
     (touch.gloc.of bind-pattern)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-tail 2 "./boot/macro/synpat.scm" . 203808)
     (push.cddr.iloc (1 . 1) "./boot/macro/synpat.scm" . 203827)
     (push.iloc.1 . 2)
     (call
       (call
         (=n.iloc (0 . 0) 0 "./boot/macro/synpat.scm" . 204841)
         (if.false.ret)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 204858)
         (ret.subr.gloc.of symbol? "./boot/macro/synpat.scm" . 204849))
       (if.true
         (touch.gloc.of bind-var!)
         (push.car.iloc (1 . 1) "./boot/macro/synpat.scm" . 205871)
         (push.const)
         (push.iloc.1 . 3)
         (apply.gloc.of bind-var! "./boot/macro/synpat.scm" . 205860))
       (touch.gloc.of bind-ellipsis-n)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.const)
       (apply.gloc.of bind-ellipsis-n "./boot/macro/synpat.scm" . 206884))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 203794))
   (iloc.0 . 1)
   (if.pair?
     (touch.gloc.of bind-pattern)
     (push.cdr.iloc (0 . 0) "./boot/macro/synpat.scm" . 208922)
     (push.cdr.iloc (0 . 1) "./boot/macro/synpat.scm" . 208933)
     (push.iloc.0 . 2)
     (call
       (touch.gloc.of bind-pattern)
       (push.car.iloc (0 . 0) "./boot/macro/synpat.scm" . 209960)
       (push.car.iloc (0 . 1) "./boot/macro/synpat.scm" . 209971)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 209946))
     (push)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 208908))
   (push.iloc.0 . 1)
   (subr.gloc.of vector? 1 "./boot/macro/synpat.scm" . 210956)
   (if.true
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 211994)
     (push.iloc.0 . 1)
     (push.subr.gloc.of vector->list 1 "./boot/macro/synpat.scm" . 212014)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of bind-pattern "./boot/macro/synpat.scm" . 211980))
   (ret.iloc 0 . 3))
 (set.gloc.of bind-pattern)
 (ret.const.unspec))

;
((close
   (2 0 . collect-rename-ids)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 11287)
     (push.iloc 2 . 1)
     (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 11281)
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 12311)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 12305))
     (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13335)
     (call
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 13351)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 13345))
     (ret.cons "./boot/macro/syntmp.scm" . 13329))
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.1 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 7184))
   (push)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 8199))
 (set.gloc.of collect-rename-ids)
 (ret.const.unspec))
((close
   (1 0 . parse-ellipsis-splicing)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 18469)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 18464))
     (if.true
       (push.n+.iloc (0 . 0) 1 "./boot/macro/syntmp.scm" . 19476)
       (push.cdr.iloc (0 . 1) "./boot/macro/syntmp.scm" . 19486)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 19470))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of list-head 2 "./boot/macro/syntmp.scm" . 21526)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 21518))
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.subr.gloc.of cdddr 1 "./boot/macro/syntmp.scm" . 17438)
   (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 17413))
 (set.gloc.of parse-ellipsis-splicing)
 (ret.const.unspec))
((close
   (2 0 . check-template)
   (extend.unbound . 2)
   (push.close
     (2 0)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 30742))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 30738))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 31762))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 32816))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 33827)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 33816))
           (if.true.ret)
           (call
             (push.iloc.0 . 0)
             (push.const . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 34845))
           (if.false.ret)
           (push.iloc.0 . 1)
           (push.iloc.1 . 1)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 35869))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 28681))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 36882))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 37916)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 37926)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 37910))
         (if.true.ret)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 38945)
           (push.const . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 38939))
         (if.false.ret)
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 39969)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 39963))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 40978))
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of rank-of)
               (push.iloc.0 . 0)
               (push.iloc 5 . 1)
               (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 42029))
             (push)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of >= "./boot/macro/syntmp.scm" . 42025))
           (call
             (touch.gloc.of collect-unique-ids)
             (push.iloc.0 . 0)
             (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 42056))
           (push)
           (apply.gloc.of any1 "./boot/macro/syntmp.scm" . 42006))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 43036)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 43030))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 45084)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 45078))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 46108)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 46102))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 47122)
       (if.false.ret)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 48152)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 48146))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 28681))
   (push.close
     (2 0)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 55324))
         (push)
         (push.iloc 2 . 1)
         (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 55319)
         (if.false.ret)
         (push.const . "syntax template")
         (push.const . "too few ellipsis following subtemplate")
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 56343))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 58392)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 58386))
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 59416)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 59410))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 60434)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 61464)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 61458))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 53257))
   (enclose . 2)
   (call
     (call
       (touch.gloc.of safe-length)
       (push.iloc.1 . 0)
       (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 63505))
     (push)
     (push.const . 2)
     (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 63502)
     (if.false.ret)
     (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 63532)
     (const . ...)
     (ret.eq? "./boot/macro/syntmp.scm" . 63527))
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 64536)
     (push.const . 0)
     (apply.iloc (0 . 1) "./boot/macro/syntmp.scm" . 64521))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (call
         (push.iloc.0 . 0)
         (const . ...)
         (if.not.eq?.ret.const . #f)
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 68631))
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 69658))
       (>.iloc (0 . 1) "./boot/macro/syntmp.scm" . 69655)
       (if.false.ret)
       (push.const . "syntax template")
       (push.const . "too few ellipsis following subtemplate")
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 70679))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 71698))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 72752))
       (push.close
         (3 0)
         (call
           (=n.iloc (1 . 1) 0 "./boot/macro/syntmp.scm" . 73753)
           (if.false.ret)
           (call
             (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 74805)
             (push.iloc.0 . 2)
             (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 74781))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 4 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 75805))
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 76831)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 76820))
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 77844))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 65545))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 78866))
     (if.true
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 79906)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 80942)
           (push.iloc 3 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 80933))
         (push)
         (extend . 1)
         (<n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 81954)
         (if.true
           (push.const . "syntax template")
           (push.const . "misplace ellipsis following literal")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 83057)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 82978))
         (n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 84010)
         (<.iloc (0 . 0) "./boot/macro/syntmp.scm" . 84002)
         (if.true
           (push.const . "syntax template")
           (push.const . "too few ellipsis following subtemplate")
           (push.iloc 4 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 85108)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 85026))
         (push.cddr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 87080)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 87074))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 88096)
       (if.pair?
         (call
           (=n.iloc (0 . 1) 0 "./boot/macro/syntmp.scm" . 89118)
           (if.false.ret)
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 90170)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 90180)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 90146))
           (if.true.ret)
           (push.const . "syntax template")
           (push.const . "missing pattern variable that used in same level as in pattern")
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 91276)
           (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 91170))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 92191)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 92201)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 92185))
         (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 93215)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 93209))
       (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 94240)
       (if.null?
         (push.const . "syntax template")
         (push.const . "misplaced ellipsis following empty list")
         (push.iloc 3 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 95257))
       (push.const . "syntax template")
       (push.const . "misplaced ellipsis following literal")
       (push.iloc 3 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 97385)
       (apply.gloc.of syntax-violation "./boot/macro/syntmp.scm" . 97305))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 98322))
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 99361)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 99346))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 100376)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 100370))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 102424)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 102418))
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 103448)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 103442))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 104466)
     (if.true
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 105496)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 105490))
     (ret.const.unspec))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 65545))
 (set.gloc.of check-template)
 (ret.const.unspec))
((close
   (2 0 . rank-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 109585)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 110608))
   (ret.const . -1))
 (set.gloc.of rank-of)
 (ret.const.unspec))
((close
   (2 0 . subform-of)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 114698)
   (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 114693))
 (set.gloc.of subform-of)
 (ret.const.unspec))
((close
   (4 0 . collect-ellipsis-vars)
   (call
     (touch.gloc.of collect-unique-ids)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-unique-ids "./boot/macro/syntmp.scm" . 130064))
   (push)
   (extend . 1)
   (touch.gloc.of filter)
   (push.gloc.of values)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 133153)
       (push.iloc.1 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syntmp.scm" . 133147)
       (if.false.ret)
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 134194)
       (push.iloc 2 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 134188)
       (subr.gloc.of cdr 1 "./boot/macro/syntmp.scm" . 134183)
       (<.iloc (2 . 2) "./boot/macro/syntmp.scm" . 135204)
       (if.true (ret.iloc 0 . 0))
       (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 136235)
       (if.null? (ret.iloc 0 . 0))
       (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137263)
       (cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 137274)
       (ret.cons "./boot/macro/syntmp.scm" . 137257))
     (push.iloc.1 . 3)
     (apply.gloc.of map "./boot/macro/syntmp.scm" . 130053))
   (push)
   (apply.gloc.of filter "./boot/macro/syntmp.scm" . 130053))
 (set.gloc.of collect-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . consume-ellipsis-vars)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 151587)
         (push.iloc 3 . 0)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 151578))
       (<.iloc (3 . 1) "./boot/macro/syntmp.scm" . 151575)
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 152605)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 152621)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 152615))
         (ret.cons "./boot/macro/syntmp.scm" . 152599))
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 153630)
       (if.null?
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 154653)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 154647))
       (push.iloc.0 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 155678)
       (if.null?
         (const . #t)
         (set.iloc 2 . 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 157725)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 157719))
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of cdar 1 "./boot/macro/syntmp.scm" . 159787)
         (subr.gloc.of circular-list? 1 "./boot/macro/syntmp.scm" . 159771)
         (if.true.ret)
         (const . #t)
         (set.iloc 2 . 1)
         (ret.const.unspec))
       (touch.gloc.of acons)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 160798)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/syntmp.scm" . 160809)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 160827)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 160821))
       (push)
       (apply.gloc.of acons "./boot/macro/syntmp.scm" . 160791))
     (push.iloc 2 . 2)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 149518))
   (push)
   (extend . 1)
   (iloc.1 . 1)
   (if.true (iloc.1 . 0) (if.true.ret.const . #f) (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.true.ret)
   (ret.const))
 (set.gloc.of consume-ellipsis-vars)
 (ret.const.unspec))
((close
   (3 0 . contain-rank-moved-var?)
   (extend.enclose
     (2 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.const . 0)
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 173079))
         (push)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 173074))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 175132)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 175126))
         (if.true.ret)
         (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 176156)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 176150))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 177170)
       (if.false.ret)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 178200)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 178194))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 171017))
   (extend.enclose
     (2 0 . loop)
     (iloc.0 . 0)
     (if.symbol?
       (push.const . 0)
       (call
         (touch.gloc.of rank-of)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 183315))
       (push)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of < "./boot/macro/syntmp.scm" . 183310))
     (call
       (touch.gloc.of ellipsis-splicing-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 184334))
     (if.true
       (push.close
         (0 0)
         (touch.gloc.of parse-ellipsis-splicing)
         (push.iloc.1 . 0)
         (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 185388))
       (push.close
         (3 0)
         (call
           (push.iloc.0 . 0)
           (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 186399)
           (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 186388))
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 187412))
       (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 181253))
     (call
       (touch.gloc.of ellipsis-pair?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 188430))
     (if.true
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 189464)
         (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 189474)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 189458))
       (if.true.ret)
       (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 190488)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 190482))
     (call
       (touch.gloc.of ellipsis-quote?)
       (push.iloc.0 . 0)
       (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 191502))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 192544)
       (push.iloc.0 . 1)
       (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 192526))
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 194584)
         (push.iloc.0 . 1)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 194578))
       (if.true.ret)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 195608)
       (push.iloc.0 . 1)
       (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 195602))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 196622)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 197652)
     (push.iloc.0 . 1)
     (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 197646))
   (push.iloc 2 . 0)
   (push.const . 0)
   (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 181253))
 (set.gloc.of contain-rank-moved-var?)
 (ret.const.unspec))
((close
   (3 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (2 0)
     (push.const . 0)
     (call
       (touch.gloc.of rank-of)
       (push.iloc.0 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 215064))
     (push)
     (push.iloc.0 . 1)
     (subr.gloc.of < 3 "./boot/macro/syntmp.scm" . 215059)
     (if.true
       (push.const . "~a:~a")
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syntmp.scm" . 216130))
       (push)
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 3 "./boot/macro/syntmp.scm" . 216114)
       (push.subr.gloc.of string->symbol 1 "./boot/macro/syntmp.scm" . 216098)
       (extend . 1)
       (call
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syntmp.scm" . 217113)
         (if.true.ret)
         (extend.enclose+
           (2 0 . loop)
           (>n.iloc (0 . 0) 0 "./boot/macro/syntmp.scm" . 219170)
           (if.true
             (push.n+.iloc (0 . 0) -1 "./boot/macro/syntmp.scm" . 220200)
             (call
               (touch.gloc.of make-infinite-list\x60;6)
               (push.car.iloc (0 . 1) "./boot/macro/syntmp.scm" . 220234)
               (apply.gloc.of make-infinite-list\x60;6 "./boot/macro/syntmp.scm" . 220214))
             (push)
             (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 220208)
             (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 220194))
           (push.iloc 5 . 0)
           (push.iloc 2 . 0)
           (push.iloc 3 . 1)
           (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syntmp.scm" . 222242)
           (push.iloc 5 . 1)
           (push.iloc 2 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syntmp.scm" . 223266))
         (push.iloc 2 . 1)
         (call
           (touch.gloc.of rank-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 218160))
         (push)
         (push.subr.gloc.of - 2 "./boot/macro/syntmp.scm" . 218151)
         (call
           (touch.gloc.of subform-of)
           (push.iloc 2 . 0)
           (push.iloc 5 . 2)
           (apply.gloc.of subform-of "./boot/macro/syntmp.scm" . 218188))
         (push)
         (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 218137))
       (ret.iloc 0 . 0))
     (ret.iloc 0 . 0))
   (push.close
     (2 0)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (3 . 0) "./boot/macro/syntmp.scm" . 231448))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 233508)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 233502))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 234532)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 234526))
         (ret.cons "./boot/macro/syntmp.scm" . 233496))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 235544)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 236588)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 236582))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 236568))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 229391))
   (enclose . 2)
   (call
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 242715))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 243739))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 244793))
         (push.close
           (3 0)
           (call
             (push.iloc.0 . 0)
             (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 245808)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 245797))
           (push)
           (push.const . ...)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (apply.iloc (2 . 0) "./boot/macro/syntmp.scm" . 245832))
           (push.cons)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 245789))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 240658))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 246811))
       (if.true
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 247847)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 247857)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 247841))
         (push)
         (push.const . ...)
         (call
           (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 248882)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 248876))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/syntmp.scm" . 248865)
         (ret.cons "./boot/macro/syntmp.scm" . 247835))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 249883))
       (if.true
         (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 250913)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 251955)
           (push.iloc.0 . 1)
           (apply.iloc (2 . 1) "./boot/macro/syntmp.scm" . 251937))
         (ret.cons "./boot/macro/syntmp.scm" . 250907))
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 253991)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 253985))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 255015)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 255009))
         (ret.cons "./boot/macro/syntmp.scm" . 253979))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 256027)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 257071)
           (push.iloc.0 . 1)
           (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 257065))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 257051))
       (ret.iloc 0 . 0))
     (push.iloc 3 . 0)
     (push.const . 0)
     (apply.iloc (0 . 0) "./boot/macro/syntmp.scm" . 240658))
   (push)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 260131)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 260117)
   (push.iloc 2 . 2)
   (push.iloc.1 . 1)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syntmp.scm" . 261154)
   (push.subr.gloc.of append 2 "./boot/macro/syntmp.scm" . 261141)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 207883))
 (set.gloc.of rewrite-template-ranks-vars\x60;2)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of list 1 "./boot/macro/syntmp.scm" . 209946)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of set-cdr! 2 "./boot/macro/syntmp.scm" . 210968)
   (ret.iloc 0 . 0))
 (set.gloc.of make-infinite-list\x60;6)
 (close
   (3 0 . adapt-to-rank-moved-vars)
   (call
     (touch.gloc.of contain-rank-moved-var?)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of contain-rank-moved-var? "./boot/macro/syntmp.scm" . 263177))
   (if.true
     (touch.gloc.of rewrite-template-ranks-vars\x60;2)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of rewrite-template-ranks-vars\x60;2 "./boot/macro/syntmp.scm" . 264201))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of values "./boot/macro/syntmp.scm" . 265225))
 (set.gloc.of adapt-to-rank-moved-vars)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 278556)
   (push.iloc.0 . 1)
   (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 278550)
   (if.true
     (touch.gloc.of loop\x60;13)
     (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 279580)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 279574))
   (touch.gloc.of loop\x60;13)
   (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 281628)
   (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 281644)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 281622))
 (set.gloc.of loop\x60;13)
 (close
   (1 0)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/syntmp.scm" . 274460)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 274471)
       (subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 274454)
       (if.true.ret.const . #f)
       (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 275489)
       (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 275483))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 272397))
   (if.true.ret)
   (touch.gloc.of loop\x60;13)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;13 "./boot/macro/syntmp.scm" . 276493))
 (set.gloc.of remove-duplicates\x60;2)
 (close
   (5 0 . transcribe-template)
   (push.close
     (0 0)
     (touch.gloc.of adapt-to-rank-moved-vars)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (call
       (touch.gloc.of remove-duplicates\x60;2)
       (push.iloc.1 . 2)
       (apply.gloc.of remove-duplicates\x60;2 "./boot/macro/syntmp.scm" . 283728))
     (push)
     (apply.gloc.of adapt-to-rank-moved-vars "./boot/macro/syntmp.scm" . 283685))
   (push.close
     (3 0)
     (extend.unbound . 5)
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 287762)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 289829)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 290857)
           (apply.iloc (4 . 4) "./boot/macro/syntmp.scm" . 290851))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 291875))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 293906)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 293906))
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 299026)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 301093)
         (if.null?.ret.const)
         (iloc 4 . 4)
         (if.true
           (push.iloc 4 . 4)
           (push.cadr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 302125)
           (apply.gloc.of map "./boot/macro/syntmp.scm" . 302115))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of cadr "./boot/macro/syntmp.scm" . 303139))
       (push.const . "syntax template")
       (push.const . "subforms have different size of matched input")
       (push.const . template:)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 305170)
       (push.const . subforms:)
       (iloc 4 . 2)
       (push.cons)
       (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 305170))
     (push.close
       (3 0)
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 1)
         (if.pair?
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.iloc (3 . 4) "./boot/macro/syntmp.scm" . 312352))
           (push)
           (iloc.0 . 0)
           (push.cons)
           (call
             (touch.gloc.of consume-ellipsis-vars)
             (push.iloc 4 . 1)
             (push.iloc 2 . 1)
             (push.iloc.0 . 1)
             (apply.gloc.of consume-ellipsis-vars "./boot/macro/syntmp.scm" . 313370))
           (push)
           (apply.iloc+ (1 . 0) "./boot/macro/syntmp.scm" . 312340))
         (iloc.0 . 1)
         (if.null?.ret.const)
         (push.iloc.0 . 1)
         (const . #t)
         (if.eq? (push.iloc.0 . 0) (ret.subr.gloc.of reverse "./boot/macro/syntmp.scm" . 315429))
         (push.const . "syntax template")
         (push.const . "subforms have different size of matched input")
         (push.const . template:)
         (push.iloc 5 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syntmp.scm" . 317460)
         (push.const . subforms:)
         (iloc 5 . 2)
         (push.cons)
         (apply.gloc.of assertion-violation "./boot/macro/syntmp.scm" . 317460))
       (push.const)
       (call
         (touch.gloc.of collect-ellipsis-vars)
         (push.iloc.1 . 0)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (apply.gloc.of collect-ellipsis-vars "./boot/macro/syntmp.scm" . 310314))
       (push)
       (apply.iloc+ (0 . 0) "./boot/macro/syntmp.scm" . 310283))
     (push.close
       (3 0)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 323609))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 323606)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 324637)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 324630))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 325654))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 327719)
           (ret.null? "./boot/macro/syntmp.scm" . 327712))
         (if.true
           (push.const . \x2E;&NIL)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 329781)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 3) "./boot/macro/syntmp.scm" . 329756))
           (ret.cons "./boot/macro/syntmp.scm" . 328726))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 330805)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 3) "./boot/macro/syntmp.scm" . 330780))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 331829)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 3) "./boot/macro/syntmp.scm" . 331804))
         (ret.cons "./boot/macro/syntmp.scm" . 330774))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 332818)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 333881)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 3) "./boot/macro/syntmp.scm" . 333856))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 333842))
       (ret.iloc 0 . 0))
     (push.close
       (3 0)
       (iloc.0 . 0)
       (if.symbol?
         (call
           (touch.gloc.of rank-of)
           (push.iloc.0 . 0)
           (push.iloc 2 . 1)
           (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 339993))
         (push)
         (push.const . 0)
         (subr.gloc.of < 2 "./boot/macro/syntmp.scm" . 339990)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/syntmp.scm" . 341021)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syntmp.scm" . 341014))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (push.iloc.0 . 2)
         (apply.iloc (1 . 0) "./boot/macro/syntmp.scm" . 342038))
       (call
         (touch.gloc.of ellipsis-splicing-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-splicing-pair? "./boot/macro/syntmp.scm" . 343058))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of parse-ellipsis-splicing)
           (push.iloc.1 . 0)
           (apply.gloc.of parse-ellipsis-splicing "./boot/macro/syntmp.scm" . 344112))
         (push.close
           (3 0)
           (call
             (push.gloc.of append)
             (call
               (push.iloc.0 . 0)
               (push.n+.iloc (1 . 1) 1 "./boot/macro/syntmp.scm" . 345161)
               (push.iloc.1 . 2)
               (apply.iloc (2 . 2) "./boot/macro/syntmp.scm" . 345130))
             (push)
             (apply.gloc.of apply "./boot/macro/syntmp.scm" . 345116))
           (push)
           (call
             (push.iloc.0 . 1)
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc (2 . 4) "./boot/macro/syntmp.scm" . 346140))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 345108))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 337929))
       (call
         (touch.gloc.of ellipsis-pair?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-pair? "./boot/macro/syntmp.scm" . 347154))
       (if.true
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 348194)
         (if.symbol?
           (call
             (touch.gloc.of rank-of)
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 349230)
             (push.iloc 2 . 1)
             (apply.gloc.of rank-of "./boot/macro/syntmp.scm" . 349221))
           (push)
           (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 350250)
           (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 350242)
           (if.true
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 351295)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 1) "./boot/macro/syntmp.scm" . 351274))
             (push)
             (call
               (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 352315)
               (push.iloc.0 . 1)
               (push.iloc.0 . 2)
               (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 352298))
             (push)
             (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 351266))
           (ret.const.unspec))
         (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 353312)
         (if.pair?
           (call
             (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 354363)
             (push.n+.iloc (0 . 1) 1 "./boot/macro/syntmp.scm" . 354374)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 2) "./boot/macro/syntmp.scm" . 354337))
           (push)
           (call
             (push.cddr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 355378)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 355361))
           (push)
           (ret.subr.gloc.of append "./boot/macro/syntmp.scm" . 354329))
         (ret.const.unspec))
       (call
         (touch.gloc.of ellipsis-quote?)
         (push.iloc.0 . 0)
         (apply.gloc.of ellipsis-quote? "./boot/macro/syntmp.scm" . 356370))
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/syntmp.scm" . 357425)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 3) "./boot/macro/syntmp.scm" . 357400))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 358441)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 358424))
         (ret.cons "./boot/macro/syntmp.scm" . 357394))
       (iloc.0 . 0)
       (if.pair?
         (call
           (iloc 3 . 4)
           (if.false.ret)
           (car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 360487)
           (ret.null? "./boot/macro/syntmp.scm" . 360480))
         (if.true
           (push.const . \x2E;&NIL)
           (call
             (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 362541)
             (push.iloc.0 . 1)
             (push.iloc.0 . 2)
             (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 362524))
           (ret.cons "./boot/macro/syntmp.scm" . 361494))
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syntmp.scm" . 363565)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 363548))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syntmp.scm" . 364589)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 364572))
         (ret.cons "./boot/macro/syntmp.scm" . 363542))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syntmp.scm" . 365586)
       (if.true
         (call
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syntmp.scm" . 366641)
           (push.iloc.0 . 1)
           (push.iloc.0 . 2)
           (apply.iloc (1 . 4) "./boot/macro/syntmp.scm" . 366624))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syntmp.scm" . 366610))
       (ret.iloc 0 . 0))
     (enclose . 5)
     (call
       (call
         (touch.gloc.of safe-length)
         (push.iloc.1 . 0)
         (apply.gloc.of safe-length "./boot/macro/syntmp.scm" . 369683))
       (push)
       (push.const . 2)
       (subr.gloc.of = 2 "./boot/macro/syntmp.scm" . 369680)
       (if.false.ret)
       (push.car.iloc (1 . 0) "./boot/macro/syntmp.scm" . 369710)
       (const . ...)
       (ret.eq? "./boot/macro/syntmp.scm" . 369705))
     (if.true
       (push.cadr.iloc (1 . 0) "./boot/macro/syntmp.scm" . 370724)
       (push.const . 0)
       (push.iloc.1 . 2)
       (apply.iloc (0 . 3) "./boot/macro/syntmp.scm" . 370699))
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (apply.iloc (0 . 4) "./boot/macro/syntmp.scm" . 371723))
   (apply.gloc.of \x2E;call-with-values "./boot/macro/syntmp.scm" . 276493))
 (set.gloc.of transcribe-template)
 (ret.const.unspec))

;
((close
   (2 0)
   (push.const . syntax-rules)
   (push.iloc.0 . 0)
   (call
     (push.gloc.of \x2E;fn1.1\x60;1)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 30753))
   (push)
   (ret.subr.gloc.of \x2E;cons* "./boot/macro/synrule.scm" . 29703))
 (set.gloc.of compiled->source\x60;2)
 (close
   (2 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 10265)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 11289)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synrule.scm" . 13332))
   (push)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/synrule.scm" . 14359))
   (push)
   (extend . 4)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 21536)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
         (call
           (touch.gloc.of rename-id)
           (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 20514)
           (push.iloc 2 . 3)
           (apply.gloc.of rename-id "./boot/macro/synrule.scm" . 21556))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/synrule.scm" . 21546))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/synrule.scm" . 21530))
     (push.iloc 2 . 0)
     (push.subr.gloc.of caddr 1 "./boot/macro/synrule.scm" . 12313)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 17426))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (apply.gloc.of transcribe-template "./boot/macro/synrule.scm" . 23573))
   (push)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/synrule.scm" . 25634)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 25660)
         (apply.gloc.of env-lookup "./boot/macro/synrule.scm" . 25644))
       (ret.cons "./boot/macro/synrule.scm" . 25628))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 24597))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 23565))
 (set.gloc.of transcribe-compiled-templete\x60;2)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 30773)
   (push.cadr.iloc (0 . 0) "./boot/macro/synrule.scm" . 30782)
   (ret.subr.gloc.of \x2E;list "./boot/macro/synrule.scm" . 30758))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (2 0 . transcribe-syntax-rules)
   (call
     (iloc.0 . 0)
     (if.pair?.ret.const . #t)
     (push.iloc.0 . 0)
     (push.const . "misplaced syntactic keyword")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 33801))
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 35858)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 35878)
   (extend . 2)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 1)
       (if.true
         (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 39971)
         (push.const . "invalid syntax")
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of put-annotation)
           (call
             (touch.gloc.of compiled->source\x60;2)
             (push.iloc 2 . 0)
             (push.cddr.iloc (3 . 1) "./boot/macro/synrule.scm" . 40044)
             (apply.gloc.of compiled->source\x60;2 "./boot/macro/synrule.scm" . 40020))
           (push)
           (push.iloc 2 . 1)
           (apply.gloc.of put-annotation "./boot/macro/synrule.scm" . 40004))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 39953))
       (push.car.iloc (3 . 0) "./boot/macro/synrule.scm" . 40995)
       (push.const . "invalid syntax")
       (push.iloc 3 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/synrule.scm" . 40977))
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 42010)
     (extend . 1)
     (push.car.iloc (0 . 0) "./boot/macro/synrule.scm" . 43037)
     (extend . 1)
     (call
       (call
         (touch.gloc.of match-pattern?)
         (push.iloc 5 . 0)
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (apply.gloc.of match-pattern? "./boot/macro/synrule.scm" . 44063))
       (if.false.ret)
       (touch.gloc.of bind-pattern)
       (push.iloc 5 . 0)
       (push.iloc.0 . 0)
       (push.iloc 4 . 0)
       (push.const)
       (apply.gloc.of bind-pattern "./boot/macro/synrule.scm" . 45087))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (touch.gloc.of transcribe-compiled-templete\x60;2)
       (push.cdr.iloc (2 . 0) "./boot/macro/synrule.scm" . 47153)
       (push.iloc.0 . 0)
       (apply.gloc.of transcribe-compiled-templete\x60;2 "./boot/macro/synrule.scm" . 47123))
     (push.cdr.iloc (3 . 0) "./boot/macro/synrule.scm" . 48153)
     (apply.iloc+ (4 . 0) "./boot/macro/synrule.scm" . 48147))
   (push.cddr.iloc (2 . 1) "./boot/macro/synrule.scm" . 35898)
   (apply.iloc+ (0 . 0) "./boot/macro/synrule.scm" . 36871))
 (set.gloc.of transcribe-syntax-rules)
 (ret.const.unspec))
((close
   (3 0 . parse-syntax-rule)
   (push.car.iloc (0 . 1) "./boot/macro/synrule.scm" . 52244)
   (push.cadr.iloc (0 . 1) "./boot/macro/synrule.scm" . 52268)
   (extend . 2)
   (call
     (touch.gloc.of check-pattern)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of check-pattern "./boot/macro/synrule.scm" . 53255))
   (call
     (touch.gloc.of collect-vars-ranks)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.const)
     (apply.gloc.of collect-vars-ranks "./boot/macro/synrule.scm" . 54292))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of check-template)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of check-template "./boot/macro/synrule.scm" . 55305))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of collect-rename-ids)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-rename-ids "./boot/macro/synrule.scm" . 56360))
   (push)
   (ret.subr.gloc.of values "./boot/macro/synrule.scm" . 56329))
 (set.gloc.of parse-syntax-rule)
 (ret.const.unspec))
((close
   (4 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of list "./boot/macro/synrule.scm" . 74780))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (call
     (touch.gloc.of get-annotation)
     (push.iloc.0 . 0)
     (apply.gloc.of get-annotation "./boot/macro/synrule.scm" . 63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . \x2E;&SOURCE-PATH)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/synrule.scm" . 65563)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synrule.scm" . 65557))
 (set.gloc.of make-remark\x60;2)
 (close
   (4 0 . compile-syntax-rules)
   (call
     (touch.gloc.of unrename-syntax)
     (push.iloc.0 . 1)
     (push.iloc.0 . 3)
     (apply.gloc.of unrename-syntax "./boot/macro/synrule.scm" . 69650))
   (push)
   (call
     (touch.gloc.of unrename-syntax)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of unrename-syntax "./boot/macro/synrule.scm" . 69688))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of make-remark\x60;2)
     (push.iloc.1 . 0)
     (apply.gloc.of make-remark\x60;2 "./boot/macro/synrule.scm" . 71699))
   (push)
   (call
     (push.close
       (1 0)
       (push.close
         (0 0)
         (touch.gloc.of parse-syntax-rule)
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.iloc 3 . 3)
         (apply.gloc.of parse-syntax-rule "./boot/macro/synrule.scm" . 73801))
       (push.gloc.of \x2E;fn1.1\x60;1)
       (apply.gloc.of \x2E;call-with-values "./boot/macro/synrule.scm" . 72728))
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/macro/synrule.scm" . 69637))
   (push)
   (subr.gloc.of cons 2 "./boot/macro/synrule.scm" . 69637)
   (ret.cons "./boot/macro/synrule.scm" . 69637))
 (set.gloc.of compile-syntax-rules)
 (ret.const.unspec))

;
((push.const . \x2E;patvars)
 (push.const)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 14337))
((close
   (3 0 . make-syntax-object)
   (push.const . type:syntax)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 16446))
 (set.gloc.of make-syntax-object)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-expr)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 17453))
 (set.gloc.of syntax-object-expr)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-renames)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 18477))
 (set.gloc.of syntax-object-renames)
 (ret.const.unspec))
((close
   (1 0 . syntax-object-lexname)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/macro/syncase.scm" . 19501))
 (set.gloc.of syntax-object-lexname)
 (ret.const.unspec))
((close
   (1 0 . wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 23562)
   (const . type:syntax)
   (ret.eq? "./boot/macro/syncase.scm" . 23557))
 (set.gloc.of wrapped-syntax-object?)
 (ret.const.unspec))
((close
   (2 0 . lookup-lexical-name)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 27665))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol? (ret.iloc 0 . 0))
   (call
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/syncase.scm" . 29715))
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 29729))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 28679))
   (ret.iloc 2 . 0))
 (set.gloc.of lookup-lexical-name)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;7)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 39964)
       (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 39958))
     (if.true.ret)
     (touch.gloc.of loop\x60;7)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 39981)
     (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 39975))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 40978)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 43033)
       (if.false.ret)
       (call
         (touch.gloc.of loop\x60;7)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 44067)
         (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 44061))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 45092)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 45085))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 42020)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 42017)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 42002))
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 46098))
   (if.true.ret.const . #f)
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 48146))
 (set.gloc.of loop\x60;7)
 (close
   (1 0)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;7 "./boot/macro/syncase.scm" . 37897))
 (set.gloc.of contain-non-id-wrapped-syntax-object?\x60;2)
 (close
   (1 0 . unwrap-syntax)
   (call
     (touch.gloc.of contain-non-id-wrapped-syntax-object?\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of contain-non-id-wrapped-syntax-object?\x60;2 "./boot/macro/syncase.scm" . 50188))
   (if.true
     (call
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 55332)
               (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 55326))
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 56356)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 56350))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 57374)
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 58413)
             (apply.gloc.of for-each "./boot/macro/syncase.scm" . 58398))
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 59422))
           (if.true
             (call
               (touch.gloc.of syntax-object-renames)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 60460))
             (push)
             (extend . 1)
             (iloc.0 . 0)
             (if.null?.ret.const . #t)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 62529)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 62500)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 63548)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 63561)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 63524))
           (call
             (touch.gloc.of wrapped-syntax-object?)
             (push.iloc.0 . 0)
             (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 64542))
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 66635)
                 (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 66606)
                 (if.true.ret)
                 (push.iloc 3 . 0)
                 (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 67654)
                 (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 67662)
                 (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 67630))
               (call
                 (touch.gloc.of syntax-object-renames)
                 (push.iloc.0 . 0)
                 (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 68648))
               (push)
               (apply.gloc.of for-each "./boot/macro/syncase.scm" . 65566))
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 69668))
             (push)
             (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 69662))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 53269))
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable->alist "./boot/macro/syncase.scm" . 70677))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 73766)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73760))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 73787)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 73781))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 74796)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 74814)
           (ret.eq? "./boot/macro/syncase.scm" . 74807))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 75813))
       (iloc.0 . 0)
       (if.symbol?
         (touch.gloc.of make-syntax-object)
         (push.iloc.0 . 0)
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 77875)
           (if.true.ret)
           (ret.const))
         (push)
         (push.const . #f)
         (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 77847))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 78871))
       (if.true
         (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 79902))
         (if.true (ret.iloc 0 . 0))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 80937))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 80931))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 81943)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 82991)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 82981))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 82967))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 71694))
   (ret.iloc 0 . 0))
 (set.gloc.of unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 93222)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 93216))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 93243)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 93237))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 94252)
           (if.not.eq?.ret.const . #f)
           (push.iloc.0 . 1)
           (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 94270)
           (ret.eq? "./boot/macro/syncase.scm" . 94263))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 95269))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 96279)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 97327)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 97317))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 97303))
       (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 98327))
       (if.true
         (call
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 99365))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?.ret.const . #t)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 101438)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 101409)
           (if.true.ret)
           (push.iloc 3 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 102457)
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 102470)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 102433))
         (touch.gloc.of syntax-object-expr)
         (push.iloc.0 . 0)
         (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 103447))
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 104471))
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 106564)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/syncase.scm" . 106535)
             (if.true.ret)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 107583)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 107591)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 107559))
           (call
             (touch.gloc.of syntax-object-renames)
             (push.iloc.0 . 0)
             (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 108577))
           (push)
           (apply.gloc.of for-each "./boot/macro/syncase.scm" . 105495))
         (call
           (touch.gloc.of syntax-object-expr)
           (push.iloc.0 . 0)
           (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 109597))
         (push)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 109591))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 91150))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 111638)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 89093))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;flatten-syntax)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 88067))
((close
   (3 1)
   (extend.enclose
     (2 0)
     (call
       (touch.gloc.of match-pattern?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of match-pattern? "./boot/macro/syncase.scm" . 118798))
     (if.false.ret)
     (touch.gloc.of bind-pattern)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc 2 . 2)
     (push.const)
     (apply.gloc.of bind-pattern "./boot/macro/syncase.scm" . 119822))
   (call
     (touch.gloc.of unwrap-syntax)
     (push.iloc.1 . 1)
     (apply.gloc.of unwrap-syntax "./boot/macro/syncase.scm" . 121873))
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (ret.subr.gloc.of car "./boot/macro/syncase.scm" . 124977))
       (push)
       (push.const . "invalid syntax")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 124941))
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 125979)
     (push.subr.gloc.of cadr 1 "./boot/macro/syncase.scm" . 128029)
     (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 125979)
     (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 129051)
     (extend . 2)
     (call
       (push.iloc 3 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 125979)
       (push.subr.gloc.of car 1 "./boot/macro/syncase.scm" . 127002)
       (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 130077))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.1 . 0)
       (if.false.ret.const . #t)
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 133160)
       (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 133152))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (push.subr.gloc.of append 2 "./boot/macro/syncase.scm" . 134173)
       (apply.iloc (1 . 1) "./boot/macro/syncase.scm" . 134167))
     (push.cdr.iloc (2 . 0) "./boot/macro/syncase.scm" . 135197)
     (apply.iloc+ (3 . 0) "./boot/macro/syncase.scm" . 135191))
   (push.iloc 3 . 3)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 122887))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax-dispatch)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 113665))
((close
   (2 0)
   (extend.enclose+
     (1 0 . loop)
     (call
       (touch.gloc.of contain-wrapped-syntax-object?\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of contain-wrapped-syntax-object?\x60;2 "./boot/macro/syncase.scm" . 187410))
     (if.true
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 189480)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 189474))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 189501)
           (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 189495))
         (push)
         (extend . 2)
         (call
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 190508)
           (iloc.0 . 0)
           (if.not.eq?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 190526)
           (iloc.0 . 1)
           (ret.eq? "./boot/macro/syncase.scm" . 190521))
         (if.true (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (ret.cons "./boot/macro/syncase.scm" . 191527))
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (const . \x2E;&NIL)
     (if.eq?
       (touch.gloc.of make-syntax-object)
       (push.const)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 194578))
     (iloc.0 . 0)
     (if.symbol?
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 196654)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 196626))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 197650)
     (if.true
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of rewrite-nil\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-nil\x60;2 "./boot/macro/syncase.scm" . 198694))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 198674))
     (iloc.0 . 0)
     (if.pair?
       (touch.gloc.of make-syntax-object)
       (call
         (touch.gloc.of rewrite-nil\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of rewrite-nil\x60;2 "./boot/macro/syncase.scm" . 200742))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 200722))
     (iloc.0 . 0)
     (if.null?.ret.const)
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 203794))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 186377))
 (set.gloc.of partial-wrap-syntax-object\x60;2)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;23)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 162849)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 162843))
     (push)
     (call
       (touch.gloc.of loop\x60;23)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 162870)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 162864))
     (push)
     (extend . 2)
     (call
       (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 163877)
       (iloc.0 . 0)
       (if.not.eq?.ret.const . #f)
       (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 163895)
       (iloc.0 . 1)
       (ret.eq? "./boot/macro/syncase.scm" . 163890))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 164896))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 165906)
   (if.true
     (call
       (touch.gloc.of loop\x60;23)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 166950)
       (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 166944))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 166930))
   (push.iloc.0 . 0)
   (const . \x2E;&NIL)
   (if.eq?.ret.const)
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;23)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149533)
     (if.null?.ret.const . #t)
     (call
       (touch.gloc.of loop\x60;9)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 149550)
       (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 149544))
     (if.true.ret)
     (touch.gloc.of loop\x60;9)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 149567)
     (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 149561))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 150546)
   (if.true
     (extend.enclose+
       (1 0 . loop2)
       (>=n.iloc (0 . 0) 0 "./boot/macro/syncase.scm" . 152601)
       (if.false.ret)
       (call
         (touch.gloc.of loop\x60;9)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector-ref 2 "./boot/macro/syncase.scm" . 153635)
         (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 153629))
       (if.true.ret)
       (push.n+.iloc (0 . 0) -1 "./boot/macro/syncase.scm" . 154660)
       (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 154653))
     (push.iloc.1 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/macro/syncase.scm" . 151588)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/syncase.scm" . 151585)
     (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 151570))
   (touch.gloc.of wrapped-syntax-object?)
   (push.iloc.0 . 0)
   (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 156690))
 (set.gloc.of loop\x60;9)
 (close
   (1 0)
   (touch.gloc.of loop\x60;9)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;9 "./boot/macro/syncase.scm" . 147465))
 (set.gloc.of contain-wrapped-syntax-object?\x60;2)
 (close
   (1 0)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 142352))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 143381))
 (set.gloc.of emit\x60;2)
 (close
   (2 0)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 175137)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 175131))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 175158)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 175152))
       (push)
       (extend . 2)
       (call
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 176165)
         (iloc.0 . 0)
         (if.not.eq?.ret.const . #f)
         (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 176183)
         (iloc.0 . 1)
         (ret.eq? "./boot/macro/syncase.scm" . 176178))
       (if.true (ret.iloc 1 . 0))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/syncase.scm" . 177184))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 178194)
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 179238)
         (apply.iloc+ (1 . 0) "./boot/macro/syncase.scm" . 179232))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 179218))
     (call
       (touch.gloc.of renamed-id?)
       (push.iloc.0 . 0)
       (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 180242))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 181294)
         (if.true.ret)
         (ret.const))
       (push)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 181266))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "./boot/macro/syncase.scm" . 173065))
 (set.gloc.of wrap-renamed-id\x60;2)
 (close
   (1 0)
   (touch.gloc.of loop\x60;23)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;23 "./boot/macro/syncase.scm" . 160777))
 (set.gloc.of rewrite-nil\x60;2)
 (close
   (5 0 . syntax-transcribe)
   (iloc.0 . 1)
   (if.null?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 206857))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 208913))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 210961))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of current-rename-count)
     (apply.gloc.of current-rename-count "./boot/macro/syncase.scm" . 213009))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of rename-id)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of rename-id "./boot/macro/syncase.scm" . 215084))
       (ret.cons "./boot/macro/syncase.scm" . 215075))
     (call
       (touch.gloc.of collect-rename-ids)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 216086))
     (push)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 215057))
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 218154)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 218184)
         (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 218164))
       (ret.cons "./boot/macro/syncase.scm" . 218148))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/syncase.scm" . 218129))
   (push)
   (extend . 1)
   (call
     (iloc 5 . 4)
     (if.null? (ret.const))
     (iloc 3 . 0)
     (if.null?.ret.const)
     (touch.gloc.of filter)
     (push.gloc.of values)
     (call
       (push.close
         (1 0)
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 226353)
         (push.iloc 6 . 4)
         (push.subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 227376)
         (extend . 1)
         (iloc.0 . 0)
         (if.false.ret)
         (call
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 226353)
             (push.iloc 5 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 229442))
           (push)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 229475)
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of local-macro-symbol?)
             (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 230487)
             (apply.gloc.of local-macro-symbol? "./boot/macro/syncase.scm" . 230466))
           (if.false.ret)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 231530)
             (push.iloc 6 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 231509))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of local-macro-symbol?)
             (push.iloc.0 . 0)
             (apply.gloc.of local-macro-symbol? "./boot/macro/syncase.scm" . 232521))
           (if.false.ret)
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 233583)
             (push.iloc 6 . 0)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 233562))
           (ret.eq? "./boot/macro/syncase.scm" . 233545))
         (if.true.ret.const . #f)
         (push.cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 235583)
         (call
           (touch.gloc.of make-out-of-context)
           (push.iloc 7 . 1)
           (apply.gloc.of make-out-of-context "./boot/macro/syncase.scm" . 235591))
         (ret.cons "./boot/macro/syncase.scm" . 235577))
       (push.iloc.1 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 207881))
     (push)
     (apply.gloc.of filter "./boot/macro/syncase.scm" . 207881))
   (push)
   (extend . 1)
   (iloc 5 . 0)
   (if.null?
     (call
       (touch.gloc.of transcribe-template)
       (push.iloc 6 . 1)
       (push.iloc 6 . 2)
       (push.iloc 6 . 0)
       (push.iloc 2 . 0)
       (push.const . #f)
       (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 239643))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of renamed-id?)
       (push.iloc.0 . 0)
       (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 240661))
     (if.true
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (push.iloc 2 . 0)
         (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 241714)
         (if.true.ret)
         (ret.const))
       (push)
       (push.iloc 7 . 3)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 241685))
     (touch.gloc.of wrap-renamed-id\x60;2)
     (push.iloc.0 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of wrap-renamed-id\x60;2 "./boot/macro/syncase.scm" . 242709))
   (call
     (touch.gloc.of transcribe-template)
     (push.iloc 6 . 1)
     (push.iloc 6 . 2)
     (push.iloc 6 . 0)
     (push.iloc 2 . 0)
     (push.gloc.of emit\x60;2)
     (apply.gloc.of transcribe-template "./boot/macro/syncase.scm" . 243739))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 245784))
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (const . \x2E;&NIL)
   (if.eq?
     (touch.gloc.of make-syntax-object)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 247832))
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 249909)
       (if.true.ret)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 249936)
       (if.true.ret)
       (ret.const))
     (push)
     (push.iloc 7 . 3)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 249880))
   (touch.gloc.of partial-wrap-syntax-object\x60;2)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of extend-env)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 251961))
   (push)
   (apply.gloc.of partial-wrap-syntax-object\x60;2 "./boot/macro/syncase.scm" . 251928))
 (set.gloc.of syntax-transcribe)
 (ret.const.unspec))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 256005))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i0)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 253953))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 260134)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 260101))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i1)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 258049))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 264197))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i2)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 262145))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 1)
   (const . 0)
   (push.cons)
   (push.subr.gloc.of list 1 "./boot/macro/syncase.scm" . 268326)
   (push.iloc.0 . 2)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 268293))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/i3)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 266241))
((close
   (2 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 272389))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c0)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 270337))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.const)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 276485))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c1)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 274433))
((close
   (3 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.const . #f)
   (push.iloc.0 . 2)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 280581))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c2)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 278529))
((close
   (4 0)
   (touch.gloc.of syntax-transcribe)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.const . #f)
   (push.iloc.0 . 3)
   (apply.gloc.of syntax-transcribe "./boot/macro/syncase.scm" . 284677))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;syntax/c3)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 282625))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
   (call
     (touch.gloc.of make-pattern-variable)
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
     (apply.gloc.of make-pattern-variable "./boot/macro/syncase.scm" . 289797))
   (ret.cons "./boot/macro/syncase.scm" . 289797))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (2 0)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 292906)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 292900))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 292923)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 292917))
       (ret.cons "./boot/macro/syncase.scm" . 292894))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 293925))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 292875))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 294930)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 294968)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 294958))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 294944))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 291849))
 (set.gloc.of rewrite\x60;2)
 (close
   (2 0 . expand-syntax-case)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/syncase.scm" . 289797)
     (ret.subr.gloc.of list? "./boot/macro/syncase.scm" . 289797))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdddr 1 "./boot/macro/syncase.scm" . 289797)
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
     (extend . 2)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 289797)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 289797))
     (push)
     (extend . 1)
     (call
       (call
         (push.iloc.0 . 0)
         (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 289797)
         (if.false.ret)
         (touch.gloc.of every1)
         (push.gloc.of symbol?)
         (push.iloc.0 . 0)
         (apply.gloc.of every1 "./boot/macro/syncase.scm" . 289797))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "invalid literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 289797))
     (call
       (call
         (touch.gloc.of unique-id-list?)
         (push.iloc.0 . 0)
         (apply.gloc.of unique-id-list? "./boot/macro/syncase.scm" . 289797))
       (if.true.ret)
       (push.const . syntax-case)
       (push.const . "duplicate literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 289797))
     (call
       (push.const . _)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 289797)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "_ in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 289797))
     (call
       (push.const . ...)
       (push.iloc.0 . 0)
       (subr.gloc.of memq 2 "./boot/macro/syncase.scm" . 289797)
       (if.false.ret)
       (push.const . syntax-case)
       (push.const . "... in literals")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 289797))
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (touch.gloc.of lookup-lexical-name)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 289797))
         (ret.cons "./boot/macro/syncase.scm" . 289797))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 289797))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of rewrite\x60;2)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of rewrite\x60;2 "./boot/macro/syncase.scm" . 289797))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0)
       (call
         (touch.gloc.of rewrite\x60;2)
         (call
           (touch.gloc.of unrename-syntax)
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 289797))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of rewrite\x60;2 "./boot/macro/syncase.scm" . 289797))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 289797))
       (call
         (touch.gloc.of check-pattern)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (apply.gloc.of check-pattern "./boot/macro/syncase.scm" . 289797))
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of extend-env)
         (call
           (push.gloc.of \x2E;fn3.1\x60;3)
           (call
             (touch.gloc.of collect-vars-ranks)
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.const . 0)
             (push.const)
             (apply.gloc.of collect-vars-ranks "./boot/macro/syncase.scm" . 289797))
           (push)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 289797))
         (push)
         (push.iloc 7 . 1)
         (apply.gloc.of extend-env "./boot/macro/syncase.scm" . 289797))
       (push)
       (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 289797))
     (touch.gloc.of annotate)
     (push.const . \x2E;syntax-dispatch)
     (call
       (touch.gloc.of expand-form)
       (push.const . \x2E;patvars)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 289797))
     (push)
     (call
       (touch.gloc.of expand-form)
       (push.iloc 4 . 1)
       (push.iloc 5 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 289797))
     (push)
     (push.const . quote)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 289797)
     (call
       (push.close
         (1 0)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 289797)
           (ret.pair? "./boot/macro/syncase.scm" . 289797))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.false.ret)
           (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
           (ret.null? "./boot/macro/syncase.scm" . 289797))
         (if.true
           (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
           (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
           (extend . 2)
           (push.close
             (0 0)
             (push.iloc.1 . 1)
             (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 289797))
           (push.close
             (2 0)
             (push.const . \x2E;list)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 289797)
             (push.const . #f)
             (call
               (touch.gloc.of expand-form)
               (push.const . \x2E;LAMBDA)
               (push.const \x2E;patvars)
               (push.iloc.1 . 0)
               (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 289797)
               (push.iloc.0 . 1)
               (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 289797))
             (push)
             (ret.subr.gloc.of \x2E;list "./boot/macro/syncase.scm" . 289797))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 289797))
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cdddr 1 "./boot/macro/syncase.scm" . 289797)
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of caddr 1 "./boot/macro/syncase.scm" . 289797)
         (push.cadr.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
         (push.car.iloc (1 . 0) "./boot/macro/syncase.scm" . 289797)
         (extend . 3)
         (push.close
           (0 0)
           (push.iloc.1 . 2)
           (apply.iloc (4 . 0) "./boot/macro/syncase.scm" . 289797))
         (push.close
           (2 0)
           (push.const . \x2E;list)
           (push.const . quote)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 289797)
           (call
             (touch.gloc.of expand-form)
             (push.const . \x2E;LAMBDA)
             (push.const \x2E;patvars)
             (push.iloc.1 . 1)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 289797)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 289797))
           (push)
           (call
             (touch.gloc.of expand-form)
             (push.const . \x2E;LAMBDA)
             (push.const \x2E;patvars)
             (push.iloc.1 . 0)
             (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 289797)
             (push.iloc.0 . 1)
             (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 289797))
           (push)
           (ret.subr.gloc.of \x2E;list "./boot/macro/syncase.scm" . 289797))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 289797))
       (push.iloc 4 . 0)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 289797))
     (push)
     (push.subr.gloc.of \x2E;cons* 5 "./boot/macro/syncase.scm" . 289797)
     (push.iloc 4 . 1)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 289797))
   (push.const . syntax-case)
   (push.const . "invalid syntax")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 289797))
 (set.gloc.of expand-syntax-case)
 (ret.const.unspec))
((close
   (2 0)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 354346)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 354340))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 354363)
         (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 354357))
       (ret.cons "./boot/macro/syncase.scm" . 354334))
     (call
       (iloc.0 . 0)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of assq "./boot/macro/syncase.scm" . 355365))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/syncase.scm" . 354315))
     (push.iloc.1 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 356370)
     (if.true
       (call
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 356408)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 356398))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 356384))
     (ret.iloc 1 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 353289))
 (set.gloc.of rewrite\x60;2)
 (close
   (2 0 . expand-syntax)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 351237)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/syncase.scm" . 351237)
     (ret.null? "./boot/macro/syncase.scm" . 351237))
   (if.true
     (push.cadr.iloc (0 . 0) "./boot/macro/syncase.scm" . 351237)
     (extend . 1)
     (call
       (touch.gloc.of unrename-syntax)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of unrename-syntax "./boot/macro/syncase.scm" . 351237))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 351237))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of pattern-variable?)
             (push.iloc.0 . 0)
             (apply.gloc.of pattern-variable? "./boot/macro/syncase.scm" . 351237))
           (if.false.ret)
           (push.iloc.1 . 0)
           (cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 351237)
           (ret.cons "./boot/macro/syncase.scm" . 351237))
         (call
           (touch.gloc.of collect-unique-ids)
           (push.iloc.0 . 0)
           (apply.gloc.of collect-unique-ids "./boot/macro/syncase.scm" . 351237))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 351237))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 351237))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of check-template)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of check-template "./boot/macro/syncase.scm" . 351237))
     (call
       (touch.gloc.of expand-form)
       (push.const . \x2E;patvars)
       (push.iloc 3 . 1)
       (apply.gloc.of expand-form "./boot/macro/syncase.scm" . 351237))
     (push)
     (extend . 1)
     (iloc 2 . 0)
     (if.symbol?
       (call
         (touch.gloc.of lookup-lexical-name)
         (push.iloc 3 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 351237))
       (push)
       (extend . 1)
       (push.iloc 3 . 0)
       (iloc.0 . 0)
       (if.eq?
         (iloc 2 . 0)
         (if.null?
           (touch.gloc.of annotate)
           (push.const . \x2E;syntax/i0)
           (push.iloc.1 . 0)
           (push.const . quote)
           (push.iloc 3 . 0)
           (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
           (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 351237)
           (push.iloc 5 . 0)
           (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/i1)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
         (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 351237)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/i2)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
         (push.const . quote)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
         (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 351237)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/i3)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 351237)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.close
           (1 0)
           (call
             (touch.gloc.of lookup-lexical-name)
             (push.iloc.0 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 351237))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of renamed-id?)
             (push.iloc.0 . 0)
             (apply.gloc.of renamed-id? "./boot/macro/syncase.scm" . 351237))
           (if.false.ret)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (if.eq?.ret.const . #f)
           (push.iloc.1 . 0)
           (iloc.0 . 0)
           (ret.cons "./boot/macro/syncase.scm" . 351237))
         (call
           (touch.gloc.of collect-rename-ids)
           (push.iloc 2 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of collect-rename-ids "./boot/macro/syncase.scm" . 351237))
         (push)
         (apply.gloc.of map "./boot/macro/syncase.scm" . 351237))
       (push)
       (apply.gloc.of filter "./boot/macro/syncase.scm" . 351237))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 0)
       (if.null?
         (touch.gloc.of annotate)
         (push.const . \x2E;syntax/c0)
         (push.iloc.1 . 0)
         (push.const . quote)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
         (push.subr.gloc.of \x2E;list 3 "./boot/macro/syncase.scm" . 351237)
         (push.iloc 5 . 0)
         (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/c1)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.const . quote)
       (push.iloc 2 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 351237)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
     (iloc 2 . 0)
     (if.null?
       (touch.gloc.of annotate)
       (push.const . \x2E;syntax/c2)
       (push.iloc.1 . 0)
       (push.const . quote)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.const . quote)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
       (push.subr.gloc.of \x2E;list 4 "./boot/macro/syncase.scm" . 351237)
       (push.iloc 5 . 0)
       (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
     (touch.gloc.of annotate)
     (push.const . \x2E;syntax/c3)
     (push.iloc.1 . 0)
     (push.const . quote)
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
     (push.const . quote)
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
     (push.const . quote)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/syncase.scm" . 351237)
     (push.subr.gloc.of \x2E;list 5 "./boot/macro/syncase.scm" . 351237)
     (push.iloc 5 . 0)
     (apply.gloc.of annotate "./boot/macro/syncase.scm" . 351237))
   (push.const . syntax)
   (push.const . "expected exactly one datum")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/syncase.scm" . 351237))
 (set.gloc.of expand-syntax)
 (ret.const.unspec))
((close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of loop\x60;5)
       (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 408606)
       (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 408600))
     (push)
     (call
       (touch.gloc.of loop\x60;5)
       (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 408627)
       (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 408621))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "./boot/macro/syncase.scm" . 409636)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "./boot/macro/syncase.scm" . 409654)
       (ret.eq? "./boot/macro/syncase.scm" . 409647))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "./boot/macro/syncase.scm" . 410653))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 411663)
   (if.true
     (call
       (push.gloc.of loop\x60;5)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 412711)
       (apply.gloc.of map "./boot/macro/syncase.scm" . 412701))
     (push)
     (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 412687))
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 413711))
   (if.true
     (touch.gloc.of loop\x60;5)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 414741))
     (push)
     (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 414735))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . syntax->datum)
   (touch.gloc.of strip-rename-suffix)
   (call
     (touch.gloc.of loop\x60;5)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;5 "./boot/macro/syncase.scm" . 406534))
   (push)
   (apply.gloc.of strip-rename-suffix "./boot/macro/syncase.scm" . 406534))
 (set.gloc.of syntax->datum)
 (ret.const.unspec))
((close
   (2 0 . datum->syntax)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 419849))
   (if.false.call
     (push.const . datum->syntax)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 420909)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 420873))
   (call
     (touch.gloc.of retrieve-rename-suffix)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 421931))
     (push)
     (apply.gloc.of retrieve-rename-suffix "./boot/macro/syncase.scm" . 421907))
   (push)
   (call
     (call
       (touch.gloc.of syntax-object-renames)
       (push.iloc.0 . 0)
       (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 422939))
     (if.null?
       (touch.gloc.of current-expansion-environment)
       (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 423956))
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 424980))
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 4)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/syncase.scm" . 430119)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 430113))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 430136)
           (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 430130))
         (ret.cons "./boot/macro/syncase.scm" . 430107))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/syncase.scm" . 431131)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/macro/syncase.scm" . 432179)
           (apply.gloc.of map "./boot/macro/syncase.scm" . 432169))
         (push)
         (ret.subr.gloc.of list->vector "./boot/macro/syncase.scm" . 432155))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/syncase.scm" . 434210)
         (if.true.ret)
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/syncase.scm" . 436300)
         (push.iloc 2 . 0)
         (push.subr.gloc.of string-append 2 "./boot/macro/syncase.scm" . 436285)
         (push.subr.gloc.of string->symbol 1 "./boot/macro/syncase.scm" . 436269)
         (extend . 1)
         (push.iloc 3 . 2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/syncase.scm" . 437284)
         (call
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 3 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 438326))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq?
             (push.iloc 4 . 3)
             (push.iloc.1 . 0)
             (call
               (touch.gloc.of env-lookup)
               (push.iloc 4 . 1)
               (push.iloc 2 . 0)
               (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 441418))
             (push)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 441389))
           (push.iloc 4 . 3)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (ret.subr.gloc.of core-hashtable-set! "./boot/macro/syncase.scm" . 444461))
         (ret.iloc 0 . 0))
       (ret.iloc 0 . 0))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "./boot/macro/syncase.scm" . 428050))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.symbol?
     (touch.gloc.of make-syntax-object)
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 448563)
       (subr.gloc.of assq 2 "./boot/macro/syncase.scm" . 448553)
       (if.true.ret)
       (ret.const))
     (push)
     (push.const . #f)
     (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 448525))
   (touch.gloc.of make-syntax-object)
   (push.iloc.0 . 0)
   (push.iloc.1 . 3)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/syncase.scm" . 449573)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 449549))
 (set.gloc.of datum->syntax)
 (ret.const.unspec))
((close
   (1 0 . identifier?)
   (call
     (touch.gloc.of wrapped-syntax-object?)
     (push.iloc.0 . 0)
     (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 453642))
   (if.false.ret)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 454675))
   (push)
   (ret.subr.gloc.of symbol? "./boot/macro/syncase.scm" . 454666))
 (set.gloc.of identifier?)
 (ret.const.unspec))
((close
   (2 0 . bound-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 458761))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 459826)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 459785))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 460809))
   (if.false.call
     (push.const . bound-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 461874)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 461833))
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 462858))
   (push)
   (call
     (touch.gloc.of syntax-object-expr)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 462883))
   (ret.eq? "./boot/macro/syncase.scm" . 462853))
 (set.gloc.of bound-identifier=?)
 (ret.const.unspec))
((close
   (2 0 . free-identifier=?)
   (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 466953))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 468017)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 467977))
   (call (push.iloc.0 . 1) (apply.gloc.of identifier? "./boot/macro/syncase.scm" . 469001))
   (if.false.call
     (push.const . free-identifier=?)
     (push.const . "expected identifier, but got ~r")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 470065)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 470025))
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/syncase.scm" . 471060))
   (push)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/syncase.scm" . 472084))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 0)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 473106))
   (push)
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc.1 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/syncase.scm" . 474130))
   (push)
   (extend . 2)
   (call
     (iloc.0 . 0)
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 475185))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 475164))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/syncase.scm" . 476209))
     (push)
     (push.iloc.1 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/syncase.scm" . 476188))
   (push)
   (extend . 2)
   (call (iloc.1 . 0) (if.false.ret) (ret.iloc 1 . 1))
   (if.true (push.iloc.1 . 0) (iloc.1 . 1) (ret.eq? "./boot/macro/syncase.scm" . 477216))
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 478245))
     (push)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 478270))
     (ret.eq? "./boot/macro/syncase.scm" . 478240))
   (call
     (touch.gloc.of syntax-object-renames)
     (push.iloc 3 . 0)
     (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 480286))
   (push)
   (call
     (touch.gloc.of syntax-object-renames)
     (push.iloc 3 . 1)
     (apply.gloc.of syntax-object-renames "./boot/macro/syncase.scm" . 481310))
   (push)
   (extend . 2)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (iloc.0 . 1)
     (ret.pair? "./boot/macro/syncase.scm" . 482346))
   (if.true
     (push.cdr.iloc (0 . 0) "./boot/macro/syncase.scm" . 483357)
     (cdr.iloc (0 . 1) "./boot/macro/syncase.scm" . 483368)
     (ret.eq? "./boot/macro/syncase.scm" . 483352))
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 3 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 484381))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 3 . 1)
     (push.iloc.1 . 1)
     (apply.gloc.of env-lookup "./boot/macro/syncase.scm" . 484406))
   (ret.eq? "./boot/macro/syncase.scm" . 484376))
 (set.gloc.of free-identifier=?)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of make-syntax-object)
   (call (apply.gloc.of generate-temporary-symbol "./boot/macro/syncase.scm" . 490538))
   (push)
   (push.const)
   (push.const . #f)
   (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 490518))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0 . generate-temporaries)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/macro/syncase.scm" . 488457)
   (if.false.call
     (push.const . generate-temporaries)
     (push.const . "expected list, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/macro/syncase.scm" . 489524)
     (apply.gloc.of assertion-violation "./boot/macro/syncase.scm" . 489481))
   (push.gloc.of \x2E;fn2.1\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of map "./boot/macro/syncase.scm" . 490501))
 (set.gloc.of generate-temporaries)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer)
   (touch.gloc.of make-variable-transformer-token)
   (push.close
     (1 0)
     (call
       (call
         (touch.gloc.of wrapped-syntax-object?)
         (push.iloc.0 . 0)
         (apply.gloc.of wrapped-syntax-object? "./boot/macro/syncase.scm" . 496658))
       (if.true (ret.iloc 0 . 0))
       (touch.gloc.of make-syntax-object)
       (push.iloc.0 . 0)
       (push.const)
       (push.const . #f)
       (apply.gloc.of make-syntax-object "./boot/macro/syncase.scm" . 498706))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/syncase.scm" . 496648))
   (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 494597))
 (set.gloc.of make-variable-transformer)
 (ret.const.unspec))
((close
   (1 0 . make-variable-transformer-token)
   (push.const . type:variable-transformer-token)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/macro/syncase.scm" . 502789))
 (set.gloc.of make-variable-transformer-token)
 (ret.const.unspec))
((close
   (1 0 . variable-transformer-token?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 506890)
   (const . type:variable-transformer-token)
   (ret.eq? "./boot/macro/syncase.scm" . 506885))
 (set.gloc.of variable-transformer-token?)
 (ret.const.unspec))
((close
   (1 0)
   (push.close
     (1 0 . thunk)
     (push.close (0 0) (push.iloc.1 . 0) (apply.iloc (2 . 0) "./boot/macro/syncase.scm" . 513056))
     (push.gloc.of \x2E;fn1.1\x60;1)
     (apply.gloc.of call-with-values "./boot/macro/syncase.scm" . 512020))
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of procedure? 1 "./boot/macro/syncase.scm" . 518158)
   (if.true
     (push.close
       (0 0)
       (touch.gloc.of closure-arity)
       (push.iloc 2 . 0)
       (apply.gloc.of closure-arity "./boot/macro/syncase.scm" . 519208))
     (push.close
       (2 0)
       (iloc.0 . 0)
       (if.false.ret)
       (iloc.0 . 1)
       (if.false.ret)
       (=n.iloc (0 . 0) 1 "./boot/macro/syncase.scm" . 520223)
       (if.false.ret)
       (=n.iloc (0 . 1) 0 "./boot/macro/syncase.scm" . 520235)
       (if.false.ret)
       (ret.iloc 1 . 0))
     (apply.gloc.of \x2E;call-with-values "./boot/macro/syncase.scm" . 510981))
   (call
     (touch.gloc.of variable-transformer-token?)
     (push.iloc.1 . 0)
     (apply.gloc.of variable-transformer-token? "./boot/macro/syncase.scm" . 521230))
   (if.true
     (push.iloc.1 . 0)
     (push.const . 1)
     (subr.gloc.of tuple-ref 2 "./boot/macro/syncase.scm" . 522265)
     (set.iloc 1 . 0)
     (touch.gloc.of make-variable-transformer-token)
     (push.iloc.0 . 0)
     (apply.gloc.of make-variable-transformer-token "./boot/macro/syncase.scm" . 523278))
   (ret.iloc 1 . 0))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 1)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;flatten-syntax "./boot/macro/syncase.scm" . 516123))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 1) "./boot/macro/syncase.scm" . 517159)
   (ret.subr.gloc.of values "./boot/macro/syncase.scm" . 517147))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;transformer-thunk)
 (push.gloc.of \x2E;fn2.1\x60;2)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/syncase.scm" . 509955))

;
((call (push.const) (apply.gloc.of make-parameter "./boot/macro/library.scm" . 5150))
 (set.gloc.of scheme-library-paths)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 6176))
 (set.gloc.of scheme-library-exports)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (apply.gloc.of make-parameter "./boot/macro/library.scm" . 7201))
 (set.gloc.of scheme-library-versions)
 (ret.const.unspec))
((close
   (2 0 . symbol-list->string)
   (push.gloc.of string-append)
   (call
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 14371)
       (if.symbol?
         (push.iloc 2 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 16438)
         (push.subr.gloc.of symbol->string 1 "./boot/macro/library.scm" . 16422)
         (call
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 17452)
           (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 17446))
         (push)
         (subr.gloc.of cons 2 "./boot/macro/library.scm" . 16416)
         (ret.cons "./boot/macro/library.scm" . 15386))
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 19488)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 19482))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 12305))
   (push)
   (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 10243)
   (apply.gloc.of apply "./boot/macro/library.scm" . 10243))
 (set.gloc.of symbol-list->string)
 (ret.const.unspec))
((close
   (1 0 . generate-library-id)
   (touch.gloc.of library-name->id)
   (push.const . #f)
   (push.iloc.0 . 0)
   (apply.gloc.of library-name->id "./boot/macro/library.scm" . 23557))
 (set.gloc.of generate-library-id)
 (ret.const.unspec))
((close
   (2 0 . library-name->id)
   (extend.enclose
     (0 0)
     (iloc 2 . 0)
     (if.true
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 31809))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 31757))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 32781))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 34830)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 34848)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 34843))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 35853))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.1 . 1)
         (push.const . "~a")
         (subr.gloc.of current-library-infix 0)
         (push)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 36919)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 36893))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 36877))
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 37932)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 37929)
     (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 37913)
     (extend . 1)
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 38931))
     (if.true
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc.0 . 0)
         (push.const . "~a")
         (subr.gloc.of current-library-infix 0)
         (push)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 39997)
         (apply.gloc.of symbol-list->string "./boot/macro/library.scm" . 39971))
       (push)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 39955))
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 40979))
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 41993))
 (set.gloc.of library-name->id)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 55310)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 55325)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 55338))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (2 0 . library-name->version)
   (extend.enclose
     (0 0)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 50244))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 50189))
     (push.const . library)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 51213))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 57358)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 57376)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 57371))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 58384))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 60468)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 60465)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 60449)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 60444)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . #f)
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 62494)
       (if.false.ret)
       (touch.gloc.of every1)
       (push.gloc.of exact-nonnegative-integer?\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 62507))
     (if.true (ret.iloc 0 . 0))
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 63518))
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 64521))
 (set.gloc.of library-name->version)
 (ret.const.unspec))
((close
   (2 0 . library-reference->name)
   (extend.enclose
     (0 0)
     (iloc 2 . 0)
     (if.pair?
       (push.const . library)
       (push.const . "malformed library name")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 72769))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 72717))
     (push.const . library)
     (push.const . "malformed library name")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 73741))
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.1 . 1)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 75788))
   (if.true (ret.iloc 1 . 1))
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 77866)
   (push.const . 1)
   (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 77863)
   (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 77848)
   (extend . 1)
   (call
     (touch.gloc.of every1)
     (push.gloc.of symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 78869))
   (if.true (ret.iloc 0 . 0))
   (apply.iloc (1 . 0) "./boot/macro/library.scm" . 79898))
 (set.gloc.of library-reference->name)
 (ret.const.unspec))
((close
   (2 0 . flatten-library-reference)
   (call
     (call
       (push.iloc.0 . 1)
       (subr.gloc.of list? 1 "./boot/macro/library.scm" . 83982)
       (if.false.ret)
       (push.iloc.0 . 1)
       (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 83999)
       (ret.subr.gloc.of not "./boot/macro/library.scm" . 83994))
     (if.true.ret)
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 85053))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 85001))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (if.not.null?.ret.const . #f)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 83973)
     (if.false.ret)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (touch.gloc.of flatten-library-reference)
     (push.iloc.0 . 0)
     (push.cadr.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 83973))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 1) "./boot/macro/library.scm" . 83973)
     (const . library)
     (ret.eq? "./boot/macro/library.scm" . 83973))
   (if.true
     (push.const . library)
     (push.const . "malformed library name")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc.0 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 83973))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 83973))
   (ret.iloc 0 . 1))
 (set.gloc.of flatten-library-reference)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 102414)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 102429)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 102442))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (2 0 . library-reference->version)
   (extend.enclose
     (0 0)
     (iloc 2 . 0)
     (if.pair?
       (push.const . import)
       (push.const . "malformed library version")
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 2 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 97347))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 97293))
     (push.const . import)
     (push.const . "malformed library version")
     (push.iloc 2 . 1)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 98317))
   (call
     (push.iloc.1 . 1)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 104462)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.subr.gloc.of null? 1 "./boot/macro/library.scm" . 104479)
     (ret.subr.gloc.of not "./boot/macro/library.scm" . 104474))
   (if.true
     (call
       (touch.gloc.of every1)
       (push.gloc.of symbol?)
       (push.iloc.1 . 1)
       (apply.gloc.of every1 "./boot/macro/library.scm" . 105488))
     (if.true.ret.const . #f)
     (push.iloc.1 . 1)
     (push.iloc.1 . 1)
     (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 106552)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/macro/library.scm" . 106549)
     (push.subr.gloc.of list-tail 2 "./boot/macro/library.scm" . 106534)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 106529)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 107550)
     (if.true (ret.iloc 0 . 0))
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 108579))
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 109577))
 (set.gloc.of library-reference->version)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (subr.gloc.of integer? 1 "./boot/macro/library.scm" . 116750)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of exact? 1 "./boot/macro/library.scm" . 116765)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of >= "./boot/macro/library.scm" . 116778))
 (set.gloc.of exact-nonnegative-integer?\x60;2)
 (close
   (4 0 . test-library-versions)
   (call
     (extend.enclose
       (1 0 . loop)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 119819)
         (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
       (push)
       (extend . 1)
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . not)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
           (apply.iloc (2 . 0) "./boot/macro/library.scm" . 119819))
         (push)
         (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . or)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (const . and)
         (ret.eq? "./boot/macro/library.scm" . 119819))
       (if.true
         (touch.gloc.of every1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 119819))
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 119819)
         (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
       (extend.enclose
         (2 0 . loop)
         (call
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/macro/library.scm" . 119819)
             (if.false.ret)
             (push.iloc.0 . 1)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
           (if.true.ret)
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 5 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (iloc.0 . 1)
         (if.null?.ret.const . #t)
         (push.iloc.0 . 0)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (subr.gloc.of >= 2 "./boot/macro/library.scm" . 119819)
         (if.false.ret)
         (touch.gloc.of every2)
         (push.close
           (2 0)
           (call
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.cdr.iloc (0 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of list? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.1 . 1)
             (if.not.pair?.ret.const . #f)
             (cdr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (if.not.pair?.ret.const . #f)
             (cddr.iloc (1 . 1) "./boot/macro/library.scm" . 119819)
             (ret.null? "./boot/macro/library.scm" . 119819))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . not)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (call
               (push.iloc 2 . 0)
               (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
               (apply.iloc (4 . 0) "./boot/macro/library.scm" . 119819))
             (push)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . >=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of >= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.0 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . <=)
             (if.not.eq?.ret.const . #f)
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.cadr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (ret.subr.gloc.of <= "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . and)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of every1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of every1 "./boot/macro/library.scm" . 119819))
           (call
             (iloc.1 . 0)
             (if.false.ret)
             (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (const . or)
             (ret.eq? "./boot/macro/library.scm" . 119819))
           (if.true
             (touch.gloc.of any1)
             (push.close
               (1 0)
               (push.iloc 3 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (push.iloc.0 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 119819)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 119819))
             (push.cdr.iloc (2 . 1) "./boot/macro/library.scm" . 119819)
             (apply.gloc.of any1 "./boot/macro/library.scm" . 119819))
           (call
             (touch.gloc.of exact-nonnegative-integer?\x60;2)
             (push.iloc 2 . 1)
             (apply.gloc.of exact-nonnegative-integer?\x60;2 "./boot/macro/library.scm" . 119819))
           (if.true
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (ret.subr.gloc.of = "./boot/macro/library.scm" . 119819))
           (push.const . import)
           (push.const . "malformed version reference")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 8 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 119819))
           (push)
           (push.iloc 8 . 1)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 119819))
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of length 1 "./boot/macro/library.scm" . 119819)
         (push.subr.gloc.of list-head 2 "./boot/macro/library.scm" . 119819)
         (push.iloc.0 . 1)
         (apply.gloc.of every2 "./boot/macro/library.scm" . 119819))
       (push.iloc 4 . 3)
       (push.iloc 2 . 0)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 119819))
     (push.iloc.1 . 2)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 118793))
   (if.true.ret)
   (push.const . import)
   (push.const . "mismatch between version reference ~a and current version ~a")
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 142363)
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 143387))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 141321))
 (set.gloc.of test-library-versions)
 (ret.const.unspec))
((close
   (1 0 . make-shield-id-table)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (call
     (touch.gloc.of make-unbound)
     (apply.gloc.of make-unbound "./boot/macro/library.scm" . 147500))
   (push)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 148510))
     (push.gloc.of coreform-primitives)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 148487))
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 151574)
           (apply.iloc (1 . 0) "./boot/macro/library.scm" . 151568))
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 152598)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 152592))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 154640))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 155664)
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 156694)
         (apply.iloc (1 . 0) "./boot/macro/library.scm" . 156688))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 149511))
   (ret.iloc 0 . 0))
 (set.gloc.of make-shield-id-table)
 (ret.const.unspec))
((close
   (3 0 . verify-no-unbound-id)
   (extend.enclose
     (1 0)
     (push.close
       (1 0)
       (extend.enclose
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq?.ret.const . #t)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 169002)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 168996)
         (if.true.ret.const . #f)
         (call
           (touch.gloc.of any1)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 170015))
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 171039))
       (call
         (push.car.iloc (4 . 1) "./boot/macro/library.scm" . 165933)
         (const . begin)
         (if.eq? (push.iloc 4 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 165951))
         (ret.iloc 4 . 1))
       (push)
       (apply.iloc (0 . 0) "./boot/macro/library.scm" . 165908))
     (apply.gloc.of call/cc "./boot/macro/library.scm" . 163847))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (call
       (push.car.iloc (2 . 1) "./boot/macro/library.scm" . 174112)
       (const . begin)
       (if.eq? (push.iloc 2 . 1) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 174130))
       (ret.iloc 2 . 1))
     (push)
     (extend . 1)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 175134))
       (iloc.0 . 0)
       (if.pair?
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 177178)
         (push.const lambda quote)
         (subr.gloc.of memq 2 "./boot/macro/library.scm" . 177172)
         (if.true.ret)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of for-each "./boot/macro/library.scm" . 178196))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc (0 . 0) "./boot/macro/library.scm" . 174087))
   (call
     (touch.gloc.of every1)
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 180262)
       (subr.gloc.of current-primitive-prefix 0)
       (push)
       (subr.gloc.of symbol-contains 2 "./boot/macro/library.scm" . 180245)
       (if.true.ret)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 181286)
       (subr.gloc.of current-rename-delimiter 0)
       (push)
       (subr.gloc.of symbol-contains 2 "./boot/macro/library.scm" . 181269)
       (if.true.ret)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 182310)
       (subr.gloc.of current-library-suffix 0)
       (push)
       (subr.gloc.of symbol-contains 2 "./boot/macro/library.scm" . 182293)
       (if.true.ret)
       (push.iloc 3 . 2)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 183351)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 183317)
       (if.true.ret)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 184347)
       (push.gloc.of coreform-primitives)
       (subr.gloc.of memq 2 "./boot/macro/library.scm" . 184341)
       (if.true.ret)
       (call
         (touch.gloc.of current-macro-expression)
         (push.const . #f)
         (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 186391))
       (touch.gloc.of undefined/syntax-violation)
       (push.const . #f)
       (push.const . "attempt to reference unbound variable ~u")
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 188518)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 188467)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 189491))
       (push)
       (call
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 190532)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 190515))
       (push)
       (apply.gloc.of undefined/syntax-violation "./boot/macro/library.scm" . 187415))
     (push.iloc.0 . 0)
     (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 191503)
     (apply.gloc.of every1 "./boot/macro/library.scm" . 179207))
   (ret.iloc 2 . 1))
 (set.gloc.of verify-no-unbound-id)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (cadr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
   (ret.cons "./boot/macro/library.scm" . 197639))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 197639))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 197639))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (2 0 . parse-exports)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of reverse "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (call
         (touch.gloc.of acons)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
         (push.iloc.0 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 197639))
       (push)
       (apply.iloc+ (1 . 0) "./boot/macro/library.scm" . 197639))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 197639)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 197639))
     (if.true
       (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
       (push.iloc.0 . 0)
       (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 197639)
       (extend . 2)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of \x2E;fn3.1\x60;3)
           (push.iloc.0 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 197639))
         (if.true.ret)
         (push.const . export)
         (push.const . "malformed export spec")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 197639)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
       (push.iloc.0 . 0)
       (call
         (push.gloc.of \x2E;fn1.1\x60;1)
         (push.iloc.0 . 1)
         (apply.gloc.of map "./boot/macro/library.scm" . 197639))
       (push)
       (push.iloc.1 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 197639)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 197639))
     (push.const . export)
     (push.const . "malformed export spec")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 2 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 197639))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 197639)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 197639))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 196613))
 (set.gloc.of parse-exports)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (touch.gloc.of safe-length)
     (push.iloc.0 . 0)
     (apply.gloc.of safe-length "./boot/macro/library.scm" . 231431))
   (push)
   (push.const . 2)
   (ret.subr.gloc.of = "./boot/macro/library.scm" . 231431))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . parse-imports)
   (extend.unbound . 2)
   (push.close
     (3 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 219161)
       (if.true.ret)
       (push.const . import)
       (push.const . "attempt to reference unexported identifier ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 220211)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 220271))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 220185))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 218121))
   (push.close
     (3 0)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of assq 2 "./boot/macro/library.scm" . 226330)
       (if.false.ret)
       (push.const . import)
       (push.const . "duplicate import identifiers ~a")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 227380)
       (call
         (touch.gloc.of abbreviated-take-form)
         (push.iloc 3 . 0)
         (push.const . 4)
         (push.const . 8)
         (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 227426))
       (push)
       (push.iloc.1 . 2)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 227354))
     (push.iloc.0 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 225289))
   (enclose . 2)
   (extend.enclose
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/library.scm" . 231431)
       (ret.pair? "./boot/macro/library.scm" . 231431))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 231431)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 231431)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (ret.subr.gloc.of memq "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 231431)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (touch.gloc.of filter)
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of memq 2 "./boot/macro/library.scm" . 231431)
           (ret.subr.gloc.of not "./boot/macro/library.scm" . 231431))
         (push.iloc.0 . 0)
         (apply.gloc.of filter "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 231431)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (push.iloc.1 . 0)
       (push.subr.gloc.of cddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 2)
       (call
         (push.iloc 2 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 231431)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
         (push.const)
         (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (touch.gloc.of every1)
           (push.gloc.of \x2E;fn2.1\x60;2)
           (push.iloc.1 . 1)
           (apply.gloc.of every1 "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "malformed import set")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (call
           (call
             (touch.gloc.of unique-id-list?)
             (call
               (push.gloc.of car)
               (push.iloc.1 . 1)
               (apply.gloc.of map "./boot/macro/library.scm" . 231431))
             (push)
             (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
           (if.false.ret)
           (touch.gloc.of unique-id-list?)
           (call
             (push.gloc.of cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of map "./boot/macro/library.scm" . 231431))
           (push)
           (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 231431))
         (if.true.ret)
         (push.const . import)
         (push.const . "duplicate identifers in rename specs")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 6 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of cadr)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 1) "./boot/macro/library.scm" . 231431))
       (call
         (push.iloc.0 . 0)
         (call
           (push.gloc.of car)
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 231431))
         (push)
         (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 231431)
         (apply.iloc (5 . 0) "./boot/macro/library.scm" . 231431))
       (push.iloc.1 . 0)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.iloc 2 . 1)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 231431)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
             (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
             (ret.cons "./boot/macro/library.scm" . 231431))
           (ret.iloc 1 . 0))
         (push.iloc.0 . 0)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 3 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (4 . 0) "./boot/macro/library.scm" . 231431))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/library.scm" . 231431)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of cdddar 1 "./boot/macro/library.scm" . 231431)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 231431)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 231431))
     (if.true
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddar 1 "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
       (call
         (push.close
           (1 0)
           (push.const . "~a~a")
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of format 3 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of string->symbol 1 "./boot/macro/library.scm" . 231431)
           (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 231431)
           (ret.cons "./boot/macro/library.scm" . 231431))
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 231431)
           (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 231431)
           (push.const)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
         (push)
         (apply.gloc.of map "./boot/macro/library.scm" . 231431))
       (push)
       (push.iloc 2 . 1)
       (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 231431)
       (apply.iloc (3 . 0) "./boot/macro/library.scm" . 231431))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
       (extend . 1)
       (call
         (touch.gloc.of flatten-library-reference)
         (push.iloc 5 . 0)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 231431)
         (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 231431))
       (push)
       (call
         (touch.gloc.of library-reference->version)
         (push.iloc 6 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-reference->version "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of \x2E;require-scheme-library "./boot/macro/library.scm" . 231431))
       (call
         (touch.gloc.of library-name->id)
         (push.iloc 7 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of library-name->id "./boot/macro/library.scm" . 231431))
       (push)
       (extend . 1)
       (call
         (call
           (iloc.1 . 1)
           (if.false.ret)
           (call
             (touch.gloc.of scheme-library-versions)
             (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 231431))
           (push)
           (push.iloc.0 . 0)
           (push.const . #f)
           (ret.subr.gloc.of core-hashtable-ref "./boot/macro/library.scm" . 231431))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of test-library-versions)
           (push.iloc 9 . 0)
           (push.iloc 3 . 0)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of test-library-versions "./boot/macro/library.scm" . 231431))
         (ret.const.unspec))
       (push.iloc 3 . 0)
       (call
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 231431)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (push.iloc 6 . 1)
           (ret.subr.gloc.of append "./boot/macro/library.scm" . 231431))
         (push.const . import)
         (push.const . "attempt to import undefined library")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 9 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
         (push)
         (push.iloc 2 . 0)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
       (push)
       (apply.iloc (6 . 0) "./boot/macro/library.scm" . 231431))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 4 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 231431))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 231431)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 231431))
   (push.iloc 2 . 1)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 230405))
 (set.gloc.of parse-imports)
 (ret.const.unspec))
((close
   (2 0 . parse-depends)
   (extend.enclose+
     (2 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of cdar 1 "./boot/macro/library.scm" . 292871)
       (ret.pair? "./boot/macro/library.scm" . 292871))
     (push)
     (extend . 1)
     (iloc.1 . 0)
     (if.null? (ret.iloc 1 . 1))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 292871)
       (const . for)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 292871)
       (const . only)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 292871)
       (const . except)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 292871)
       (const . rename)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc.1 . 0)
       (subr.gloc.of cddar 1 "./boot/macro/library.scm" . 292871)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (subr.gloc.of cdddar 1 "./boot/macro/library.scm" . 292871)
       (if.not.null?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 292871)
       (const . prefix)
       (ret.eq? "./boot/macro/library.scm" . 292871))
     (if.true
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 292871)
         (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 292871)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
       (push)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (iloc.1 . 0)
     (if.pair?
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
       (call
         (touch.gloc.of library-reference->name)
         (push.iloc 3 . 0)
         (call
           (touch.gloc.of flatten-library-reference)
           (push.iloc 3 . 0)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
           (apply.gloc.of flatten-library-reference "./boot/macro/library.scm" . 292871))
         (push)
         (apply.gloc.of library-reference->name "./boot/macro/library.scm" . 292871))
       (push)
       (iloc.1 . 1)
       (push.cons)
       (apply.iloc+ (2 . 0) "./boot/macro/library.scm" . 292871))
     (push.const . import)
     (push.const . "malformed import set")
     (call
       (touch.gloc.of abbreviated-take-form)
       (push.iloc 3 . 0)
       (push.const . 4)
       (push.const . 8)
       (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 292871))
     (push)
     (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 292871)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 292871))
   (push.iloc.1 . 1)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/macro/library.scm" . 291845))
 (set.gloc.of parse-depends)
 (ret.const.unspec))
((close
   (1 0)
   (touch.gloc.of loop\x60;8)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 317465)
   (push.const)
   (push.const)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 317449))
 (set.gloc.of permute-env\x60;2)
 (close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 319506))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 320540)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 320530))
   (if.true
     (touch.gloc.of loop\x60;8)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 321560)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 321583)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 321554))
   (touch.gloc.of loop\x60;8)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 323608)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 323624)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 323602))
 (set.gloc.of loop\x60;8)
 (close
   (2 0 . expand-library)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (cddr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cadddr 1 "./boot/macro/library.scm" . 315397)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdaddr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cddddr 1 "./boot/macro/library.scm" . 315397)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 315397)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caaddr 1 "./boot/macro/library.scm" . 315397)
     (const . export)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of car 1 "./boot/macro/library.scm" . 315397)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 315397))
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of cddddr 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/macro/library.scm" . 315397)
     (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 315397)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdaddr 1 "./boot/macro/library.scm" . 315397)
     (push.cadr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
     (extend . 4)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc.1 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 315397))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of parse-exports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 2)
       (apply.gloc.of parse-exports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 315397))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 315397))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 6)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc.1 . 5)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (push.const . #f)
           (subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
           (if.false.ret)
           (push.const . library)
           (push.const . "duplicate export identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 4 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc.1 . 5)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 4)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 315397)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (if.eq?.ret.const . #t)
           (push.const . library)
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 5 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
         (push.iloc 2 . 4)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.0 . 1)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 315397))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 315397)
         (push.iloc.1 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 315397)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 315397))
       (push.iloc.1 . 4)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 315397)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 315397))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 3 . 3)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.iloc 6 . 0)
       (call
         (touch.gloc.of expand-library-body)
         (push.iloc 6 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc 5 . 0)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of permute-env\x60;2)
             (push.iloc 2 . 0)
             (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 315397))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 315397))
         (push)
         (call
           (touch.gloc.of permute-env\x60;2)
           (push.iloc 2 . 1)
           (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 315397))
         (push)
         (apply.gloc.of expand-library-body "./boot/macro/library.scm" . 315397))
       (push)
       (push.iloc 3 . 4)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 315397))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 315397))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 315397))
   (push.const . library)
   (push.const . "expected library name, export spec, and import spec")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.0 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 315397))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 315397))
 (set.gloc.of expand-library)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . \x2E;require-scheme-library)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 434200)
   (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 434200))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (3 0)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 399390))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 399373))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 400424))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 400407))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 401430)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 403502)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 403493)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 405550)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 407635)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 407608)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 407608))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 408632))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 406566))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 411702))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 412726))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 410660))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 413718)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 415790)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 415781)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 417838)
       (extend . 1)
       (push.const . library)
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 419923)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 419896)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 419896))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 420920))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 418854))
     (push.const . library)
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 424017)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 423990)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 423990))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 425041)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 425014)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 425014))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 422948))
   (push.const . library)
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 427030))
 (set.gloc.of check-duplicate-definition\x60;2)
 (close
   (9 0 . expand-library-body)
   (extend.unbound . 6)
   (push.close
     (1 0)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 0) "./boot/macro/library.scm" . 373781)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caar 1 "./boot/macro/library.scm" . 374807)
     (if.not.symbol?.ret.const . #f)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 7)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 375850)
       (apply.gloc.of env-lookup "./boot/macro/library.scm" . 375834))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of macro?)
       (push.iloc.0 . 0)
       (apply.gloc.of macro? "./boot/macro/library.scm" . 376852))
     (if.true.ret)
     (push.gloc.of denote-define)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-define-macro)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-let-syntax)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (push.gloc.of denote-letrec-syntax)
     (iloc.0 . 0)
     (ret.eq? "./boot/macro/library.scm" . 381972))
   (push.const)
   (push.close
     (2 0)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 388110))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of acons "./boot/macro/library.scm" . 389151))
       (set.iloc 1 . 1)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 390175)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 390163))
     (set.iloc 2 . 7)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 391209)
       (push.iloc 3 . 7)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 391199))
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 391177))
   (push.close
     (2 0)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 395298)
       (push.iloc 2 . 8)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 395286))
     (set.iloc 2 . 8)
     (ret.const.unspec))
   (push.close
     (4 0)
     (call
       (touch.gloc.of check-duplicate-definition\x60;2)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of check-duplicate-definition\x60;2 "./boot/macro/library.scm" . 431113))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 7)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 432158))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn3.1\x60;3)
       (push.iloc 3 . 6)
       (apply.gloc.of map "./boot/macro/library.scm" . 434195))
     (push)
     (extend . 1)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 439365)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 440348))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 440348))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 440370)
           (push.iloc 5 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 440364)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 440359)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 441396)
             (push.iloc 7 . 7)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 441383))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 442398))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 440348))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 440348))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 440348))
       (push.iloc 2 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 438291))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 2)
       (if.null? (ret.const))
       (subr.gloc.of make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (extend.enclose
           (1 0 . loop)
           (iloc.0 . 0)
           (if.pair?
             (call
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 450612)
               (apply.iloc (1 . 0) "./boot/macro/library.scm" . 450606))
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 450629)
             (apply.iloc (1 . 0) "./boot/macro/library.scm" . 450623))
           (iloc.0 . 0)
           (if.symbol?
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (push.const . #t)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 451632))
           (push.iloc.0 . 0)
           (subr.gloc.of vector? 1 "./boot/macro/library.scm" . 452642)
           (if.true
             (push.iloc.0 . 0)
             (push.subr.gloc.of vector->list 1 "./boot/macro/library.scm" . 452662)
             (apply.iloc (1 . 0) "./boot/macro/library.scm" . 452656))
           (ret.const.unspec))
         (call
           (push.gloc.of caddr)
           (push.iloc 5 . 2)
           (apply.gloc.of map "./boot/macro/library.scm" . 449577))
         (push)
         (apply.iloc (0 . 0) "./boot/macro/library.scm" . 449561))
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 454703)
           (push.iloc 7 . 8)
           (subr.gloc.of assq 2 "./boot/macro/library.scm" . 454697)
           (if.true.ret)
           (call
             (touch.gloc.of env-lookup)
             (push.iloc 7 . 7)
             (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 455749)
             (apply.gloc.of env-lookup "./boot/macro/library.scm" . 455733))
           (push)
           (extend . 1)
           (call
             (iloc.0 . 0)
             (if.not.symbol?.ret.const . #f)
             (push.iloc.0 . 0)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 456786)
             (push.subr.gloc.of eq? 2 "./boot/macro/library.scm" . 456776)
             (ret.subr.gloc.of not "./boot/macro/library.scm" . 456771))
           (if.true
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 457791)
             (call
               (touch.gloc.of make-import)
               (push.iloc.0 . 0)
               (apply.gloc.of make-import "./boot/macro/library.scm" . 457799))
             (push)
             (apply.iloc (7 . 3) "./boot/macro/library.scm" . 457775))
           (ret.const.unspec))
         (push.iloc.0 . 0)
         (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 458787)
         (apply.gloc.of for-each "./boot/macro/library.scm" . 453657))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 461867))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (push.iloc 3 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 466016)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 465978)
             (if.false.ret)
             (push.iloc.1 . 0)
             (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 467026)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 467034)
             (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 467002))
           (push.iloc 8 . 8)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 468019)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 464937))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 469033))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 461849)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 461849)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 461849)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 471101)
           (push.iloc 6 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 471095)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 471090)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 473140)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 472116)
           (const . template)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 475180)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 475180)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 475180))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 472116)
           (const . procedure)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 476204)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 476204))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 472116)
           (const . variable)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 477228)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 477228))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 478258))
         (push.iloc 5 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 461849))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 461849)
       (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 461849))
     (push)
     (extend . 1)
     (push.const . \x2E;intern-scheme-library)
     (push.const . quote)
     (push.iloc 6 . 1)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 480274)
     (push.const . quote)
     (push.iloc 6 . 2)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 480274)
     (push.const . quote)
     (call
       (push.close
         (1 0)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 486438)
         (call
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 487475)
           (push.iloc 5 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 487469)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (touch.gloc.of make-import)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 487520)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 487507))
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 488499)
           (push.iloc 8 . 5)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 488493)
           (extend . 1)
           (iloc.0 . 0)
           (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/macro/library.scm" . 487462))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 490541))
           (push.const . library)
           (push.const . "attempt to export unbound identifier ~u")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 492657)
           (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 492607)
           (push.iloc 9 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 493631)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 491565))
         (ret.cons "./boot/macro/library.scm" . 485406))
       (push.iloc 6 . 4)
       (apply.gloc.of map "./boot/macro/library.scm" . 433163))
     (push)
     (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 433163)
     (push.subr.gloc.of \x2E;list 4 "./boot/macro/library.scm" . 433163)
     (extend . 1)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc 2 . 0)
           (apply.gloc.of map "./boot/macro/library.scm" . 495641))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc 2 . 0)
           (apply.gloc.of map "./boot/macro/library.scm" . 496672))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 497686))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 499777)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 499785)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 499796))
           (push.iloc 6 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 499749))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 500765))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 502831)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 504922)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 504892))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 505916))
           (push.iloc 7 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 503855))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 501789))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc 3 . 0)
     (push.iloc 2 . 0)
     (push.iloc 4 . 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 507917)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 507917)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 507917)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 507917)
     (subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 507917)
     (push.cons)
     (push.iloc 7 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 507917))
   (enclose . 5)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 516132)
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 5)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 518215)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 518171))
     (push.iloc.1 . 5)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 518149))
   (extend.enclose
     (4 0 . loop)
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 520231)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 520252)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 520243))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 7)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 521258)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 521242))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 7)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 523293))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 523287))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 525335)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdar 1 "./boot/macro/library.scm" . 525335)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cddar 1 "./boot/macro/library.scm" . 525335)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdddar 1 "./boot/macro/library.scm" . 525335)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 525335)
           (subr.gloc.of list? 1 "./boot/macro/library.scm" . 525335)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 525335)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 525335))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 525335)
           (push.iloc.1 . 0)
           (push.subr.gloc.of caddar 1 "./boot/macro/library.scm" . 525335)
           (push.iloc.1 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 525335)
           (extend . 3)
           (call
             (push.iloc 4 . 5)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 525335)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 525335)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 525335))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 525335)
             (push.iloc.1 . 1)
             (push.iloc 6 . 7)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 525335))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 525335))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 525335))
               (push)
               (apply.iloc (6 . 3) "./boot/macro/library.scm" . 525335))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 525335)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 525335))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 525335))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 525335)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 525335)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 525335))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 525335))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 525335))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 525335)
                   (push.iloc 7 . 7)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 525335))
                 (push)
                 (apply.iloc (6 . 2) "./boot/macro/library.scm" . 525335))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 525335)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 525335)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 525335))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 525335))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 7)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 525335))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 525335))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 525335)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 525335))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 525335))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 525335))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 525335)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 525335))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 545857)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 545841))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 545836)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 545870)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 545826))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 5)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 546895)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 546846)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 547934)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 547870))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 548900)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 549955)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 549924))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 550939))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 551983))
           (push)
           (apply.iloc (5 . 3) "./boot/macro/library.scm" . 551963))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 552993)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 553027))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 552987))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 555065)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 555043))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 555077)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 555031))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 556059))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 558107))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 559174)
           (push.iloc 5 . 7)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 559152))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 7)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 561209)
             (push.iloc 5 . 7)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 561194))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.null?
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 563240)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 563234))
           (call (push.iloc.0 . 0) (apply.iloc (5 . 0) "./boot/macro/library.scm" . 564258))
           (if.true
             (push.iloc.0 . 0)
             (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 565306)
             (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 565288)
             (push.iloc 3 . 1)
             (push.iloc 3 . 2)
             (push.iloc 3 . 3)
             (apply.iloc (4 . 0) "./boot/macro/library.scm" . 565282))
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 567349)
           (push.iloc 3 . 2)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 567364)
           (push.iloc 3 . 3)
           (apply.iloc (5 . 4) "./boot/macro/library.scm" . 567330))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 521230))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 569386)
       (push.iloc.1 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 569401)
       (push.iloc.1 . 3)
       (apply.iloc (3 . 4) "./boot/macro/library.scm" . 569367))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 571425)
     (push.iloc.0 . 2)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 571440)
     (push.iloc.0 . 3)
     (apply.iloc (2 . 4) "./boot/macro/library.scm" . 571406))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 7)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 519190))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 519173))
 (set.gloc.of expand-library-body)
 (ret.const.unspec))
((close
   (1 0)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 576543)
   (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 576566)
   (extend . 2)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq?.ret.const . #t)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-delete! 2 "./boot/macro/library.scm" . 579609)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/macro/library.scm" . 580637)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const.undef)
     (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 580663))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 581664)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 582706))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/macro/library.scm" . 583746)
   (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 583717))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0 . import-top-level-bindings)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/macro/library.scm" . 574467))
 (set.gloc.of import-top-level-bindings)
 (ret.const.unspec))
((close
   (2 0 . expand-import)
   (call
     (call
       (touch.gloc.of unexpect-top-level-form)
       (apply.gloc.of unexpect-top-level-form "./boot/macro/library.scm" . 588810))
     (if.false.ret)
     (push.const . import)
     (push.const . "misplaced top-level directive")
     (push.iloc.0 . 0)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 589834))
   (call
     (touch.gloc.of auto-compile-cache-update)
     (apply.gloc.of auto-compile-cache-update "./boot/macro/library.scm" . 590853))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 593978)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 593946)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 596013)
         (if.eq?.ret.const . #t)
         (push.const . import)
         (push.const . "duplicate import identifiers")
         (call
           (touch.gloc.of abbreviated-take-form)
           (push.iloc 3 . 0)
           (push.const . 4)
           (push.const . 8)
           (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 597084))
         (push)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 597117)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 597027))
       (push.iloc 2 . 0)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 599099)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 599107)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 599066))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 591912)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 591892))
     (push)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 591877))
   (touch.gloc.of import-top-level-bindings)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 601122)
   (apply.gloc.of import-top-level-bindings "./boot/macro/library.scm" . 601095))
 (set.gloc.of expand-import)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (call
       (touch.gloc.of generate-library-id)
       (push.iloc.0 . 0)
       (apply.gloc.of generate-library-id "./boot/macro/library.scm" . 605207))
     (push)
     (extend . 1)
     (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 606250))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 606230)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . pending)
     (if.eq?
       (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 608293))
       (push)
       (push.iloc.1 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 608272)
       (push.const . library)
       (push.const . "encountered cyclic dependencies")
       (push.iloc 2 . 0)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 609296))
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 613416))
         (push)
         (push.iloc 2 . 0)
         (push.const . pending)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 613395))
       (push.close
         (0 0)
         (touch.gloc.of load-scheme-library)
         (push.iloc 3 . 0)
         (push.const . #f)
         (apply.gloc.of load-scheme-library "./boot/macro/library.scm" . 615443))
       (push.close
         (0 0)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 617521))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 617501)
         (const . pending)
         (if.not.eq?.ret.const . #f)
         (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 618541))
         (push)
         (push.iloc 2 . 0)
         (push.const . #f)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 618520))
       (apply.gloc.of dynamic-wind "./boot/macro/library.scm" . 611344))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;require-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 604163))
((call
   (push.const . equal?)
   (push.subr.gloc.of make-core-hashtable 1 "./boot/macro/library.scm" . 622621)
   (extend . 1)
   (ret.close
     (1 0 . unify-import-bindings)
     (push.close
       (1 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 625685)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of values "./boot/macro/library.scm" . 625678))
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 627740)
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of map "./boot/macro/library.scm" . 624647)))
 (set.gloc.of unify-import-bindings)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of scheme-library-versions)
       (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 632879))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 632858))
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 633882))
   (push)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of unify-import-bindings)
     (push.iloc.0 . 2)
     (apply.gloc.of unify-import-bindings "./boot/macro/library.scm" . 633918))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 633861))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;intern-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 630785))
((close
   (1 0)
   (call (apply.gloc.of scheme-library-exports "./boot/macro/library.scm" . 637981))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of core-hashtable-delete! "./boot/macro/library.scm" . 637957))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const . \x2E;unintern-scheme-library)
 (push.gloc.of \x2E;fn1.1\x60;1)
 (ret.subr.gloc.of set-top-level-value! "./boot/macro/library.scm" . 635905))
((close
   (3 0 . loop)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of append "./boot/macro/library.scm" . 652306))
   (call
     (touch.gloc.of unbound?)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 653340)
     (apply.gloc.of unbound? "./boot/macro/library.scm" . 653330))
   (if.true
     (touch.gloc.of loop\x60;8)
     (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 654360)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 654383)
     (iloc.0 . 2)
     (push.cons)
     (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 654354))
   (touch.gloc.of loop\x60;8)
   (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 656408)
   (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 656424)
   (iloc.0 . 1)
   (push.cons)
   (push.iloc.0 . 2)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 656402))
 (set.gloc.of loop\x60;8)
 (close
   (1 0)
   (touch.gloc.of loop\x60;8)
   (push.iloc.0 . 0)
   (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 650265)
   (push.const)
   (push.const)
   (apply.gloc.of loop\x60;8 "./boot/macro/library.scm" . 650249))
 (set.gloc.of permute-env\x60;2)
 (close
   (2 0 . expand-top-level-program)
   (extend.unbound . 1)
   (push.const \x2E;R6RS-TOP)
   (enclose . 1)
   (call
     (iloc.1 . 0)
     (if.not.pair?.ret.const . #f)
     (car.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
     (if.not.pair?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 648197)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 648197)
     (if.false.ret)
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
     (subr.gloc.of list? 1 "./boot/macro/library.scm" . 648197)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 648197)
     (const . import)
     (ret.eq? "./boot/macro/library.scm" . 648197))
   (if.true
     (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cdar 1 "./boot/macro/library.scm" . 648197)
     (extend . 2)
     (call
       (touch.gloc.of library-name->id)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->id "./boot/macro/library.scm" . 648197))
     (push)
     (call
       (touch.gloc.of library-name->version)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of library-name->version "./boot/macro/library.scm" . 648197))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 1)
       (if.false.ret)
       (call
         (touch.gloc.of scheme-library-versions)
         (apply.gloc.of scheme-library-versions "./boot/macro/library.scm" . 648197))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 648197))
     (call
       (touch.gloc.of parse-imports)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-imports "./boot/macro/library.scm" . 648197))
     (push)
     (call
       (touch.gloc.of parse-depends)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of parse-depends "./boot/macro/library.scm" . 648197))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 4)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 2)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 648197)
         (push.iloc.1 . 3)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/macro/library.scm" . 648197)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
           (if.eq?.ret.const . #t)
           (push.const . "top-level program")
           (push.const . "duplicate import identifiers")
           (call
             (touch.gloc.of abbreviated-take-form)
             (push.iloc 6 . 0)
             (push.const . 4)
             (push.const . 8)
             (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 648197))
           (push)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 648197))
         (push.iloc 2 . 3)
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
         (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 648197)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 648197))
       (push.iloc.0 . 0)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 648197))
     (call
       (touch.gloc.of make-shield-id-table)
       (push.iloc 2 . 0)
       (apply.gloc.of make-shield-id-table "./boot/macro/library.scm" . 648197))
     (push)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (subr.gloc.of core-hashtable-set! 3 "./boot/macro/library.scm" . 648197)
         (push.iloc.1 . 1)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 648197)
         (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 648197))
       (push.iloc.1 . 3)
       (push.subr.gloc.of core-hashtable->alist 1 "./boot/macro/library.scm" . 648197)
       (apply.gloc.of for-each "./boot/macro/library.scm" . 648197))
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-immutable-identifiers)
         (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 648197))
       (set.iloc 1 . 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc 3 . 2)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 648197))
     (push.close
       (0 0)
       (touch.gloc.of verify-no-unbound-id)
       (push.const . #f)
       (call
         (touch.gloc.of expand-top-level-program-body)
         (push.iloc 7 . 0)
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc 5 . 0)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (call
           (touch.gloc.of extend-env)
           (push.gloc.of private-primitives-environment)
           (call
             (touch.gloc.of permute-env\x60;2)
             (push.iloc 2 . 0)
             (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 648197))
           (push)
           (apply.gloc.of extend-env "./boot/macro/library.scm" . 648197))
         (push)
         (call
           (touch.gloc.of permute-env\x60;2)
           (push.iloc 2 . 1)
           (apply.gloc.of permute-env\x60;2 "./boot/macro/library.scm" . 648197))
         (push)
         (apply.gloc.of expand-top-level-program-body "./boot/macro/library.scm" . 648197))
       (push)
       (push.iloc 3 . 3)
       (apply.gloc.of verify-no-unbound-id "./boot/macro/library.scm" . 648197))
     (push.close
       (0 0)
       (touch.gloc.of current-immutable-identifiers)
       (push.iloc.1 . 0)
       (apply.gloc.of current-immutable-identifiers "./boot/macro/library.scm" . 648197))
     (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 648197))
   (push.const . "top-level program")
   (push.const . "expected import form and top-level body")
   (call
     (touch.gloc.of abbreviated-take-form)
     (push.iloc.1 . 0)
     (push.const . 4)
     (push.const . 8)
     (apply.gloc.of abbreviated-take-form "./boot/macro/library.scm" . 648197))
   (push)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 648197))
 (set.gloc.of expand-top-level-program)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . \x2E;require-scheme-library)
   (push.const . quote)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 760855)
   (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 760855))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (3 0)
   (call
     (touch.gloc.of unique-id-list?)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 726046))
     (push)
     (apply.gloc.of unique-id-list? "./boot/macro/library.scm" . 726029))
   (if.true.ret)
   (call
     (touch.gloc.of find-duplicates)
     (call
       (push.gloc.of car)
       (push.iloc.0 . 2)
       (apply.gloc.of map "./boot/macro/library.scm" . 727080))
     (push)
     (apply.gloc.of find-duplicates "./boot/macro/library.scm" . 727063))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 728086)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 730158)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 730149)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 732206)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 734291)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 734264)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 734264))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc 2 . 0)
         (push.cons)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 735288))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 733222))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.1 . 0)
       (push.cons)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 738358))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define)
       (iloc.0 . 0)
       (push.cons)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 739382))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 737316))
   (push.iloc.1 . 0)
   (push.iloc 2 . 1)
   (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 740374)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 742446)
     (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 742437)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.0 . 0)
     (if.eq?
       (push.iloc 3 . 0)
       (push.iloc 4 . 0)
       (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 744494)
       (extend . 1)
       (push.const . "top-level program")
       (push.const . "duplicate definitions")
       (call
         (touch.gloc.of annotate)
         (push.const . define-syntax)
         (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 746579)
         (push.const ...)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 746552)
         (push.iloc 2 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 746552))
       (push)
       (call
         (touch.gloc.of annotate)
         (push.const . define)
         (iloc.0 . 0)
         (push.cons)
         (push.iloc.0 . 0)
         (apply.gloc.of annotate "./boot/macro/library.scm" . 747576))
       (push)
       (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 745510))
     (push.const . "top-level program")
     (push.const . "duplicate definitions")
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 750673)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 750646)
       (push.iloc.1 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 750646))
     (push)
     (call
       (touch.gloc.of annotate)
       (push.const . define-syntax)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 751697)
       (push.const ...)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 751670)
       (push.iloc.0 . 0)
       (apply.gloc.of annotate "./boot/macro/library.scm" . 751670))
     (push)
     (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 749604))
   (push.const . "top-level program")
   (push.const . "duplicate definitions")
   (push.iloc 2 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 753686))
 (set.gloc.of check-duplicate-definition\x60;2)
 (close
   (8 0 . expand-top-level-program-body)
   (extend.unbound . 6)
   (push.const)
   (push.close
     (2 0)
     (call
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 1)
         (apply.gloc.of macro? "./boot/macro/library.scm" . 714766))
       (if.false.ret)
       (call
         (touch.gloc.of acons)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of acons "./boot/macro/library.scm" . 715807))
       (set.iloc 1 . 0)
       (ret.const.unspec))
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 716831)
       (push.iloc 2 . 6)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 716819))
     (set.iloc 2 . 6)
     (push.close
       (1 0)
       (push.cddr.iloc (0 . 0) "./boot/macro/library.scm" . 717865)
       (push.iloc 3 . 6)
       (ret.subr.gloc.of set-cdr! "./boot/macro/library.scm" . 717855))
     (push.iloc.1 . 0)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 717833))
   (push.close
     (2 0)
     (call
       (touch.gloc.of extend-env)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 721954)
       (push.iloc 2 . 7)
       (apply.gloc.of extend-env "./boot/macro/library.scm" . 721942))
     (set.iloc 2 . 7)
     (ret.const.unspec))
   (push.close
     (4 0)
     (call
       (touch.gloc.of check-duplicate-definition\x60;2)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of check-duplicate-definition\x60;2 "./boot/macro/library.scm" . 757769))
     (call
       (touch.gloc.of expand-each)
       (push.iloc.0 . 0)
       (push.iloc 2 . 6)
       (apply.gloc.of expand-each "./boot/macro/library.scm" . 758814))
     (push)
     (extend . 1)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc 3 . 5)
       (apply.gloc.of map "./boot/macro/library.scm" . 760850))
     (push)
     (call
       (push.close
         (1 0)
         (push.const . #f)
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 766020)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (touch.gloc.of current-top-level-exterior)
             (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 767003))
           (set.iloc 1 . 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 1)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 767003))
         (push.close
           (0 0)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 767025)
           (push.iloc 4 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 767019)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 767014)
           (call
             (touch.gloc.of expand-form)
             (push.cadr.iloc (2 . 0) "./boot/macro/library.scm" . 768051)
             (push.iloc 6 . 6)
             (apply.gloc.of expand-form "./boot/macro/library.scm" . 768038))
           (push)
           (extend . 2)
           (call
             (touch.gloc.of set-closure-comment!)
             (push.iloc.0 . 1)
             (push.iloc.0 . 0)
             (apply.gloc.of set-closure-comment! "./boot/macro/library.scm" . 769053))
           (push.const . define)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 767003))
         (push.close
           (0 0)
           (touch.gloc.of current-top-level-exterior)
           (push.iloc.1 . 0)
           (apply.gloc.of current-top-level-exterior "./boot/macro/library.scm" . 767003))
         (apply.gloc.of \x2E;dynamic-wind "./boot/macro/library.scm" . 767003))
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/macro/library.scm" . 764946))
     (push)
     (call
       (iloc.1 . 2)
       (if.null? (ret.const))
       (call (apply.gloc.of generate-temporary-symbol "./boot/macro/library.scm" . 775208))
       (push)
       (extend . 1)
       (push.const . let)
       (push.iloc.0 . 0)
       (push.const . quote)
       (call
         (subr.gloc.of make-core-hashtable 0)
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (call
               (touch.gloc.of unbound?)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 779333)
               (apply.gloc.of unbound? "./boot/macro/library.scm" . 779323))
             (push)
             (subr.gloc.of not 1 "./boot/macro/library.scm" . 779318)
             (if.true
               (push.iloc.1 . 0)
               (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 780366)
               (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 780374)
               (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 780342))
             (ret.const.unspec))
           (push.iloc 5 . 7)
           (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 781360)
           (apply.gloc.of for-each "./boot/macro/library.scm" . 778278))
         (push.iloc.0 . 0)
         (ret.subr.gloc.of core-hashtable->alist "./boot/macro/library.scm" . 782374))
       (push)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 775190)
       (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 775190)
       (push.subr.gloc.of \x2E;list 1 "./boot/macro/library.scm" . 775190)
       (call
         (push.close
           (1 0)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 784442)
           (push.iloc 3 . 3)
           (push.subr.gloc.of assq 2 "./boot/macro/library.scm" . 784436)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 784431)
           (push.iloc.0 . 0)
           (push.subr.gloc.of caddr 1 "./boot/macro/library.scm" . 786481)
           (extend . 2)
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 785457)
           (const . template)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 788521)
             (push.const . quote)
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 788521)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 788521))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 785457)
           (const . procedure)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote syntax)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 789545)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 789545))
           (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 785457)
           (const . variable)
           (if.eq?
             (push.const . \x2E;set-top-level-macro!)
             (push.const quote variable)
             (push.const . quote)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;list 2 "./boot/macro/library.scm" . 790569)
             (push.iloc.0 . 1)
             (push.iloc 2 . 0)
             (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 790569))
           (push.const . "internal error in rewrite body: bad macro spec ~s")
           (push.iloc.1 . 0)
           (apply.gloc.of scheme-error "./boot/macro/library.scm" . 791599))
         (push.iloc 2 . 2)
         (apply.gloc.of map "./boot/macro/library.scm" . 775190))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/macro/library.scm" . 775190)
       (ret.subr.gloc.of \x2E;list "./boot/macro/library.scm" . 775190))
     (push)
     (extend . 3)
     (call
       (call
         (touch.gloc.of check-rec*-contract-violation)
         (call
           (push.gloc.of cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 793625))
         (push)
         (call
           (push.gloc.of caddr)
           (push.iloc.0 . 1)
           (apply.gloc.of map "./boot/macro/library.scm" . 794656))
         (push)
         (apply.gloc.of check-rec*-contract-violation "./boot/macro/library.scm" . 795670))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (push.cdr.iloc (0 . 0) "./boot/macro/library.scm" . 797761)
             (car.iloc (1 . 0) "./boot/macro/library.scm" . 797769)
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 0)
             (ret.subr.gloc.of car "./boot/macro/library.scm" . 797780))
           (push.iloc 3 . 3)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 797733))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of current-macro-expression)
           (push.const . #f)
           (apply.gloc.of current-macro-expression "./boot/macro/library.scm" . 798749))
         (push.const . #f)
         (push.const . "attempt to reference uninitialized variable ~u")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 800815)
         (call
           (touch.gloc.of any1)
           (push.close
             (1 0)
             (call
               (touch.gloc.of check-rec-contract-violation)
               (push.iloc.1 . 0)
               (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 802906)
               (push.iloc.0 . 0)
               (apply.gloc.of check-rec-contract-violation "./boot/macro/library.scm" . 802876))
             (if.false.ret)
             (touch.gloc.of annotate)
             (push.const . define)
             (iloc.0 . 0)
             (push.cons)
             (push.iloc.0 . 0)
             (apply.gloc.of annotate "./boot/macro/library.scm" . 803900))
           (push.iloc 4 . 1)
           (apply.gloc.of any1 "./boot/macro/library.scm" . 801839))
         (push)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 799773))
       (ret.const.unspec))
     (touch.gloc.of annotate)
     (push.const . begin)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 805901)
     (push.subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 805901)
     (subr.gloc.of \x2E;append 2 "./boot/macro/library.scm" . 805901)
     (push.cons)
     (push.iloc 4 . 0)
     (apply.gloc.of annotate "./boot/macro/library.scm" . 805901))
   (enclose . 4)
   (subr.gloc.of make-core-hashtable 0 "./boot/macro/library.scm" . 813092)
   (set.iloc 0 . 4)
   (call
     (push.const . 0)
     (extend . 1)
     (ret.close
       (0 0)
       (n+.iloc (1 . 0) 1 "./boot/macro/library.scm" . 818197)
       (set.iloc 1 . 0)
       (push.const . ".e~a")
       (push.iloc.1 . 0)
       (push.subr.gloc.of format 2 "./boot/macro/library.scm" . 819227)
       (ret.subr.gloc.of string->symbol "./boot/macro/library.scm" . 819211)))
   (set.iloc 0 . 5)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 4)
       (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 821319)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/macro/library.scm" . 821275))
     (push.iloc.1 . 4)
     (apply.gloc.of for-each "./boot/macro/library.scm" . 821253))
   (extend.enclose
     (4 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 824350)
       (push.iloc.0 . 2)
       (push.subr.gloc.of reverse 1 "./boot/macro/library.scm" . 824365)
       (push.iloc.0 . 3)
       (apply.iloc (2 . 3) "./boot/macro/library.scm" . 824331))
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (car.iloc (0 . 0) "./boot/macro/library.scm" . 825387)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 825408)
       (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 825399))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 6)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/macro/library.scm" . 826414)
         (apply.gloc.of env-lookup "./boot/macro/library.scm" . 826398))
       (push)
       (extend . 1)
       (push.gloc.of denote-begin)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of flatten-begin)
           (push.iloc.1 . 0)
           (push.iloc 4 . 6)
           (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 828449))
         (push)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 828443))
       (push.gloc.of denote-define-syntax)
       (iloc.0 . 0)
       (if.eq?
         (call
           (iloc.1 . 0)
           (if.not.pair?.ret.const . #f)
           (car.iloc (1 . 0) "./boot/macro/library.scm" . 830491)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdar 1 "./boot/macro/library.scm" . 830491)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cddar 1 "./boot/macro/library.scm" . 830491)
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 0)
           (subr.gloc.of cdddar 1 "./boot/macro/library.scm" . 830491)
           (if.not.null?.ret.const . #f)
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 830491)
           (subr.gloc.of list? 1 "./boot/macro/library.scm" . 830491)
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 830491)
           (ret.subr.gloc.of symbol? "./boot/macro/library.scm" . 830491))
         (if.true
           (push.cdr.iloc (1 . 0) "./boot/macro/library.scm" . 830491)
           (push.iloc.1 . 0)
           (push.subr.gloc.of caddar 1 "./boot/macro/library.scm" . 830491)
           (push.iloc.1 . 0)
           (push.subr.gloc.of cadar 1 "./boot/macro/library.scm" . 830491)
           (extend . 3)
           (call
             (push.iloc 4 . 4)
             (push.iloc.0 . 2)
             (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 830491)
             (if.false.ret)
             (push.const . define-syntax)
             (push.const . "attempt to modify immutable binding")
             (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 830491)
             (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 830491))
           (push.close
             (0 0)
             (touch.gloc.of compile-macro)
             (push.car.iloc (3 . 0) "./boot/macro/library.scm" . 830491)
             (push.iloc.1 . 1)
             (push.iloc 6 . 6)
             (apply.gloc.of compile-macro "./boot/macro/library.scm" . 830491))
           (push.close
             (1 1)
             (call
               (touch.gloc.of generate-global-id)
               (push.iloc 6 . 1)
               (push.iloc.1 . 2)
               (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 830491))
             (push)
             (extend . 1)
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-import)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-import "./boot/macro/library.scm" . 830491))
               (push)
               (apply.iloc (6 . 2) "./boot/macro/library.scm" . 830491))
             (push.iloc.1 . 0)
             (subr.gloc.of procedure? 1 "./boot/macro/library.scm" . 830491)
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro)
                   (push.iloc.1 . 0)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro "./boot/macro/library.scm" . 830491))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 830491))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . procedure)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 830491)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 830491)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 830491))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 830491))
             (call
               (touch.gloc.of macro-variable?)
               (push.iloc.1 . 0)
               (apply.gloc.of macro-variable? "./boot/macro/library.scm" . 830491))
             (if.true
               (call
                 (push.iloc 2 . 2)
                 (call
                   (touch.gloc.of make-macro-variable)
                   (push.cadr.iloc (1 . 0) "./boot/macro/library.scm" . 830491)
                   (push.iloc 7 . 6)
                   (apply.gloc.of make-macro-variable "./boot/macro/library.scm" . 830491))
                 (push)
                 (apply.iloc (6 . 1) "./boot/macro/library.scm" . 830491))
               (push.iloc 2 . 0)
               (push.iloc 4 . 1)
               (push.iloc 2 . 2)
               (push.const . variable)
               (push.car.iloc (1 . 1) "./boot/macro/library.scm" . 830491)
               (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 830491)
               (iloc 4 . 2)
               (push.cons)
               (call
                 (touch.gloc.of acons)
                 (push.iloc 2 . 2)
                 (push.iloc.0 . 0)
                 (push.iloc 4 . 3)
                 (apply.gloc.of acons "./boot/macro/library.scm" . 830491))
               (push)
               (apply.iloc (5 . 0) "./boot/macro/library.scm" . 830491))
             (call
               (push.iloc 2 . 2)
               (call
                 (touch.gloc.of make-macro)
                 (push.iloc.1 . 0)
                 (push.iloc 7 . 6)
                 (apply.gloc.of make-macro "./boot/macro/library.scm" . 830491))
               (push)
               (apply.iloc (6 . 1) "./boot/macro/library.scm" . 830491))
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.iloc 2 . 2)
             (push.const . template)
             (push.iloc.1 . 0)
             (push.subr.gloc.of list 3 "./boot/macro/library.scm" . 830491)
             (iloc 4 . 2)
             (push.cons)
             (call
               (touch.gloc.of acons)
               (push.iloc 2 . 2)
               (push.iloc.0 . 0)
               (push.iloc 4 . 3)
               (apply.gloc.of acons "./boot/macro/library.scm" . 830491))
             (push)
             (apply.iloc (5 . 0) "./boot/macro/library.scm" . 830491))
           (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 830491))
         (push.const . define-syntax)
         (push.const . "expected symbol and single expression")
         (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 830491)
         (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 830491))
       (push.gloc.of denote-define)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of annotate)
           (call
             (touch.gloc.of desugar-define)
             (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 851013)
             (apply.gloc.of desugar-define "./boot/macro/library.scm" . 850997))
           (push)
           (push.subr.gloc.of cdr 1 "./boot/macro/library.scm" . 850992)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 851026)
           (apply.gloc.of annotate "./boot/macro/library.scm" . 850982))
         (push)
         (extend . 1)
         (call
           (push.iloc 4 . 4)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 852051)
           (subr.gloc.of core-hashtable-contains? 2 "./boot/macro/library.scm" . 852002)
           (if.false.ret)
           (push.const . define)
           (push.const . "attempt to modify immutable binding")
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 853090)
           (apply.gloc.of syntax-violation "./boot/macro/library.scm" . 853026))
         (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 854056)
         (call
           (touch.gloc.of generate-global-id)
           (push.iloc 5 . 1)
           (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 855111)
           (apply.gloc.of generate-global-id "./boot/macro/library.scm" . 855080))
         (push)
         (extend . 2)
         (call
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.iloc (5 . 1) "./boot/macro/library.scm" . 856095))
         (call
           (push.iloc.0 . 0)
           (call
             (touch.gloc.of make-import)
             (push.iloc.0 . 1)
             (apply.gloc.of make-import "./boot/macro/library.scm" . 857139))
           (push)
           (apply.iloc (5 . 2) "./boot/macro/library.scm" . 857119))
         (push.cdr.iloc (3 . 0) "./boot/macro/library.scm" . 858149)
         (push.iloc.1 . 0)
         (iloc 3 . 1)
         (push.cons)
         (push.iloc 3 . 2)
         (call
           (touch.gloc.of acons)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.iloc 3 . 3)
           (apply.gloc.of acons "./boot/macro/library.scm" . 858183))
         (push)
         (apply.iloc (4 . 0) "./boot/macro/library.scm" . 858143))
       (push.gloc.of denote-define-macro)
       (iloc.0 . 0)
       (if.eq?
         (call
           (touch.gloc.of rewrite-define-macro)
           (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 860221)
           (apply.gloc.of rewrite-define-macro "./boot/macro/library.scm" . 860199))
         (push)
         (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 860233)
         (push.cons)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (apply.iloc (2 . 0) "./boot/macro/library.scm" . 860187))
       (call
         (call
           (touch.gloc.of macro?)
           (push.iloc.0 . 0)
           (apply.gloc.of macro? "./boot/macro/library.scm" . 861215))
         (if.true.ret)
         (push.gloc.of denote-let-syntax)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.gloc.of denote-letrec-syntax)
         (iloc.0 . 0)
         (ret.eq? "./boot/macro/library.scm" . 863263))
       (if.true
         (push.close
           (0 0)
           (touch.gloc.of expand-initial-forms)
           (push.car.iloc (2 . 0) "./boot/macro/library.scm" . 864330)
           (push.iloc 5 . 6)
           (apply.gloc.of expand-initial-forms "./boot/macro/library.scm" . 864308))
         (push.close
           (2 0)
           (iloc.0 . 1)
           (set.iloc 5 . 6)
           (call
             (touch.gloc.of flatten-begin)
             (push.iloc.0 . 0)
             (push.subr.gloc.of list 1 "./boot/macro/library.scm" . 866362)
             (push.iloc 5 . 6)
             (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 866347))
           (push)
           (push.cdr.iloc (2 . 0) "./boot/macro/library.scm" . 866379)
           (push.subr.gloc.of append 2 "./boot/macro/library.scm" . 866339)
           (push.iloc 2 . 1)
           (push.iloc 2 . 2)
           (push.iloc 2 . 3)
           (apply.iloc (3 . 0) "./boot/macro/library.scm" . 866333))
         (apply.gloc.of \x2E;call-with-values "./boot/macro/library.scm" . 826386))
       (push.const . \x2E;define)
       (call (apply.iloc (3 . 5) "./boot/macro/library.scm" . 868402))
       (push)
       (push.car.iloc (1 . 0) "./boot/macro/library.scm" . 868420)
       (push.subr.gloc.of \x2E;list 3 "./boot/macro/library.scm" . 868385)
       (cdr.iloc (1 . 0) "./boot/macro/library.scm" . 868432)
       (push.cons)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (2 . 0) "./boot/macro/library.scm" . 868379))
     (push.const . \x2E;define)
     (call (apply.iloc (2 . 5) "./boot/macro/library.scm" . 870441))
     (push)
     (push.car.iloc (0 . 0) "./boot/macro/library.scm" . 870459)
     (push.subr.gloc.of \x2E;list 3 "./boot/macro/library.scm" . 870424)
     (cdr.iloc (0 . 0) "./boot/macro/library.scm" . 870471)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.iloc (1 . 0) "./boot/macro/library.scm" . 870418))
   (call
     (touch.gloc.of flatten-begin)
     (push.iloc 2 . 3)
     (push.iloc 2 . 6)
     (apply.gloc.of flatten-begin "./boot/macro/library.scm" . 822294))
   (push)
   (push.const)
   (push.const)
   (push.const)
   (apply.iloc (0 . 0) "./boot/macro/library.scm" . 822277))
 (set.gloc.of expand-top-level-program-body)
 (ret.const.unspec))

;
((close
   (2 0 . extend-env)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of append "./boot/macro/synenv.scm" . 9225))
 (set.gloc.of extend-env)
 (ret.const.unspec))
((close
   (2 0 . env-lookup)
   (call
     (iloc.0 . 1)
     (if.symbol?.ret.const . #t)
     (push.const . "internal error: env-lookup: expect symbol but got ~s")
     (push.iloc.0 . 1)
     (apply.gloc.of scheme-error "./boot/macro/synenv.scm" . 14345))
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 15372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of import?)
       (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 17441)
       (apply.gloc.of import? "./boot/macro/synenv.scm" . 17432))
     (if.true
       (push.cddr.iloc (0 . 0) "./boot/macro/synenv.scm" . 18470)
       (extend . 1)
       (subr.gloc.of current-macro-environment 0)
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 0)
       (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 19482))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of cdr "./boot/macro/synenv.scm" . 21528))
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.1 . 1)
   (push.iloc.1 . 1)
   (ret.subr.gloc.of core-hashtable-ref "./boot/macro/synenv.scm" . 23564))
 (set.gloc.of env-lookup)
 (ret.const.unspec))
((close
   (2 0 . env-delete!)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.subr.gloc.of assq 2 "./boot/macro/synenv.scm" . 27660)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of set-car! 2 "./boot/macro/synenv.scm" . 29713)
     (push.iloc.0 . 0)
     (push.const . no-use)
     (ret.subr.gloc.of set-cdr! "./boot/macro/synenv.scm" . 30737))
   (ret.const.unspec))
 (set.gloc.of env-delete!)
 (ret.const.unspec))
((close
   (2 0 . unrename-syntax)
   (extend.enclose
     (1 0 . loop)
     (iloc.0 . 0)
     (if.pair?
       (call
         (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 36894)
         (apply.iloc (1 . 0) "./boot/macro/synenv.scm" . 36888))
       (push)
       (call
         (push.cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 36916)
         (apply.iloc (1 . 0) "./boot/macro/synenv.scm" . 36910))
       (push)
       (extend . 2)
       (call
         (push.iloc.0 . 0)
         (car.iloc (1 . 0) "./boot/macro/synenv.scm" . 37924)
         (if.not.eq?.ret.const . #f)
         (push.iloc.0 . 1)
         (cdr.iloc (1 . 0) "./boot/macro/synenv.scm" . 37943)
         (ret.eq? "./boot/macro/synenv.scm" . 37935))
       (if.true (ret.iloc 1 . 0))
       (call
         (touch.gloc.of annotated?)
         (push.iloc.1 . 0)
         (apply.gloc.of annotated? "./boot/macro/synenv.scm" . 38935))
       (if.true
         (touch.gloc.of annotate)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (push.iloc.1 . 0)
         (apply.gloc.of annotate "./boot/macro/synenv.scm" . 38952))
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (ret.cons "./boot/macro/synenv.scm" . 39964))
     (call
       (touch.gloc.of renamed-id?)
       (push.iloc.0 . 0)
       (apply.gloc.of renamed-id? "./boot/macro/synenv.scm" . 40974))
     (if.true
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 42010))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of special?)
         (push.iloc.0 . 0)
         (apply.gloc.of special? "./boot/macro/synenv.scm" . 43031))
       (if.true
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/synenv.scm" . 43047))
       (call
         (touch.gloc.of macro?)
         (push.iloc.0 . 0)
         (apply.gloc.of macro? "./boot/macro/synenv.scm" . 44055))
       (if.true
         (call
           (touch.gloc.of original-id)
           (push.iloc.1 . 0)
           (apply.gloc.of original-id "./boot/macro/synenv.scm" . 45089))
         (push)
         (extend . 1)
         (push.iloc.1 . 0)
         (subr.gloc.of current-macro-environment 0)
         (push)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 46119)
         (if.eq? (ret.iloc 0 . 0))
         (ret.iloc 2 . 0))
       (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (subr.gloc.of vector? 1 "./boot/macro/synenv.scm" . 48142)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/macro/synenv.scm" . 49190)
         (apply.gloc.of map "./boot/macro/synenv.scm" . 49180))
       (push)
       (ret.subr.gloc.of list->vector "./boot/macro/synenv.scm" . 49166))
     (ret.iloc 0 . 0))
   (push.iloc.1 . 0)
   (apply.iloc (0 . 0) "./boot/macro/synenv.scm" . 34821))
 (set.gloc.of unrename-syntax)
 (ret.const.unspec))
((close
   (2 0 . free-id=?)
   (call
     (touch.gloc.of current-transformer-environment)
     (apply.gloc.of current-transformer-environment "./boot/macro/synenv.scm" . 68628))
   (push)
   (call
     (touch.gloc.of current-expansion-environment)
     (apply.gloc.of current-expansion-environment "./boot/macro/synenv.scm" . 68672))
   (push)
   (extend . 2)
   (extend.enclose
     (2 0)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 72732))
     (push)
     (extend . 1)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (if.eq?
       (push.iloc.0 . 0)
       (iloc.1 . 0)
       (if.eq?.ret.const . #t)
       (call
         (touch.gloc.of unbound?)
         (push.iloc.0 . 0)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 75797))
       (if.true.ret)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 76836))
       (ret.eq? "./boot/macro/synenv.scm" . 76821))
     (call
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 0)
         (apply.gloc.of original-id "./boot/macro/synenv.scm" . 77855))
       (push)
       (call
         (touch.gloc.of original-id)
         (push.iloc.1 . 1)
         (apply.gloc.of original-id "./boot/macro/synenv.scm" . 77873))
       (if.not.eq?.ret.const . #f)
       (call
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (if.eq?.ret.const . #t)
         (touch.gloc.of unbound?)
         (push.iloc.0 . 0)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 78898))
       (if.false.ret)
       (call
         (call
           (touch.gloc.of env-lookup)
           (push.iloc 3 . 0)
           (push.iloc.1 . 1)
           (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 79915))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of unbound?)
           (push.iloc.0 . 0)
           (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 79946))
         (if.true.ret)
         (push.iloc.0 . 0)
         (iloc 2 . 1)
         (ret.eq? "./boot/macro/synenv.scm" . 79967))
       (if.false.ret)
       (call
         (call
           (touch.gloc.of env-lookup)
           (push.iloc 3 . 1)
           (push.iloc.1 . 0)
           (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 80939))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of unbound?)
           (push.iloc.0 . 0)
           (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 80970))
         (if.true.ret)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (ret.eq? "./boot/macro/synenv.scm" . 80991))
       (if.false.ret)
       (call
         (touch.gloc.of env-lookup)
         (push.iloc 3 . 1)
         (push.iloc.1 . 1)
         (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 81963))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of unbound?)
         (push.iloc.0 . 0)
         (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 81994))
       (if.true.ret)
       (push.iloc.0 . 0)
       (iloc 2 . 1)
       (ret.eq? "./boot/macro/synenv.scm" . 82015))
     (if.true.ret)
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 0)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 82975))
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 3 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 84013))
     (if.eq?.ret.const . #t)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 3 . 1)
       (push.iloc.1 . 1)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 85037))
     (ret.eq? "./boot/macro/synenv.scm" . 85022))
   (call
     (touch.gloc.of lookup-lexical-name)
     (push.iloc 2 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 87058))
   (push)
   (extend . 1)
   (iloc 3 . 1)
   (if.symbol?
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of lookup-lexical-name)
       (push.iloc 3 . 1)
       (push.iloc 2 . 1)
       (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 89116))
     (push)
     (apply.iloc (1 . 0) "./boot/macro/synenv.scm" . 89101))
   (call
     (touch.gloc.of syntax-object-lexname)
     (push.iloc 3 . 1)
     (apply.gloc.of syntax-object-lexname "./boot/macro/synenv.scm" . 90136))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (iloc.0 . 0) (ret.eq? "./boot/macro/synenv.scm" . 92179))
   (call
     (touch.gloc.of lookup-lexical-name)
     (call
       (touch.gloc.of syntax-object-expr)
       (push.iloc 4 . 1)
       (apply.gloc.of syntax-object-expr "./boot/macro/synenv.scm" . 93235))
     (push)
     (push.iloc 3 . 1)
     (apply.gloc.of lookup-lexical-name "./boot/macro/synenv.scm" . 93214))
   (push)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 3 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 94244))
   (push)
   (extend . 2)
   (push.iloc 2 . 0)
   (iloc.0 . 0)
   (if.eq?
     (push.iloc.0 . 1)
     (iloc 2 . 0)
     (if.eq?.ret.const . #t)
     (call
       (touch.gloc.of unbound?)
       (push.iloc.0 . 1)
       (apply.gloc.of unbound? "./boot/macro/synenv.scm" . 97309))
     (if.true.ret)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of env-lookup)
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 98348))
     (ret.eq? "./boot/macro/synenv.scm" . 98333))
   (call
     (touch.gloc.of syntax-object-renames)
     (push.iloc 5 . 1)
     (apply.gloc.of syntax-object-renames "./boot/macro/synenv.scm" . 99365))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.pair?
     (push.iloc.1 . 1)
     (cdr.iloc (0 . 0) "./boot/macro/synenv.scm" . 101422)
     (ret.eq? "./boot/macro/synenv.scm" . 101407))
   (push.iloc.1 . 1)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 5 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 102450))
   (if.eq?.ret.const . #t)
   (push.iloc.1 . 1)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc 5 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 103474))
   (ret.eq? "./boot/macro/synenv.scm" . 103459))
 (set.gloc.of free-id=?)
 (ret.const.unspec))
((close
   (1 0 . make-import)
   (push.const . import)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 107525))
 (set.gloc.of make-import)
 (ret.const.unspec))
((close (0 0 . make-unbound) (ret.const unbound)) (set.gloc.of make-unbound) (ret.const.unspec))
((close
   (1 0 . make-out-of-context)
   (iloc.0 . 0)
   (if.true
     (push.const . out-of-context)
     (iloc.0 . 0)
     (ret.cons "./boot/macro/synenv.scm" . 116745))
   (ret.const out-of-context . #f))
 (set.gloc.of make-out-of-context)
 (ret.const.unspec))
((close
   (1 0 . make-pattern-variable)
   (push.const . pattern-variable)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 121861))
 (set.gloc.of make-pattern-variable)
 (ret.const.unspec))
((close
   (2 0 . make-macro)
   (push.const . macro)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 125957))
 (set.gloc.of make-macro)
 (ret.const.unspec))
((close
   (2 0 . make-macro-variable)
   (push.const . macro-variable)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of cons* "./boot/macro/synenv.scm" . 130053))
 (set.gloc.of make-macro-variable)
 (ret.const.unspec))
((close
   (1 0 . make-special)
   (push.const . special)
   (iloc.0 . 0)
   (ret.cons "./boot/macro/synenv.scm" . 134149))
 (set.gloc.of make-special)
 (ret.const.unspec))
((close
   (1 0 . import?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 139279)
   (const . import)
   (ret.eq? "./boot/macro/synenv.scm" . 139274))
 (set.gloc.of import?)
 (ret.const.unspec))
((close
   (1 0 . unbound?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 144399)
   (const . unbound)
   (ret.eq? "./boot/macro/synenv.scm" . 144394))
 (set.gloc.of unbound?)
 (ret.const.unspec))
((close
   (1 0 . out-of-context?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 149519)
   (const . out-of-context)
   (ret.eq? "./boot/macro/synenv.scm" . 149514))
 (set.gloc.of out-of-context?)
 (ret.const.unspec))
((close
   (1 0 . macro?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 154643)
   (const . macro)
   (if.eq?.ret.const . #t)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 155667)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 155662))
 (set.gloc.of macro?)
 (ret.const.unspec))
((close
   (1 0 . macro-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 160783)
   (const . macro-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 160778))
 (set.gloc.of macro-variable?)
 (ret.const.unspec))
((close
   (1 0 . pattern-variable?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 165903)
   (const . pattern-variable)
   (ret.eq? "./boot/macro/synenv.scm" . 165898))
 (set.gloc.of pattern-variable?)
 (ret.const.unspec))
((close
   (1 0 . special?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 171023)
   (const . special)
   (ret.eq? "./boot/macro/synenv.scm" . 171018))
 (set.gloc.of special?)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 175127)
   (push.const . "unquote appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 175109))
 (set.gloc.of unexpected-unquote)
 (ret.const.unspec))
((close
   (2 0 . unexpected-unquote-splicing)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 179223)
   (push.const . "unquote-splicing appear outside of quasiquote")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 179205))
 (set.gloc.of unexpected-unquote-splicing)
 (ret.const.unspec))
((close
   (2 0 . unexpected-auxiliary-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 183319)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 183301))
 (set.gloc.of unexpected-auxiliary-syntax)
 (ret.const.unspec))
((close
   (2 0 . unexpected-syntax)
   (push.car.iloc (0 . 0) "./boot/macro/synenv.scm" . 187415)
   (push.const . "misplaced syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of syntax-violation "./boot/macro/synenv.scm" . 187397))
 (set.gloc.of unexpected-syntax)
 (ret.const.unspec))
((subr.gloc.of make-core-hashtable 0 "./boot/macro/synenv.scm" . 189458)
 (set.gloc.of core-env)
 (ret.const.unspec))
((close
   (2 0)
   (push.gloc.of core-env)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (subr.gloc.of core-hashtable-set! 3 "./boot/macro/synenv.scm" . 195591)
   (push.gloc.of core-env)
   (call
     (touch.gloc.of core-primitive-name)
     (push.iloc.0 . 0)
     (apply.gloc.of core-primitive-name "./boot/macro/synenv.scm" . 196645))
   (push)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of core-hashtable-set! "./boot/macro/synenv.scm" . 196615))
 (set.gloc.of init-core-macro\x60;1)
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . lambda)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-lambda)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 198695))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 198659))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . quote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 199719))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 199683))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . if)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-if)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 200743))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 200707))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . set!)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-set!)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 201767))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 201731))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 202791))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 202755))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 203815))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 203779))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 204839))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 204803))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . begin)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-begin)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 205863))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 205827))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 206887))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 206851))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . quasiquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-quasiquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 207911))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 207875))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 208935))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 208899))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 209959))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 209923))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 210983))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 210947))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . cond)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-cond)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 212007))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 211971))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 213031))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 212995))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . do)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-do)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 214055))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 214019))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . and)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-and)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 215079))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 215043))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . or)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-or)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 216103))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 216067))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . letrec*)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-letrec*)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 217127))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 217091))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . library)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-library)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 218151))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 218115))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . define-macro)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-define-macro)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 219175))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 219139))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let*-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let*-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 220199))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 220163))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . let-values)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-let-values)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 221223))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 221187))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 222247))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 222211))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax-case)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-syntax-case)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 223271))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 223235))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . identifier-syntax)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-identifier-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 224295))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 224259))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . assert)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of expand-assert)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 225319))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 225283))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . unquote)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 226343))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 226307))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . unquote-splicing)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-unquote-splicing)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 227367))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 227331))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . syntax-rules)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 228391))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 228355))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . else)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 229415))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 229379))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . =>)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 230439))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 230403))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . ...)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 231463))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 231427))
 (call
   (touch.gloc.of init-core-macro\x60;1)
   (push.const . _)
   (call
     (touch.gloc.of make-special)
     (push.gloc.of unexpected-auxiliary-syntax)
     (apply.gloc.of make-special "./boot/macro/synenv.scm" . 232487))
   (push)
   (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 232451))
 (touch.gloc.of init-core-macro\x60;1)
 (push.const . import)
 (call
   (touch.gloc.of make-special)
   (push.gloc.of expand-import)
   (apply.gloc.of make-special "./boot/macro/synenv.scm" . 233511))
 (push)
 (apply.gloc.of init-core-macro\x60;1 "./boot/macro/synenv.scm" . 233475))
((push.gloc.of core-env)
 (push.const . lambda)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 235553)
 (set.gloc.of denote-lambda)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . begin)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 236577)
 (set.gloc.of denote-begin)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 237601)
 (set.gloc.of denote-define)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 238625)
 (set.gloc.of denote-define-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 239649)
 (set.gloc.of denote-let-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec-syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 240673)
 (set.gloc.of denote-letrec-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . define-macro)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 241697)
 (set.gloc.of denote-define-macro)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . library)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 242721)
 (set.gloc.of denote-library)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quasiquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 243745)
 (set.gloc.of denote-quasiquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 244769)
 (set.gloc.of denote-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . if)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 245793)
 (set.gloc.of denote-if)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . set!)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 246817)
 (set.gloc.of denote-set!)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 247841)
 (set.gloc.of denote-unquote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . unquote-splicing)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 248865)
 (set.gloc.of denote-unquote-splicing)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 249889)
 (set.gloc.of denote-let)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 250913)
 (set.gloc.of denote-letrec)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 251937)
 (set.gloc.of denote-let*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . cond)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 252961)
 (set.gloc.of denote-cond)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 253985)
 (set.gloc.of denote-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . do)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 255009)
 (set.gloc.of denote-do)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . and)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 256033)
 (set.gloc.of denote-and)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . or)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 257057)
 (set.gloc.of denote-or)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . letrec*)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 258081)
 (set.gloc.of denote-letrec*)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let*-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 259105)
 (set.gloc.of denote-let*-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . let-values)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 260129)
 (set.gloc.of denote-let-values)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-quote)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 261153)
 (set.gloc.of denote-syntax-quote)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 262177)
 (set.gloc.of denote-syntax)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-case)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 263201)
 (set.gloc.of denote-syntax-case)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . syntax-rules)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 264225)
 (set.gloc.of denote-syntax-rules)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . else)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 265249)
 (set.gloc.of denote-else)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . =>)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 266273)
 (set.gloc.of denote-=>)
 (ret.const.unspec))
((push.gloc.of core-env)
 (push.const . import)
 (push.const . #f)
 (subr.gloc.of core-hashtable-ref 3 "./boot/macro/synenv.scm" . 267297)
 (set.gloc.of denote-import)
 (ret.const.unspec))
((close
   (2 0 . denote-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of macro?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 272402))
   (push)
   (apply.gloc.of macro? "./boot/macro/synenv.scm" . 272394))
 (set.gloc.of denote-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-special?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (touch.gloc.of special?)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 277524))
   (push)
   (apply.gloc.of special? "./boot/macro/synenv.scm" . 277514))
 (set.gloc.of denote-special?)
 (ret.const.unspec))
((close
   (2 0 . denote-lambda?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 282639))
   (push)
   (gloc.of denote-lambda)
   (ret.eq? "./boot/macro/synenv.scm" . 282634))
 (set.gloc.of denote-lambda?)
 (ret.const.unspec))
((close
   (2 0 . denote-begin?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 287759))
   (push)
   (gloc.of denote-begin)
   (ret.eq? "./boot/macro/synenv.scm" . 287754))
 (set.gloc.of denote-begin?)
 (ret.const.unspec))
((close
   (2 0 . denote-let?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 292879))
   (push)
   (gloc.of denote-let)
   (ret.eq? "./boot/macro/synenv.scm" . 292874))
 (set.gloc.of denote-let?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 297999))
   (push)
   (gloc.of denote-define-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 297994))
 (set.gloc.of denote-define-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-let-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 303119))
   (push)
   (gloc.of denote-let-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 303114))
 (set.gloc.of denote-let-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-letrec-syntax?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 308239))
   (push)
   (gloc.of denote-letrec-syntax)
   (ret.eq? "./boot/macro/synenv.scm" . 308234))
 (set.gloc.of denote-letrec-syntax?)
 (ret.const.unspec))
((close
   (2 0 . denote-define?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 313359))
   (push)
   (gloc.of denote-define)
   (ret.eq? "./boot/macro/synenv.scm" . 313354))
 (set.gloc.of denote-define?)
 (ret.const.unspec))
((close
   (2 0 . denote-quote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 318479))
   (push)
   (gloc.of denote-quote)
   (ret.eq? "./boot/macro/synenv.scm" . 318474))
 (set.gloc.of denote-quote?)
 (ret.const.unspec))
((close
   (2 0 . denote-quasiquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 323599))
   (push)
   (gloc.of denote-quasiquote)
   (ret.eq? "./boot/macro/synenv.scm" . 323594))
 (set.gloc.of denote-quasiquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 328719))
   (push)
   (gloc.of denote-unquote)
   (ret.eq? "./boot/macro/synenv.scm" . 328714))
 (set.gloc.of denote-unquote?)
 (ret.const.unspec))
((close
   (2 0 . denote-unquote-splicing?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 333839))
   (push)
   (gloc.of denote-unquote-splicing)
   (ret.eq? "./boot/macro/synenv.scm" . 333834))
 (set.gloc.of denote-unquote-splicing?)
 (ret.const.unspec))
((close
   (2 0 . denote-define-macro?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 338959))
   (push)
   (gloc.of denote-define-macro)
   (ret.eq? "./boot/macro/synenv.scm" . 338954))
 (set.gloc.of denote-define-macro?)
 (ret.const.unspec))
((close
   (2 0 . denote-syntax-rules?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 344079))
   (push)
   (gloc.of denote-syntax-rules)
   (ret.eq? "./boot/macro/synenv.scm" . 344074))
 (set.gloc.of denote-syntax-rules?)
 (ret.const.unspec))
((close
   (2 0 . denote-else?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 349199))
   (push)
   (gloc.of denote-else)
   (ret.eq? "./boot/macro/synenv.scm" . 349194))
 (set.gloc.of denote-else?)
 (ret.const.unspec))
((close
   (2 0 . denote-=>?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 354319))
   (push)
   (gloc.of denote-=>)
   (ret.eq? "./boot/macro/synenv.scm" . 354314))
 (set.gloc.of denote-=>?)
 (ret.const.unspec))
((close
   (2 0 . denote-set!?)
   (iloc.0 . 1)
   (if.not.symbol?.ret.const . #f)
   (call
     (touch.gloc.of env-lookup)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of env-lookup "./boot/macro/synenv.scm" . 359439))
   (push)
   (gloc.of denote-set!)
   (ret.eq? "./boot/macro/synenv.scm" . 359434))
 (set.gloc.of denote-set!?)
 (ret.const.unspec))
((push.const . \x2E;LIST)
 (const . \x2E;list)
 (push.cons)
 (push.const . \x2E;CONS)
 (const . \x2E;cons)
 (push.cons)
 (push.const . \x2E;CONS*)
 (const . \x2E;cons*)
 (push.cons)
 (push.const . \x2E;APPEND)
 (const . \x2E;append)
 (push.cons)
 (push.const . \x2E;VECTOR)
 (const . \x2E;vector)
 (push.cons)
 (push.const . \x2E;LIST->VECTOR)
 (const . \x2E;list->vector)
 (push.cons)
 (push.const . \x2E;EQ?)
 (const . \x2E;eq?)
 (push.cons)
 (push.const . \x2E;EQV?)
 (const . \x2E;eqv?)
 (push.cons)
 (push.const . \x2E;MEMQ)
 (const . \x2E;memq)
 (push.cons)
 (push.const . \x2E;MEMV)
 (const . \x2E;memv)
 (push.cons)
 (push.const . \x2E;CALL-WITH-VALUES)
 (const . \x2E;call-with-values)
 (push.cons)
 (push.const . \x2E;APPLY)
 (const . \x2E;apply)
 (push.cons)
 (push.const . \x2E;CDR)
 (const . \x2E;cdr)
 (push.cons)
 (push.const . \x2E;IDENTIFIER?)
 (const . \x2E;identifier?)
 (push.cons)
 (push.const . \x2E;MAKE-VARIABLE-TRANSFORMER)
 (const . \x2E;make-variable-transformer)
 (push.cons)
 (push.const . \x2E;ASSERTION-VIOLATION)
 (const . \x2E;assertion-violation)
 (push.cons)
 (push.const . \x2E;UNSPECIFIED)
 (const . \x2E;unspecified)
 (push.cons)
 (push.const . \x2E;QUOTE)
 (gloc.of denote-quote)
 (push.cons)
 (push.const . \x2E;LET)
 (gloc.of denote-let)
 (push.cons)
 (push.const . \x2E;LETREC*)
 (gloc.of denote-letrec*)
 (push.cons)
 (push.const . \x2E;BEGIN)
 (gloc.of denote-begin)
 (push.cons)
 (push.const . \x2E;LAMBDA)
 (gloc.of denote-lambda)
 (push.cons)
 (push.const . \x2E;IF)
 (gloc.of denote-if)
 (push.cons)
 (push.const . \x2E;SET!)
 (gloc.of denote-set!)
 (push.cons)
 (push.const . \x2E;OR)
 (gloc.of denote-or)
 (push.cons)
 (push.const . \x2E;COND)
 (gloc.of denote-cond)
 (push.cons)
 (push.const . \x2E;ELSE)
 (gloc.of denote-else)
 (push.cons)
 (push.const . \x2E;DEFINE-SYNTAX)
 (gloc.of denote-define-syntax)
 (push.cons)
 (push.const . \x2E;SYNTAX)
 (gloc.of denote-syntax)
 (push.cons)
 (push.const . \x2E;SYNTAX-CASE)
 (gloc.of denote-syntax-case)
 (push.cons)
 (subr.gloc.of list 30 "./boot/macro/synenv.scm" . 362499)
 (set.gloc.of private-primitives-environment)
 (ret.const.unspec))
((push.gloc.of core-env)
 (ret.subr.gloc.of current-macro-environment "./boot/macro/synenv.scm" . 397313))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/compile.scm" . 5147))
 (set.gloc.of ht-local-closures)
 (ret.const.unspec))
((close
   (1 0 . local-closure?)
   (call
     (touch.gloc.of current-closure-comments)
     (apply.gloc.of current-closure-comments "./boot/compile.scm" . 9248))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 9228)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 10273)
   (push.const stack)
   (ret.subr.gloc.of memq "./boot/compile.scm" . 10267))
 (set.gloc.of local-closure?)
 (ret.const.unspec))
((close
   (1 0)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 16413)
   (if.not.pair?.ret.const . #f)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 17435)
   (const . lambda)
   (if.not.eq?.ret.const . #f)
   (call
     (touch.gloc.of local-closure?)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 18470)
     (apply.gloc.of local-closure? "./boot/compile.scm" . 18454))
   (if.false.ret)
   (call
     (touch.gloc.of ht-local-closures)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 19499))
   (push)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 19519)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 19478))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0 . collect-local-closure)
   (push.gloc.of \x2E;fn2.1\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/compile.scm" . 15365))
 (set.gloc.of collect-local-closure)
 (ret.const.unspec))
((close
   (1 0 . make-application-comment)
   (subr.gloc.of backtrace 0 "./boot/compile.scm" . 24585)
   (if.true
     (subr.gloc.of current-source-comments 0 "./boot/compile.scm" . 25616)
     (if.true
       (subr.gloc.of current-source-comments 0)
       (push)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 27676)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 29733)
         (if.true
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . \x2E;&SOURCE-PATH)
           (push.const . #f)
           (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 30766)
           (push.iloc.0 . 0)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 30834)
           (ret.subr.gloc.of \x2E;cons* "./boot/compile.scm" . 29729))
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . \x2E;&SOURCE-PATH)
         (push.const . #f)
         (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 31784)
         (iloc.0 . 0)
         (ret.cons "./boot/compile.scm" . 29729))
       (push.iloc.1 . 0)
       (ret.subr.gloc.of list "./boot/compile.scm" . 33820))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 35856))
   (ret.const))
 (set.gloc.of make-application-comment)
 (ret.const.unspec))
((close
   (1 0 . make-closure-comment)
   (call
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 40977))
     (if.false.ret)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/compile.scm" . 42021))
     (push)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of core-hashtable-ref "./boot/compile.scm" . 42001))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/compile.scm" . 40965))
   (ret.const))
 (set.gloc.of make-closure-comment)
 (ret.const.unspec))
((close
   (1 0 . top-level-subr)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 49162)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 50193)
   (subr.gloc.of subr? 1 "./boot/compile.scm" . 50186)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 51210))
 (set.gloc.of top-level-subr)
 (ret.const.unspec))
((close
   (1 0 . top-level-value-or-false)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 56330)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of top-level-value "./boot/compile.scm" . 57354))
 (set.gloc.of top-level-value-or-false)
 (ret.const.unspec))
((close
   (1 0 . formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 62479)
     (call
       (touch.gloc.of formals->list)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 62504)
       (apply.gloc.of formals->list "./boot/compile.scm" . 62489))
     (ret.cons "./boot/compile.scm" . 62473))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of list "./boot/compile.scm" . 64533))
 (set.gloc.of formals->list)
 (ret.const.unspec))
((close
   (2 0 . make-formals-operand)
   (push.iloc.0 . 1)
   (subr.gloc.of list? 1 "./boot/compile.scm" . 68620)
   (if.true
     (push.iloc.0 . 1)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 68642)
     (push.const . 0)
     (ret.subr.gloc.of list "./boot/compile.scm" . 68636))
   (iloc.0 . 1)
   (if.pair?
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 69669)
     (push.const . 1)
     (push.subr.gloc.of - 2 "./boot/compile.scm" . 69666)
     (push.const . 1)
     (ret.subr.gloc.of list "./boot/compile.scm" . 69660))
   (ret.const 0 1))
 (set.gloc.of make-formals-operand)
 (ret.const.unspec))
((close
   (2 0 . make-iloc-operand)
   (extend.enclose+
     (2 0 . loop1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 76824)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 76816)
     (if.true
       (push.iloc.0 . 1)
       (call
         (extend.enclose+
           (2 0 . loop2)
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 79905)
           (iloc 4 . 0)
           (if.eq? (ret.iloc 0 . 1))
           (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 81955)
           (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 81966)
           (apply.iloc+ (1 . 0) "./boot/compile.scm" . 81948))
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 78888)
         (push.const . 0)
         (apply.iloc+ (0 . 0) "./boot/compile.scm" . 78870))
       (ret.cons "./boot/compile.scm" . 75783))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 82967)
     (push.n+.iloc (0 . 1) 1 "./boot/compile.scm" . 82978)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 82960))
   (push.iloc.1 . 1)
   (push.const . 0)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 74757))
 (set.gloc.of make-iloc-operand)
 (ret.const.unspec))
((close
   (3 0 . iloc-iota)
   (extend.enclose+
     (2 0 . loop)
     (<n.iloc (0 . 0) 0 "./boot/compile.scm" . 89102)
     (if.true (ret.iloc 0 . 1))
     (push.n+.iloc (0 . 0) -1 "./boot/compile.scm" . 90137)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of + 2 "./boot/compile.scm" . 90167)
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 90131))
   (push.n+.iloc (1 . 2) -1 "./boot/compile.scm" . 88087)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 88069))
 (set.gloc.of iloc-iota)
 (ret.const.unspec))
((close
   (2 0 . cte-extend-iloc)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "./boot/compile.scm" . 94213))
 (set.gloc.of cte-extend-iloc)
 (ret.const.unspec))
((close
   (2 0 . iloc?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc 2 . 0)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 101405)
     (subr.gloc.of memq 2 "./boot/compile.scm" . 101397)
     (if.true.ret)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 102427)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 102421))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 99338))
 (set.gloc.of iloc?)
 (ret.const.unspec))
((close
   (1 0 . immediate-literal?)
   (push.iloc.0 . 0)
   (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 106505)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of char? 1 "./boot/compile.scm" . 106517)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of boolean? 1 "./boot/compile.scm" . 106527)
   (if.true.ret)
   (iloc.0 . 0)
   (if.null?.ret.const . #t)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 107549)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 107574)
   (ret.subr.gloc.of symbol? "./boot/compile.scm" . 107565))
 (set.gloc.of immediate-literal?)
 (ret.const.unspec))
((close
   (2 0 . compile-touch)
   (call
     (iloc.0 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of top-level-bound? 1 "./boot/compile.scm" . 113686)
     (if.true.ret.const . #f)
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 114710))
     (push)
     (ret.subr.gloc.of not "./boot/compile.scm" . 114705))
   (if.true
     (push.const . touch.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 112651)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 112651))
   (ret.const))
 (set.gloc.of compile-touch)
 (ret.const.unspec))
((close
   (4 0 . compile-lambda-helper)
   (call
     (touch.gloc.of formals->list)
     (push.iloc.0 . 0)
     (apply.gloc.of formals->list "./boot/compile.scm" . 120849))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of cte-extend-iloc)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 121874))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of make-formals-operand)
     (push.iloc.1 . 0)
     (push.iloc 2 . 0)
     (apply.gloc.of make-formals-operand "./boot/compile.scm" . 122900))
   (push)
   (push.iloc 2 . 2)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 122892)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.iloc 2 . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 123918))
   (ret.cons "./boot/compile.scm" . 121863))
 (set.gloc.of compile-lambda-helper)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 128027))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of cons)
     (push.gloc.of =)
     (push.gloc.of <)
     (push.gloc.of <=)
     (push.gloc.of >)
     (push.gloc.of >=)
     (push.gloc.of eq?)
     (push.gloc.of null?)
     (push.gloc.of pair?)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of eqv?)
     (push.gloc.of equal?)
     (push.subr.gloc.of list 18 "./boot/compile.scm" . 129039)
     (apply.gloc.of for-each "./boot/compile.scm" . 128005))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 130053))
 (set.gloc.of ht-special-subr-expression)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 133123)
 (set.gloc.of alist-special-binary-subr)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =n.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >n.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=n.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <n.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=n.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 136195)
 (set.gloc.of alist-special-binary-subr-negate)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . <=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . >=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 139267)
 (set.gloc.of alist-special-binary-subr-iloc)
 (ret.const.unspec))
((push.gloc.of =)
 (const . =.iloc)
 (push.cons)
 (push.gloc.of <)
 (const . >.iloc)
 (push.cons)
 (push.gloc.of <=)
 (const . >=.iloc)
 (push.cons)
 (push.gloc.of >)
 (const . <.iloc)
 (push.cons)
 (push.gloc.of >=)
 (const . <=.iloc)
 (push.cons)
 (subr.gloc.of list 5 "./boot/compile.scm" . 142339)
 (set.gloc.of alist-special-binary-subr-iloc-negate)
 (ret.const.unspec))
((close
   (4 0)
   (iloc.0 . 2)
   (if.true
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 150568)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 150545))
     (push)
     (push.const . ret.subr.gloc.of)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 150603)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 149513)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 149513)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 149513))
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151592)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 151569))
   (push)
   (push.const . subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 151623)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 151643)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 151635)
   (push.iloc.0 . 3)
   (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 149513)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 149513)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 149513))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (4 0 . compile-subr-expression)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 153620))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 154660)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 154643)
   (extend . 1)
   (push.gloc.of ht-special-subr-expression)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 155661)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 156699)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (iloc 2 . 2)
         (if.true.ret.const)
         (iloc 2 . 3)
         (if.true
           (push.const . ret.const.unspec)
           (push.subr.gloc.of list 1 "./boot/compile.scm" . 159789)
           (ret.subr.gloc.of list "./boot/compile.scm" . 159783))
         (push.const . const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 160813)
         (ret.subr.gloc.of list "./boot/compile.scm" . 160807))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 161824))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 162843)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of pair?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 165943)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 165923))
           (push)
           (push.const . ret.pair?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 164894)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 164894))
         (push.iloc.0 . 0)
         (gloc.of null?)
         (if.eq?
           (call
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 167991)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 167971))
           (push)
           (push.const . ret.null?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 166942)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 166942))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 170015))
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 171043)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 171036))
       (if.true
         (iloc 2 . 2)
         (if.true.ret.const)
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 175178)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 175159))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 174121)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 174121))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 177226)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 177207))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 176169)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 176169))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 179275)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 179256))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 178217)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 178217))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 181323)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 181304))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 180265)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 180265))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 183338))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 184348))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 185371)
     (if.null?
       (iloc 2 . 3)
       (if.true
         (push.iloc.0 . 0)
         (gloc.of cons)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 188469)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 188451))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 188508)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 188488))
           (push)
           (push.const . ret.cons)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 187422)
           (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 187422)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 187422))
         (push.iloc.0 . 0)
         (gloc.of eq?)
         (if.eq?
           (call
             (touch.gloc.of compile-argument)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 190517)
             (push.iloc 2 . 1)
             (apply.gloc.of compile-argument "./boot/compile.scm" . 190499))
           (push)
           (call
             (touch.gloc.of compile-expression)
             (push.iloc 2 . 0)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 190556)
             (push.iloc 2 . 1)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 190536))
           (push)
           (push.const . ret.eq?)
           (iloc.1 . 0)
           (push.cons)
           (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 189470)
           (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 189470)
           (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 189470))
         (push.iloc.0 . 0)
         (gloc.of eqv?)
         (if.eq?
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 192574)
           (extend . 1)
           (call
             (call
               (touch.gloc.of immediate-literal?)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 192555)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193577))
             (if.true.ret)
             (touch.gloc.of immediate-literal?)
             (push.iloc.0 . 0)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 193603))
           (if.true
             (call
               (touch.gloc.of compile-argument)
               (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 194619)
               (push.iloc 3 . 1)
               (apply.gloc.of compile-argument "./boot/compile.scm" . 194601))
             (push)
             (call
               (touch.gloc.of compile-expression)
               (push.iloc 3 . 0)
               (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 194658)
               (push.iloc 3 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 194638))
             (push)
             (push.const . ret.eq?)
             (iloc 2 . 0)
             (push.cons)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 193569)
             (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 193569)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 193569))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.iloc 2 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 195621))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 197663))
       (push.iloc.0 . 0)
       (push.gloc.of alist-special-binary-subr)
       (subr.gloc.of assq 2 "./boot/compile.scm" . 198687)
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 199723)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 199742)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 201787)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 201817))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 201858)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 201853)
             (ret.subr.gloc.of values "./boot/compile.scm" . 201835))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 202811)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 202841))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 202882)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 202877)
             (ret.subr.gloc.of values "./boot/compile.scm" . 202859))
           (push.const . #f)
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 203835))
         (push.close
           (3 0)
           (iloc.0 . 2)
           (if.true
             (push.iloc.0 . 2)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 204857))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 204841)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 204841))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 205866))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 206894))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 206937)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 206932)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 206982))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 205865)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 205865)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 205865))
           (call
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 207914))
           (if.true
             (call
               (touch.gloc.of compile-expression)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (push.const . #f)
               (push.const . #f)
               (apply.gloc.of compile-expression "./boot/compile.scm" . 208942))
             (push)
             (push.iloc 2 . 0)
             (push.gloc.of alist-special-binary-subr-iloc-negate)
             (push.subr.gloc.of assq 2 "./boot/compile.scm" . 208985)
             (push.subr.gloc.of cdr 1 "./boot/compile.scm" . 208980)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 209037))
             (push)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 207913)
             (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 207913)
             (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 207913))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 209967))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 199711))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 213035)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 213054)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (push.iloc.1 . 0)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 214085)
             (if.false.ret)
             (iloc.1 . 1)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 1)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 214115))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 214133))
           (call
             (push.iloc.1 . 1)
             (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 215109)
             (if.false.ret)
             (iloc.1 . 0)
             (if.not.symbol?.ret.const . #f)
             (touch.gloc.of iloc?)
             (push.iloc.1 . 0)
             (push.iloc 4 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 215139))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 215157))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 216133))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 218163))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 217123)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 217123))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 3)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 219175))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 213023))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 221227)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 221246)
         (extend . 2)
         (call
           (push.iloc.0 . 1)
           (subr.gloc.of fixnum? 1 "./boot/compile.scm" . 222250)
           (if.false.ret)
           (iloc.0 . 0)
           (if.not.symbol?.ret.const . #f)
           (touch.gloc.of iloc?)
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (apply.gloc.of iloc? "./boot/compile.scm" . 222280))
         (if.true
           (push.const . n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 223281))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 223311)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 222241)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 222241))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 3)
         (push.iloc 2 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 224293))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 227359))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 3)
     (push.iloc.1 . 0)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 229396))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc 2 . 3)
   (push.iloc.1 . 0)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 230413))
 (set.gloc.of compile-subr-expression)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of core-hashtable-set! "./boot/compile.scm" . 234523))
     (push.gloc.of unspecified)
     (push.gloc.of car)
     (push.gloc.of cdr)
     (push.gloc.of cadr)
     (push.gloc.of cddr)
     (push.gloc.of +)
     (push.gloc.of -)
     (push.gloc.of cons)
     (push.subr.gloc.of list 8 "./boot/compile.scm" . 235535)
     (apply.gloc.of for-each "./boot/compile.scm" . 234501))
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 236549))
 (set.gloc.of ht-special-subr-argument)
 (ret.const.unspec))
((close
   (3 0)
   (call
     (touch.gloc.of compile-argument-each)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243748)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 243725))
   (push)
   (push.const . push.subr.gloc.of)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 243784)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 243804)
   (push.subr.gloc.of length 1 "./boot/compile.scm" . 243796)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 242695)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 242695)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 242695))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (2 0 . compile-subr-argument)
   (call
     (touch.gloc.of make-application-comment)
     (push.iloc.0 . 0)
     (apply.gloc.of make-application-comment "./boot/compile.scm" . 245780))
   (push)
   (extend . 1)
   (push.car.iloc (1 . 0) "./boot/compile.scm" . 246820)
   (push.subr.gloc.of top-level-value 1 "./boot/compile.scm" . 246803)
   (extend . 1)
   (push.gloc.of ht-special-subr-argument)
   (push.iloc.0 . 0)
   (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 247821)
   (if.true
     (cdr.iloc (2 . 0) "./boot/compile.scm" . 248859)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of unspecified)
       (if.eq?
         (push.const . push.const.unspec)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 249912)
         (ret.subr.gloc.of list "./boot/compile.scm" . 249906))
       (push.const . subr.gloc.of)
       (push.car.iloc (2 . 0) "./boot/compile.scm" . 251948)
       (push.const 0)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 250906)
       (push.const . push)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 251963)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 250906))
     (cddr.iloc (2 . 0) "./boot/compile.scm" . 252955)
     (if.null?
       (call
         (touch.gloc.of iloc?)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 253983)
         (push.iloc 2 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 253976))
       (if.true
         (push.iloc.0 . 0)
         (gloc.of car)
         (if.eq?
           (push.const . push.car.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 255059)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 255040))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 255006)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 255006))
         (push.iloc.0 . 0)
         (gloc.of cdr)
         (if.eq?
           (push.const . push.cdr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 256083)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 256064))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 256030)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 256030))
         (push.iloc.0 . 0)
         (gloc.of cadr)
         (if.eq?
           (push.const . push.cadr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 257109)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 257090))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 257054)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 257054))
         (push.iloc.0 . 0)
         (gloc.of cddr)
         (if.eq?
           (push.const . push.cddr.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 258133)
             (push.iloc 2 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 258114))
           (push)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 258078)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 258078))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 259108))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 260120))
     (push.iloc 2 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 261147)
     (if.null?
       (push.iloc.0 . 0)
       (gloc.of cons)
       (if.eq?
         (call
           (touch.gloc.of compile-argument)
           (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 263217)
           (push.iloc 2 . 1)
           (apply.gloc.of compile-argument "./boot/compile.scm" . 263199))
         (push)
         (call
           (touch.gloc.of compile-expression)
           (push.iloc 2 . 0)
           (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 263256)
           (push.iloc 2 . 1)
           (push.const . #f)
           (push.const . #f)
           (apply.gloc.of compile-expression "./boot/compile.scm" . 263236))
         (push)
         (push.const . push.cons)
         (push.subr.gloc.of list 1 "./boot/compile.scm" . 263281)
         (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 262170)
         (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 262170)
         (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 262170))
       (push.iloc.0 . 0)
       (gloc.of +)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 265255)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 265274)
         (extend . 2)
         (push.close
           (0 0)
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 266305))
             (if.false.ret)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 266322))
           (if.true
             (push.iloc.1 . 0)
             (push.iloc.1 . 1)
             (ret.subr.gloc.of values "./boot/compile.scm" . 266338))
           (call
             (call
               (touch.gloc.of iloc?)
               (push.iloc.1 . 1)
               (push.iloc 4 . 1)
               (apply.gloc.of iloc? "./boot/compile.scm" . 267329))
             (if.false.ret)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 267346))
           (if.true
             (push.iloc.1 . 1)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of values "./boot/compile.scm" . 267362))
           (push.const . #f)
           (push.const . #f)
           (ret.subr.gloc.of values "./boot/compile.scm" . 268353))
         (push.close
           (2 0)
           (iloc.0 . 0)
           (if.true
             (push.const . push.n+.iloc)
             (call
               (touch.gloc.of make-iloc-operand)
               (push.iloc.0 . 0)
               (push.iloc 4 . 1)
               (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 270388))
             (push)
             (push.iloc.0 . 1)
             (push.iloc 3 . 0)
             (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 269343)
             (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 269343))
           (touch.gloc.of compile-anonymous\x60;2)
           (push.iloc 4 . 0)
           (push.iloc 4 . 1)
           (push.iloc 3 . 0)
           (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 271395))
         (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 265243))
       (push.iloc.0 . 0)
       (gloc.of -)
       (if.eq?
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 273447)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 273466)
         (extend . 2)
         (call
           (call
             (touch.gloc.of iloc?)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of iloc? "./boot/compile.scm" . 274470))
           (if.false.ret)
           (push.iloc.0 . 1)
           (ret.subr.gloc.of fixnum? "./boot/compile.scm" . 274487))
         (if.true
           (push.const . push.n+.iloc)
           (call
             (touch.gloc.of make-iloc-operand)
             (push.iloc.0 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 275506))
           (push)
           (push.iloc.0 . 1)
           (push.subr.gloc.of - 1 "./boot/compile.scm" . 275536)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;cons* 4 "./boot/compile.scm" . 274461)
           (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 274461))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 2 . 0)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 276513))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 278555))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc.1 . 0)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 280596))
   (cdr.iloc (2 . 0) "./boot/compile.scm" . 281624)
   (if.null?
     (push.const . subr.gloc.of)
     (push.car.iloc (2 . 0) "./boot/compile.scm" . 282658)
     (push.const 0)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 281613)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 282673)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 281613))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (push.iloc.1 . 0)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 283665))
 (set.gloc.of compile-subr-argument)
 (ret.const.unspec))
((close
   (2 0 . compile-argument-each)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of append)
       (push.iloc.0 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 288808)
       (apply.gloc.of apply "./boot/compile.scm" . 288794))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 291862)
     (call
       (touch.gloc.of compile-argument)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 290857)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 290839))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 291856))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 287749))
 (set.gloc.of compile-argument-each)
 (ret.const.unspec))
((close
   (2 0 . compile-argument)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 296995)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 296979))
     (if.true
       (touch.gloc.of compile-subr-argument)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of compile-subr-argument "./boot/compile.scm" . 298003))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 299032)
     (const . lambda)
     (if.eq?
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 300086)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 300098)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 300110))
         (push)
         (push.iloc.0 . 1)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 300063))
       (push)
       (extend . 1)
       (call
         (touch.gloc.of local-closure?)
         (push.iloc.1 . 0)
         (apply.gloc.of local-closure? "./boot/compile.scm" . 301081))
       (if.true
         (push.const . push.close+)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of list "./boot/compile.scm" . 302105))
       (push.const . push.close)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 303129))
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 304152)
     (const . quote)
     (if.eq?
       (push.const . push.const)
       (cadr.iloc (0 . 0) "./boot/compile.scm" . 305188)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 304146))
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 307223))
     (push)
     (push.const . push)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 307260)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 306194)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 306194))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 0)
     (const . \x2E;&UNDEF)
     (if.eq?
       (push.const . push.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 309293)
       (ret.subr.gloc.of list "./boot/compile.scm" . 309287))
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 311319))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 312354))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 313375)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . push.iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 314418)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 314395))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . push.iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 315442)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 315419))
       (push.const . push.iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 316443))
     (push.const . push.gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 311315)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 311315))
   (push.const . push.const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 318475))
 (set.gloc.of compile-argument)
 (ret.const.unspec))
((close
   (4 0 . compile-call)
   (iloc.0 . 0)
   (if.pair?
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 324624))
     (push)
     (push.const . apply)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 324661)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 323595)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 323595))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 3)
       (apply.gloc.of iloc? "./boot/compile.scm" . 326675))
     (if.true
       (call
         (touch.gloc.of ht-local-closures)
         (apply.gloc.of ht-local-closures "./boot/compile.scm" . 327729))
       (push)
       (push.iloc.0 . 0)
       (subr.gloc.of core-hashtable-contains? 2 "./boot/compile.scm" . 327703)
       (if.true
         (push.const . apply.iloc+)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 3)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 328743))
         (push)
         (push.iloc.0 . 2)
         (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 327699)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 327699))
       (push.const . apply.iloc)
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 329766))
       (push)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 327699)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 327699))
     (call
       (touch.gloc.of top-level-subr)
       (push.iloc.0 . 0)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 330771))
     (if.true
       (push.const . ret.subr.gloc.of)
       (push.iloc.0 . 0)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 330770)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 330770))
     (push.const . apply.gloc.of)
     (push.iloc.0 . 0)
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/compile.scm" . 332818)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 332818))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (push.const . apply)
   (iloc.0 . 2)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 334859))
 (set.gloc.of compile-call)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-begin)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 339985)
   (extend . 1)
   (iloc.0 . 0)
   (if.null?
     (iloc.1 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 342045)
       (ret.subr.gloc.of list "./boot/compile.scm" . 342039))
     (ret.const))
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 343061)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 344098)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 344078))
   (touch.gloc.of compile-expression-seq)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 346126))
 (set.gloc.of compile-expression-begin)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-quote)
   (iloc.0 . 2)
   (if.true.ret.const)
   (iloc.0 . 3)
   (if.true
     (push.const . ret.const)
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 352269))
   (push.const . const)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 350226)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 353293))
 (set.gloc.of compile-expression-quote)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-define)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 357413)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 357393))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 359454)
   (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 357381)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 358434)
       (ret.subr.gloc.of list "./boot/compile.scm" . 358428))
     (ret.const))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 357381))
 (set.gloc.of compile-expression-define)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-set!)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 363557)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 363537))
   (push)
   (call
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 364578)
       (ret.subr.gloc.of list "./boot/compile.scm" . 364572))
     (ret.const))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of iloc?)
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 365589)
     (push.iloc.1 . 1)
     (apply.gloc.of iloc? "./boot/compile.scm" . 365582))
   (if.true
     (push.iloc.0 . 0)
     (push.const . set.iloc)
     (call
       (touch.gloc.of make-iloc-operand)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 366646)
       (push.iloc.1 . 1)
       (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 366627))
     (push.cons)
     (iloc.0 . 1)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 365581))
   (push.iloc.0 . 0)
   (call
     (subr.gloc.of backtrace 0 "./boot/compile.scm" . 368671)
     (if.true
       (touch.gloc.of compile-touch)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 368698)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-touch "./boot/compile.scm" . 368683))
     (ret.const))
   (push)
   (push.const . set.gloc.of)
   (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 369711)
   (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 368654)
   (iloc.0 . 1)
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 368654)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 368654))
 (set.gloc.of compile-expression-set!)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-lambda)
   (call
     (touch.gloc.of compile-lambda-helper)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 373800)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 373812)
     (call
       (touch.gloc.of make-closure-comment)
       (push.iloc.0 . 0)
       (apply.gloc.of make-closure-comment "./boot/compile.scm" . 373824))
     (push)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 373777))
   (push)
   (extend . 1)
   (iloc.1 . 2)
   (if.true.ret.const)
   (iloc.1 . 3)
   (if.true
     (push.const . ret.close)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 375821))
   (push.const . close)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 376845))
 (set.gloc.of compile-expression-lambda)
 (ret.const.unspec))
((close
   (4 0 . compile-expression-let)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 380947)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 381988)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 381964))
   (call
     (touch.gloc.of collect-local-closure)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 384035)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 384012))
   (call
     (push.gloc.of car)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 385057)
     (apply.gloc.of map "./boot/compile.scm" . 385048))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of compile-argument-each)
     (call
       (push.gloc.of cadr)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 386111)
       (apply.gloc.of map "./boot/compile.scm" . 386101))
     (push)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument-each "./boot/compile.scm" . 386078))
   (push)
   (push.const . extend)
   (push.iloc.0 . 0)
   (subr.gloc.of length 1 "./boot/compile.scm" . 387113)
   (push.cons)
   (call
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (1 . 0) "./boot/compile.scm" . 388152)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 388164))
     (push)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 388128))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 386068)
   (extend . 1)
   (iloc 2 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 389150))
 (set.gloc.of compile-expression-let)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (push.const . set.iloc)
   (iloc.0 . 0)
   (push.cons)
   (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 426038)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 426038))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (4 0 . compile-expression-letrec*)
   (cadr.iloc (0 . 0) "./boot/compile.scm" . 393235)
   (if.null?
     (touch.gloc.of compile-expression-seq)
     (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 394276)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 394252))
   (push.iloc.0 . 0)
   (subr.gloc.of cdadr 1 "./boot/compile.scm" . 395283)
   (if.null?
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 396315)
     (extend . 1)
     (call
       (touch.gloc.of cte-extend-iloc)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 397360)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 397354)
       (push.iloc.1 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 397337))
     (push)
     (extend . 1)
     (call
       (cadr.iloc (1 . 0) "./boot/compile.scm" . 398371)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 398392)
       (const . lambda)
       (ret.eq? "./boot/compile.scm" . 398387))
     (if.true
       (call
         (touch.gloc.of collect-local-closure)
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 399406)
         (apply.gloc.of collect-local-closure "./boot/compile.scm" . 399383))
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 400419)
       (extend . 1)
       (call
         (call
           (touch.gloc.of local-closure?)
           (push.iloc.0 . 0)
           (apply.gloc.of local-closure? "./boot/compile.scm" . 403497))
         (if.true (ret.const . extend.enclose+))
         (ret.const . extend.enclose))
       (push)
       (call
         (touch.gloc.of compile-lambda-helper)
         (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 401473)
         (push.cddr.iloc (0 . 0) "./boot/compile.scm" . 401485)
         (call
           (touch.gloc.of make-closure-comment)
           (push.iloc.0 . 0)
           (apply.gloc.of make-closure-comment "./boot/compile.scm" . 401497))
         (push)
         (push.iloc.1 . 0)
         (apply.gloc.of compile-lambda-helper "./boot/compile.scm" . 401450))
       (push.cons)
       (call
         (touch.gloc.of compile-expression-seq)
         (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 402498)
         (push.iloc.1 . 0)
         (push.const . #f)
         (push.const . #t)
         (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 402474))
       (push.cons)
       (extend . 1)
       (iloc 4 . 3)
       (if.true (ret.iloc 0 . 0))
       (push.const . call)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 405547))
     (push.const . extend.unbound)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-argument)
       (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 408634)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument "./boot/compile.scm" . 408616))
     (push)
     (push.const . enclose)
     (const . 1)
     (push.cons)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (2 . 0) "./boot/compile.scm" . 410688)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 410664))
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 407581)
     (push.cons)
     (extend . 1)
     (iloc 3 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 411687))
   (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 413724)
   (extend . 1)
   (call
     (touch.gloc.of collect-local-closure)
     (push.iloc.0 . 0)
     (apply.gloc.of collect-local-closure "./boot/compile.scm" . 414734))
   (push.close
     (0 0)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc 3 . 0)
         (push.const)
         (ret.subr.gloc.of values "./boot/compile.scm" . 418850))
       (push.iloc.0 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 419886)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.pair?
           (push.car.iloc (0 . 0) "./boot/compile.scm" . 420927)
           (push.const quote lambda)
           (ret.subr.gloc.of memq "./boot/compile.scm" . 420921))
         (push.iloc.0 . 0)
         (push.subr.gloc.of symbol? 1 "./boot/compile.scm" . 420960)
         (ret.subr.gloc.of not "./boot/compile.scm" . 420955))
       (if.true
         (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 421934)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 421950)
         (iloc.1 . 1)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/compile.scm" . 421928))
       (push.iloc.1 . 1)
       (push.subr.gloc.of reverse 1 "./boot/compile.scm" . 422960)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of values "./boot/compile.scm" . 422952))
     (push.iloc 2 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "./boot/compile.scm" . 416796))
   (push.close
     (2 0)
     (call
       (touch.gloc.of cte-extend-iloc)
       (call (push.gloc.of car) (push.iloc.1 . 0) (apply.gloc.of map "./boot/compile.scm" . 423980))
       (push)
       (push.iloc 2 . 1)
       (apply.gloc.of cte-extend-iloc "./boot/compile.scm" . 423963))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of compile-argument-each)
       (call
         (push.gloc.of cadr)
         (push.iloc.1 . 0)
         (apply.gloc.of map "./boot/compile.scm" . 425019))
       (push)
       (push.iloc.0 . 0)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 424996))
     (push)
     (call
       (push.gloc.of append)
       (call
         (push.gloc.of \x2E;fn2.1\x60;2)
         (call
           (touch.gloc.of iloc-iota)
           (push.const . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427075)
           (push.iloc.1 . 1)
           (push.subr.gloc.of length 1 "./boot/compile.scm" . 427090)
           (apply.gloc.of iloc-iota "./boot/compile.scm" . 427062))
         (push)
         (call
           (push.close
             (1 0)
             (touch.gloc.of compile-expression)
             (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 428123)
             (push.iloc.1 . 0)
             (push.const . #f)
             (push.const . #f)
             (apply.gloc.of compile-expression "./boot/compile.scm" . 428103))
           (push.iloc.1 . 1)
           (apply.gloc.of map "./boot/compile.scm" . 428086))
         (push)
         (apply.gloc.of map "./boot/compile.scm" . 426033))
       (push)
       (apply.gloc.of apply "./boot/compile.scm" . 426019))
     (push)
     (call
       (touch.gloc.of compile-expression-seq)
       (push.cddr.iloc (3 . 0) "./boot/compile.scm" . 429115)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression-seq "./boot/compile.scm" . 429091))
     (push)
     (extend . 3)
     (call
       (iloc.0 . 0)
       (if.null?
         (push.const . extend.unbound)
         (push.iloc 3 . 0)
         (subr.gloc.of length 1 "./boot/compile.scm" . 431161)
         (push.cons)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
         (ret.cons "./boot/compile.scm" . 430112))
       (push.const . extend.unbound)
       (push.iloc 3 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432185)
       (push.cons)
       (push.iloc.0 . 0)
       (push.const . enclose)
       (push.iloc.0 . 0)
       (subr.gloc.of length 1 "./boot/compile.scm" . 432229)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
       (push.cons)
       (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 430112)
       (ret.cons "./boot/compile.scm" . 430112))
     (push)
     (extend . 1)
     (iloc 5 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 433188))
   (apply.gloc.of \x2E;call-with-values "./boot/compile.scm" . 413708))
 (set.gloc.of compile-expression-letrec*)
 (ret.const.unspec))
((close
   (5 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cadadr 1 "./boot/compile.scm" . 460820)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 461845)
   (extend . 2)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 462875))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 463900))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 464945)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 464925))
   (push)
   (extend . 3)
   (call
     (push.iloc 2 . 4)
     (const . if.null?.ret.const)
     (if.not.eq?.ret.const . #f)
     (iloc.1 . 0)
     (if.not.symbol?.ret.const . #f)
     (push.iloc.1 . 0)
     (iloc.1 . 1)
     (ret.eq? "./boot/compile.scm" . 466000))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 466970)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 466970))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 4)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 467994)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 467994)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 467994))
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 470052)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 470075)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 470069))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 471109)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 471070))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 472094)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 472094))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 473118))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 474142)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 474142))
 (set.gloc.of compile-unary-special\x60;2)
 (close
   (4 0)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 441390)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 441370))
   (push)
   (extend . 1)
   (call
     (cdr.iloc (0 . 0) "./boot/compile.scm" . 442395)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 442417)
     (const . const)
     (ret.eq? "./boot/compile.scm" . 442412))
   (if.true
     (push.iloc.0 . 0)
     (subr.gloc.of cdar 1 "./boot/compile.scm" . 443411)
     (if.true
       (touch.gloc.of compile-expression)
       (push.iloc.1 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 444455)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 444435))
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 445479)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 445459))
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 446517)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 446497))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 447540)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 447520))
   (push)
   (extend . 2)
   (call
     (cadr.iloc (2 . 0) "./boot/compile.scm" . 448547)
     (if.not.symbol?.ret.const . #f)
     (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 448565)
     (push.iloc 2 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 448577)
     (ret.eq? "./boot/compile.scm" . 448560))
   (if.true
     (iloc 2 . 3)
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 449584)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 449563))
     (push.const . call)
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 450587)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 450587))
   (iloc 2 . 3)
   (if.true
     (call
       (cdr.iloc (0 . 1) "./boot/compile.scm" . 452652)
       (if.not.null?.ret.const . #f)
       (push.iloc.0 . 1)
       (push.subr.gloc.of caar 1 "./boot/compile.scm" . 452674)
       (const . ret.const)
       (ret.eq? "./boot/compile.scm" . 452669))
     (if.true
       (push.iloc.1 . 0)
       (push.const . if.true.ret.const)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 453700)
       (push.cons)
       (iloc.0 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 452636))
     (push.iloc.1 . 0)
     (push.const . if.true)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 452636))
   (push.const . call)
   (push.iloc.1 . 0)
   (push.const . if.true)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 0)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 455707)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 455707))
 (set.gloc.of compile-anonymous\x60;2)
 (close
   (5 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of cdadr 1 "./boot/compile.scm" . 478229)
   (push.iloc.0 . 0)
   (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 479253)
   (extend . 2)
   (call
     (touch.gloc.of compile-argument)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 480309)
     (push.iloc.1 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 480291))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 481335)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 481315))
   (push)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 480283)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 1)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 482332))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.1 . 0)
     (push.subr.gloc.of cadddr 1 "./boot/compile.scm" . 483377)
     (push.iloc.1 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 483357))
   (push)
   (extend . 3)
   (call
     (cdr.iloc (0 . 1) "./boot/compile.scm" . 484381)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 1)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 484404)
     (push.const const ret.const)
     (ret.subr.gloc.of memq "./boot/compile.scm" . 484398))
   (if.true
     (iloc 2 . 2)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 4)
       (push.iloc.0 . 1)
       (subr.gloc.of cdar 1 "./boot/compile.scm" . 485438)
       (push.cons)
       (iloc.0 . 2)
       (push.cons)
       (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 485399))
     (push.const . call)
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 486423)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 486423))
   (iloc 2 . 2)
   (if.true
     (push.iloc.0 . 0)
     (push.iloc 2 . 3)
     (iloc.0 . 1)
     (push.cons)
     (iloc.0 . 2)
     (push.cons)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 487447))
   (push.const . call)
   (push.iloc.0 . 0)
   (push.iloc 2 . 3)
   (iloc.0 . 1)
   (push.cons)
   (iloc.0 . 2)
   (push.cons)
   (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 488471)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 488471))
 (set.gloc.of compile-binary-special\x60;2)
 (close
   (4 0 . compile-expression-if)
   (push.iloc.0 . 0)
   (subr.gloc.of cdddr 1 "./boot/compile.scm" . 492563)
   (if.null?
     (iloc.0 . 2)
     (if.true
       (touch.gloc.of compile-expression)
       (push.const . and)
       (cdr.iloc (0 . 0) "./boot/compile.scm" . 494636)
       (push.cons)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 494608))
     (touch.gloc.of compile-expression)
     (push.const . if)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 495659)
     (push.const (\x2E;unspecified))
     (subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 495632)
     (push.cons)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 495632))
   (call
     (cadr.iloc (0 . 0) "./boot/compile.scm" . 497695)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caadr 1 "./boot/compile.scm" . 497724)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 497708))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.cadr.iloc (1 . 0) "./boot/compile.scm" . 499750)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 499742)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.null?)
         (push.const . if.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 502818))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.pair?)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 504866))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.symbol?)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;2 "./boot/compile.scm" . 506914))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 508962))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;2)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 3)
         (push.const . if.eq?)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;2 "./boot/compile.scm" . 512034))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 513078))
       (if.true
         (push.cadr.iloc (2 . 0) "./boot/compile.scm" . 514127)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 514120)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.cadr.iloc (3 . 0) "./boot/compile.scm" . 514100)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 514094)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515116))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 515142))
         (if.true
           (touch.gloc.of compile-binary-special\x60;2)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 3)
           (push.const . if.eq?)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;2 "./boot/compile.scm" . 516136))
         (touch.gloc.of compile-anonymous\x60;2)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 517160))
       (touch.gloc.of compile-anonymous\x60;2)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (push.iloc 2 . 3)
       (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 519202))
     (touch.gloc.of compile-anonymous\x60;2)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.iloc 2 . 3)
     (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 521243))
   (touch.gloc.of compile-anonymous\x60;2)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (apply.gloc.of compile-anonymous\x60;2 "./boot/compile.scm" . 523283))
 (set.gloc.of compile-expression-if)
 (ret.const.unspec))
((close
   (2 0)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 533541)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 533521))
   (push)
   (push.const . if.true.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 533563)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 533601)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 533585))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 532491))
 (set.gloc.of compile-anonymous\x60;4)
 (close
   (2 0)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 537637)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 537617))
   (push)
   (push.const . if.false.ret.const)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 537707)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 537691))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 536587))
 (set.gloc.of compile-anonymous-negate\x60;4)
 (close
   (3 0)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 541733)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 541713))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 541790)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 541774))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 540683))
 (set.gloc.of compile-unary-special\x60;4)
 (close
   (3 0)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 545827)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 545809))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 545866)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 545846))
   (push)
   (push.iloc.0 . 2)
   (const . #t)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 545924)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 545908))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 544779)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 544779))
 (set.gloc.of compile-binary-special\x60;4)
 (close
   (2 0)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 547860)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 548897)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 548877))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 549920)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 549947)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 549931))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 553006)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 553018)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 554034)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 554061)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 554045))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 556089)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 556081)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.null?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 559157))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.pair?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 561205))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.symbol?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 563253))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 565301))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of compile-binary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.not.eq?.ret.const)
             (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 568373))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 569417))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 570464)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 570457)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 570439)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 570433)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571455))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 571481))
             (if.true
               (touch.gloc.of compile-binary-special\x60;4)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.not.eq?.ret.const)
               (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 572475))
             (touch.gloc.of compile-anonymous-negate\x60;4)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 573499))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 575541))
         (touch.gloc.of compile-anonymous-negate\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 577582))
       (touch.gloc.of compile-anonymous-negate\x60;4)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 579622))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 580651)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 580643)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 583719))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 585767))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 587815))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 589863))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 592935))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 593979))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 595026)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 595019)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 595001)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 594995)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596017))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 596043))
         (if.true
           (touch.gloc.of compile-binary-special\x60;4)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 597037))
         (touch.gloc.of compile-anonymous\x60;4)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 598061))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 600103))
     (touch.gloc.of compile-anonymous\x60;4)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 602144))
   (touch.gloc.of compile-anonymous\x60;4)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 604180))
 (set.gloc.of compile-clause\x60;2)
 (close
   (4 0 . compile-expression-or)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 606227)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #f)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 608280))
     (push.const . const)
     (const . #f)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 609304))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 610323)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 611360)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 611340))
   (call
     (iloc.0 . 3)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of cdddr 1 "./boot/compile.scm" . 613400)
     (if.not.null?.ret.const . #f)
     (push.iloc.0 . 0)
     (subr.gloc.of caddr 1 "./boot/compile.scm" . 614424)
     (if.not.pair?.ret.const . #f)
     (call
       (touch.gloc.of top-level-value-or-false)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caaddr 1 "./boot/compile.scm" . 615472)
       (apply.gloc.of top-level-value-or-false "./boot/compile.scm" . 615446))
     (push)
     (gloc.of assertion-violation)
     (ret.eq? "./boot/compile.scm" . 615441))
   (if.true
     (call
       (touch.gloc.of compile-expression)
       (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 616484)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #f)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616464))
     (push)
     (push.const . if.false.call)
     (call
       (touch.gloc.of compile-expression)
       (push.iloc.0 . 0)
       (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 616544)
       (push.iloc.0 . 1)
       (push.const . #f)
       (push.const . #t)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 616524))
     (push.cons)
     (push.subr.gloc.of \x2E;list 1 "./boot/compile.scm" . 612363)
     (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 612363))
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 618536)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 618520))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 619548))
 (set.gloc.of compile-expression-or)
 (ret.const.unspec))
((close
   (2 0)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 629797)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 629777))
   (push)
   (push.const . if.false.ret)
   (push.subr.gloc.of list 1 "./boot/compile.scm" . 629819)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 629858)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 629842))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 628747))
 (set.gloc.of compile-anonymous\x60;4)
 (close
   (2 0)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 644116)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 645153)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 645133))
   (call
     (car.iloc (0 . 0) "./boot/compile.scm" . 646176)
     (if.not.pair?.ret.const . #f)
     (touch.gloc.of top-level-subr)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caar 1 "./boot/compile.scm" . 646203)
     (apply.gloc.of top-level-subr "./boot/compile.scm" . 646187))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (gloc.of not)
     (if.eq?
       (push.iloc.1 . 0)
       (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 649262)
       (cdr.iloc (1 . 0) "./boot/compile.scm" . 649274)
       (push.cons)
       (extend . 1)
       (call
         (car.iloc (0 . 0) "./boot/compile.scm" . 650290)
         (if.not.pair?.ret.const . #f)
         (touch.gloc.of top-level-subr)
         (push.iloc.0 . 0)
         (push.subr.gloc.of caar 1 "./boot/compile.scm" . 650317)
         (apply.gloc.of top-level-subr "./boot/compile.scm" . 650301))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 652345)
         (push.subr.gloc.of length 1 "./boot/compile.scm" . 652337)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . 2)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of null?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.null?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 655413))
           (push.iloc.1 . 0)
           (gloc.of pair?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.pair?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 657461))
           (push.iloc.1 . 0)
           (gloc.of symbol?)
           (if.eq?
             (touch.gloc.of compile-unary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.symbol?.ret.const)
             (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 659509))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 661557))
         (push.iloc.0 . 0)
         (const . 3)
         (if.eq?
           (push.iloc.1 . 0)
           (gloc.of eq?)
           (if.eq?
             (touch.gloc.of compile-binary-special\x60;4)
             (push.iloc 2 . 0)
             (push.iloc 4 . 1)
             (push.const . if.eq?.ret.const)
             (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 664629))
           (call
             (push.iloc.1 . 0)
             (gloc.of eqv?)
             (if.eq?.ret.const . #t)
             (push.iloc.1 . 0)
             (gloc.of equal?)
             (ret.eq? "./boot/compile.scm" . 665673))
           (if.true
             (push.car.iloc (2 . 0) "./boot/compile.scm" . 666720)
             (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 666713)
             (extend . 1)
             (call
               (call
                 (touch.gloc.of immediate-literal?)
                 (push.car.iloc (3 . 0) "./boot/compile.scm" . 666695)
                 (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 666689)
                 (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667711))
               (if.true.ret)
               (touch.gloc.of immediate-literal?)
               (push.iloc.0 . 0)
               (apply.gloc.of immediate-literal? "./boot/compile.scm" . 667737))
             (if.true
               (touch.gloc.of compile-binary-special\x60;4)
               (push.iloc 3 . 0)
               (push.iloc 5 . 1)
               (push.const . if.eq?.ret.const)
               (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 668731))
             (touch.gloc.of compile-anonymous-negate\x60;4)
             (push.iloc 3 . 0)
             (push.iloc 5 . 1)
             (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 669755))
           (touch.gloc.of compile-anonymous-negate\x60;4)
           (push.iloc 2 . 0)
           (push.iloc 4 . 1)
           (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 671797))
         (touch.gloc.of compile-anonymous-negate\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 4 . 1)
         (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 673838))
       (touch.gloc.of compile-anonymous-negate\x60;4)
       (push.iloc.1 . 0)
       (push.iloc 3 . 1)
       (apply.gloc.of compile-anonymous-negate\x60;4 "./boot/compile.scm" . 675878))
     (push.car.iloc (1 . 0) "./boot/compile.scm" . 676907)
     (push.subr.gloc.of length 1 "./boot/compile.scm" . 676899)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . 2)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of null?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.null?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 679975))
       (push.iloc.1 . 0)
       (gloc.of pair?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.pair?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 682023))
       (push.iloc.1 . 0)
       (gloc.of symbol?)
       (if.eq?
         (touch.gloc.of compile-unary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.symbol?.ret.const)
         (apply.gloc.of compile-unary-special\x60;4 "./boot/compile.scm" . 684071))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 686119))
     (push.iloc.0 . 0)
     (const . 3)
     (if.eq?
       (push.iloc.1 . 0)
       (gloc.of eq?)
       (if.eq?
         (touch.gloc.of compile-binary-special\x60;4)
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.const . if.not.eq?.ret.const)
         (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 689191))
       (call
         (push.iloc.1 . 0)
         (gloc.of eqv?)
         (if.eq?.ret.const . #t)
         (push.iloc.1 . 0)
         (gloc.of equal?)
         (ret.eq? "./boot/compile.scm" . 690235))
       (if.true
         (push.car.iloc (2 . 0) "./boot/compile.scm" . 691282)
         (push.subr.gloc.of caddr 1 "./boot/compile.scm" . 691275)
         (extend . 1)
         (call
           (call
             (touch.gloc.of immediate-literal?)
             (push.car.iloc (3 . 0) "./boot/compile.scm" . 691257)
             (push.subr.gloc.of cadr 1 "./boot/compile.scm" . 691251)
             (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692273))
           (if.true.ret)
           (touch.gloc.of immediate-literal?)
           (push.iloc.0 . 0)
           (apply.gloc.of immediate-literal? "./boot/compile.scm" . 692299))
         (if.true
           (touch.gloc.of compile-binary-special\x60;4)
           (push.iloc 3 . 0)
           (push.iloc 3 . 1)
           (push.const . if.not.eq?.ret.const)
           (apply.gloc.of compile-binary-special\x60;4 "./boot/compile.scm" . 693293))
         (touch.gloc.of compile-anonymous\x60;4)
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 694317))
       (touch.gloc.of compile-anonymous\x60;4)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 696359))
     (touch.gloc.of compile-anonymous\x60;4)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 698400))
   (touch.gloc.of compile-anonymous\x60;4)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of compile-anonymous\x60;4 "./boot/compile.scm" . 700436))
 (set.gloc.of compile-clause\x60;2)
 (close
   (2 0)
   (call
     (touch.gloc.of compile-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 633893)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 633873))
   (push)
   (push.const . if.true.ret.const)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 633962)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 633946))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 632843))
 (set.gloc.of compile-anonymous-negate\x60;4)
 (close
   (3 0)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 637989)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 637969))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 638046)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 638030))
   (push.cons)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 636939))
 (set.gloc.of compile-unary-special\x60;4)
 (close
   (3 0)
   (call
     (touch.gloc.of compile-argument)
     (push.iloc.0 . 0)
     (push.subr.gloc.of cadar 1 "./boot/compile.scm" . 642083)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-argument "./boot/compile.scm" . 642065))
   (push)
   (call
     (touch.gloc.of compile-expression)
     (push.iloc.0 . 0)
     (push.subr.gloc.of caddar 1 "./boot/compile.scm" . 642122)
     (push.iloc.0 . 1)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 642102))
   (push)
   (push.iloc.0 . 2)
   (const . #f)
   (push.cons)
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 642180)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 642164))
   (push.cons)
   (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 641035)
   (ret.subr.gloc.of \x2E;append "./boot/compile.scm" . 641035))
 (set.gloc.of compile-binary-special\x60;4)
 (close
   (4 0 . compile-expression-and)
   (cdr.iloc (0 . 0) "./boot/compile.scm" . 702483)
   (if.null?
     (iloc.0 . 2)
     (if.true.ret.const)
     (iloc.0 . 3)
     (if.true
       (push.const . ret.const)
       (const . #t)
       (push.cons)
       (ret.subr.gloc.of list "./boot/compile.scm" . 704536))
     (push.const . const)
     (const . #t)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 705560))
   (cddr.iloc (0 . 0) "./boot/compile.scm" . 706579)
   (if.null?
     (touch.gloc.of compile-expression)
     (push.cadr.iloc (0 . 0) "./boot/compile.scm" . 707616)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 707596))
   (call
     (touch.gloc.of compile-clause\x60;2)
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 709672)
     (push.iloc.0 . 1)
     (apply.gloc.of compile-clause\x60;2 "./boot/compile.scm" . 709656))
   (push)
   (extend . 1)
   (iloc.1 . 3)
   (if.true (ret.iloc 0 . 0))
   (push.const . call)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of list "./boot/compile.scm" . 710684))
 (set.gloc.of compile-expression-and)
 (ret.const.unspec))
((call
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . begin)
   (push.gloc.of compile-expression-begin)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 714757)
   (push.iloc.0 . 0)
   (push.const . quote)
   (push.gloc.of compile-expression-quote)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 715781)
   (push.iloc.0 . 0)
   (push.const . define)
   (push.gloc.of compile-expression-define)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 716805)
   (push.iloc.0 . 0)
   (push.const . set!)
   (push.gloc.of compile-expression-set!)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 717829)
   (push.iloc.0 . 0)
   (push.const . lambda)
   (push.gloc.of compile-expression-lambda)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 718853)
   (push.iloc.0 . 0)
   (push.const . let)
   (push.gloc.of compile-expression-let)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 719877)
   (push.iloc.0 . 0)
   (push.const . letrec*)
   (push.gloc.of compile-expression-letrec*)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 720901)
   (push.iloc.0 . 0)
   (push.const . if)
   (push.gloc.of compile-expression-if)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 721925)
   (push.iloc.0 . 0)
   (push.const . or)
   (push.gloc.of compile-expression-or)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 722949)
   (push.iloc.0 . 0)
   (push.const . and)
   (push.gloc.of compile-expression-and)
   (subr.gloc.of core-hashtable-set! 3 "./boot/compile.scm" . 723973)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-copy "./boot/compile.scm" . 724997))
 (set.gloc.of ht-dispatch-expression)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of loop\x60;7)
   (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 735256)
   (push.car.iloc (0 . 0) "./boot/compile.scm" . 735274)
   (push.iloc.0 . 1)
   (push.subr.gloc.of append 2 "./boot/compile.scm" . 735266)
   (apply.gloc.of loop\x60;7 "./boot/compile.scm" . 735250))
 (set.gloc.of loop\x60;7)
 (close
   (1 0)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/compile.scm" . 732169))
 (set.gloc.of reverse-append\x60;2)
 (close
   (4 0 . compile-expression-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (touch.gloc.of reverse-append\x60;2)
       (push.iloc.0 . 1)
       (apply.gloc.of reverse-append\x60;2 "./boot/compile.scm" . 740378))
     (push.cdr.iloc (0 . 0) "./boot/compile.scm" . 747542)
     (call
       (touch.gloc.of compile-expression)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 743448)
       (push.iloc 2 . 1)
       (call
         (iloc 2 . 2)
         (if.true.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 745515)
         (ret.pair? "./boot/compile.scm" . 745508))
       (push)
       (call
         (iloc 2 . 3)
         (if.false.ret)
         (cdr.iloc (0 . 0) "./boot/compile.scm" . 746537)
         (ret.null? "./boot/compile.scm" . 746530))
       (push)
       (apply.gloc.of compile-expression "./boot/compile.scm" . 742423))
     (push)
     (iloc.0 . 1)
     (push.cons)
     (apply.iloc+ (1 . 0) "./boot/compile.scm" . 747536))
   (push.iloc.1 . 0)
   (push.const)
   (apply.iloc+ (0 . 0) "./boot/compile.scm" . 739333))
 (set.gloc.of compile-expression-seq)
 (ret.const.unspec))
((close
   (4 0 . compile-expression)
   (iloc.0 . 0)
   (if.pair?
     (push.gloc.of ht-dispatch-expression)
     (push.car.iloc (0 . 0) "./boot/compile.scm" . 755774)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/compile.scm" . 755731)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.iloc (0 . 0) "./boot/compile.scm" . 756773))
     (call
       (touch.gloc.of top-level-subr)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 757795)
       (apply.gloc.of top-level-subr "./boot/compile.scm" . 757779))
     (if.true
       (touch.gloc.of compile-subr-expression)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (apply.gloc.of compile-subr-expression "./boot/compile.scm" . 758803))
     (call
       (subr.gloc.of backtrace 0 "./boot/compile.scm" . 762916)
       (if.true
         (touch.gloc.of compile-touch)
         (push.car.iloc (1 . 0) "./boot/compile.scm" . 762943)
         (push.iloc.1 . 1)
         (apply.gloc.of compile-touch "./boot/compile.scm" . 762928))
       (ret.const))
     (push)
     (call
       (touch.gloc.of compile-argument-each)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 761910)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-argument-each "./boot/compile.scm" . 761887))
     (push)
     (call
       (touch.gloc.of compile-call)
       (push.car.iloc (1 . 0) "./boot/compile.scm" . 760877)
       (push.cdr.iloc (1 . 0) "./boot/compile.scm" . 760896)
       (push.subr.gloc.of length 1 "./boot/compile.scm" . 760888)
       (call
         (touch.gloc.of make-application-comment)
         (push.iloc.1 . 0)
         (apply.gloc.of make-application-comment "./boot/compile.scm" . 760908))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of compile-call "./boot/compile.scm" . 760863))
     (push)
     (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 763931)
     (push.subr.gloc.of \x2E;append 2 "./boot/compile.scm" . 763931)
     (extend . 1)
     (iloc 2 . 3)
     (if.true (ret.iloc 0 . 0))
     (push.const . call)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of list "./boot/compile.scm" . 764965))
   (iloc.0 . 3)
   (if.true
     (push.iloc.0 . 0)
     (const . \x2E;&UNDEF)
     (if.eq?
       (push.const . ret.const.undef)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 769053)
       (ret.subr.gloc.of list "./boot/compile.scm" . 769047))
     (push.iloc.0 . 0)
     (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 770071)
     (if.true
       (push.const . ret.const.unspec)
       (push.subr.gloc.of list 1 "./boot/compile.scm" . 771101)
       (ret.subr.gloc.of list "./boot/compile.scm" . 771095))
     (iloc.0 . 0)
     (if.symbol?
       (call
         (touch.gloc.of iloc?)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of iloc? "./boot/compile.scm" . 773147))
       (if.true
         (push.const . ret.iloc)
         (call
           (touch.gloc.of make-iloc-operand)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 774185))
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 773143))
       (push.const . ret.gloc.of)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 773143)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 773143))
     (push.const . ret.const)
     (iloc.0 . 0)
     (push.cons)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 776214))
   (iloc.0 . 2)
   (if.true.ret.const)
   (push.iloc.0 . 0)
   (const . \x2E;&UNDEF)
   (if.eq?
     (push.const . const.undef)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 780317)
     (ret.subr.gloc.of list "./boot/compile.scm" . 780311))
   (push.iloc.0 . 0)
   (subr.gloc.of unspecified? 1 "./boot/compile.scm" . 781335)
   (if.true
     (push.const . const.unspec)
     (push.subr.gloc.of list 1 "./boot/compile.scm" . 782365)
     (ret.subr.gloc.of list "./boot/compile.scm" . 782359))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (touch.gloc.of iloc?)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (apply.gloc.of iloc? "./boot/compile.scm" . 784411))
     (if.true
       (call
         (touch.gloc.of make-iloc-operand)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (apply.gloc.of make-iloc-operand "./boot/compile.scm" . 785446))
       (push)
       (extend . 1)
       (push.car.iloc (0 . 0) "./boot/compile.scm" . 786467)
       (extend . 1)
       (push.iloc.0 . 0)
       (const . 0)
       (if.eq?
         (push.const . iloc.0)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 787505)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 787487))
       (push.iloc.0 . 0)
       (const . 1)
       (if.eq?
         (push.const . iloc.1)
         (cdr.iloc (1 . 0) "./boot/compile.scm" . 788529)
         (push.cons)
         (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 788511))
       (push.const . iloc)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 789535))
     (push.const . gloc.of)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list 2 "./boot/compile.scm" . 784407)
     (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 784407))
   (push.const . const)
   (iloc.0 . 0)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "./boot/compile.scm" . 791574))
 (set.gloc.of compile-expression)
 (ret.const.unspec))
((close
   (1 0 . compile-coreform)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of ht-local-closures)
       (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
     (set.iloc 1 . 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 1)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of compile-expression)
     (push.iloc 2 . 0)
     (push.const)
     (push.const . #f)
     (push.const . #t)
     (apply.gloc.of compile-expression "./boot/compile.scm" . 797703))
   (push.close
     (0 0)
     (touch.gloc.of ht-local-closures)
     (push.iloc.1 . 0)
     (apply.gloc.of ht-local-closures "./boot/compile.scm" . 797703))
   (apply.gloc.of \x2E;dynamic-wind "./boot/compile.scm" . 797703))
 (set.gloc.of compile-coreform)
 (ret.const.unspec))

;
((close
   (3 0 . dynamic-wind)
   (call (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 11269))
   (call
     (touch.gloc.of current-dynamic-wind-record)
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (push.cons)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12342))
     (push.cons)
     (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 12293))
   (push.iloc.0 . 1)
   (push.close
     (0 1)
     (call
       (touch.gloc.of current-dynamic-wind-record)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16429))
       (push)
       (push.subr.gloc.of cdr 1 "./boot/dynamic-wind.scm" . 16424)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 16395))
     (call (apply.iloc (1 . 2) "./boot/dynamic-wind.scm" . 17419))
     (push.gloc.of values)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/dynamic-wind.scm" . 18443))
   (apply.gloc.of call-with-values "./boot/dynamic-wind.scm" . 13317))
 (set.gloc.of dynamic-wind)
 (ret.const.unspec))
((close
   (2 0 . \x2E;L0)
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (if.eq? (ret.iloc 0 . 0))
   (touch.gloc.of \x2E;L0\x60;9)
   (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 26684)
   (push.cdr.iloc (0 . 1) "./boot/dynamic-wind.scm" . 27708)
   (apply.gloc.of \x2E;L0\x60;9 "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of \x2E;L0\x60;9)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25619)
   (push.iloc.0 . 1)
   (push.subr.gloc.of length 1 "./boot/dynamic-wind.scm" . 25635)
   (extend . 2)
   (touch.gloc.of \x2E;L0\x60;9)
   (call
     (iloc.0 . 0)
     (>.iloc (0 . 1) "./boot/dynamic-wind.scm" . 26647)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 26670)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 26657))
     (ret.iloc 1 . 0))
   (push)
   (call
     (iloc.0 . 1)
     (>.iloc (0 . 0) "./boot/dynamic-wind.scm" . 27671)
     (if.true
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of - 2 "./boot/dynamic-wind.scm" . 27694)
       (ret.subr.gloc.of list-tail "./boot/dynamic-wind.scm" . 27681))
     (ret.iloc 1 . 1))
   (push)
   (apply.gloc.of \x2E;L0\x60;9 "./boot/dynamic-wind.scm" . 26635))
 (set.gloc.of common-tail\x60;2)
 (close
   (3 0 . perform-dynamic-wind)
   (call
     (call
       (touch.gloc.of common-tail\x60;2)
       (push.iloc.0 . 0)
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 30754))
       (push)
       (apply.gloc.of common-tail\x60;2 "./boot/dynamic-wind.scm" . 30737))
     (push)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.const.unspec))
         (call
           (touch.gloc.of current-dynamic-wind-record)
           (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 33837)
           (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 33808))
         (call (push.iloc.0 . 0) (subr.gloc.of cdar 1 "./boot/dynamic-wind.scm" . 34833) (apply))
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 35862)
         (apply.iloc+ (1 . 0) "./boot/dynamic-wind.scm" . 35856))
       (call
         (touch.gloc.of current-dynamic-wind-record)
         (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 31767))
       (push)
       (apply.iloc+ (0 . 0) "./boot/dynamic-wind.scm" . 31751))
     (extend.enclose
       (1 0 . loop)
       (push.iloc.0 . 0)
       (iloc 2 . 0)
       (if.eq? (ret.const.unspec))
       (call
         (push.cdr.iloc (0 . 0) "./boot/dynamic-wind.scm" . 38934)
         (apply.iloc (1 . 0) "./boot/dynamic-wind.scm" . 38928))
       (call (push.iloc.0 . 0) (subr.gloc.of caar 1 "./boot/dynamic-wind.scm" . 39953) (apply))
       (touch.gloc.of current-dynamic-wind-record)
       (push.iloc.0 . 0)
       (apply.gloc.of current-dynamic-wind-record "./boot/dynamic-wind.scm" . 40976))
     (push.iloc 2 . 0)
     (apply.iloc (0 . 0) "./boot/dynamic-wind.scm" . 36871))
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of apply "./boot/dynamic-wind.scm" . 41989))
 (set.gloc.of perform-dynamic-wind)
 (ret.const.unspec))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/exception.scm" . 5154))
 (set.gloc.of parent-exception-handler)
 (ret.const.unspec))
((close
   (1 0 . raise)
   (call
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 9228))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 11281))
       (call
         (call
           (touch.gloc.of parent-exception-handler)
           (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 12312))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (call
             (call (apply.gloc.of make-non-continuable-violation "./boot/exception.scm" . 14382))
             (push)
             (call
               (push.const . raise)
               (apply.gloc.of make-who-condition "./boot/exception.scm" . 15406))
             (push)
             (call
               (push.const . "returned from non-continuable exception")
               (apply.gloc.of make-message-condition "./boot/exception.scm" . 16430))
             (push)
             (call
               (push.iloc 2 . 0)
               (push.subr.gloc.of list 1 "./boot/exception.scm" . 17480)
               (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 17454))
             (push)
             (apply.gloc.of condition "./boot/exception.scm" . 14371))
           (push)
           (apply.iloc (0 . 0) "./boot/exception.scm" . 14365))
         (ret.const.unspec))
       (push.const . "error in raise: returned from non-continuable exception~%~%irritants:~%~a")
       (call
         (touch.gloc.of describe-condition)
         (push.const . #f)
         (push.iloc.1 . 0)
         (apply.gloc.of describe-condition "./boot/exception.scm" . 18539))
       (push)
       (apply.gloc.of scheme-error "./boot/exception.scm" . 18449))
     (ret.const.unspec))
   (push.const . "error in raise: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.0 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 19544))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 19461))
 (set.gloc.of raise)
 (ret.const.unspec))
((close
   (1 0 . raise-continuable)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 23564))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true (push.iloc.1 . 0) (apply.iloc (0 . 0) "./boot/exception.scm" . 24606))
   (push.const . "error in raise-continuable: unhandled exception has occurred~%~%irritants:~%~a")
   (call
     (touch.gloc.of describe-condition)
     (push.const . #f)
     (push.iloc.1 . 0)
     (apply.gloc.of describe-condition "./boot/exception.scm" . 26731))
   (push)
   (apply.gloc.of scheme-error "./boot/exception.scm" . 26636))
 (set.gloc.of raise-continuable)
 (ret.const.unspec))
((close
   (2 0 . with-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 30739))
   (push)
   (extend . 1)
   (push.const . #f)
   (push.const . #f)
   (push.close
     (1 0 . tmp2)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-exception-handler)
         (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
       (set.iloc 1 . 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc 3 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
     (push.close (0 0) (push.iloc 2 . 0) (apply.iloc (4 . 0) "./boot/exception.scm" . 36881))
     (push.close
       (0 0)
       (touch.gloc.of current-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 36881))
     (apply.gloc.of \x2E;dynamic-wind "./boot/exception.scm" . 36881))
   (extend . 3)
   (push.close
     (0 0)
     (call
       (touch.gloc.of parent-exception-handler)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (set.iloc 1 . 0)
     (call
       (touch.gloc.of current-exception-handler)
       (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
     (set.iloc 1 . 1)
     (call
       (touch.gloc.of parent-exception-handler)
       (push.iloc 2 . 0)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 2)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
   (push.close (0 0) (apply.iloc (3 . 1) "./boot/exception.scm" . 37897))
   (push.close
     (0 0)
     (call
       (touch.gloc.of parent-exception-handler)
       (push.iloc.1 . 0)
       (apply.gloc.of parent-exception-handler "./boot/exception.scm" . 37897))
     (touch.gloc.of current-exception-handler)
     (push.iloc.1 . 1)
     (apply.gloc.of current-exception-handler "./boot/exception.scm" . 37897))
   (apply.gloc.of \x2E;dynamic-wind "./boot/exception.scm" . 37897))
 (set.gloc.of with-exception-handler)
 (ret.const.unspec))
((close
   (2 1 . assertion-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 45083))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 46116))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 47131))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 48155))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 45077)
       (apply.gloc.of filter "./boot/exception.scm" . 44045))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 43014))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 41989))
 (set.gloc.of assertion-violation)
 (ret.const.unspec))
((close
   (1 1 . undefined-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 55323))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 56356))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 57416)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 57392))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 55317)
       (apply.gloc.of filter "./boot/exception.scm" . 54285))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 53254))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 52229))
 (set.gloc.of undefined-violation)
 (ret.const.unspec))
((close
   (1 1 . lexical-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-lexical-violation "./boot/exception.scm" . 64539))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 65572))
       (push)
       (call
         (iloc.0 . 1)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (0 . 1) "./boot/exception.scm" . 66632)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 66608))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 64533)
       (apply.gloc.of filter "./boot/exception.scm" . 63501))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 62470))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 61445))
 (set.gloc.of lexical-violation)
 (ret.const.unspec))
((close
   (3 1 . syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 73804))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 73755))
       (push)
       (call
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (apply.gloc.of make-who-condition "./boot/exception.scm" . 75807))
         (call
           (call
             (call
               (touch.gloc.of wrapped-syntax-object?)
               (push.iloc.0 . 2)
               (apply.gloc.of wrapped-syntax-object? "./boot/exception.scm" . 76853))
             (if.true
               (touch.gloc.of unwrap-syntax)
               (push.iloc.0 . 2)
               (apply.gloc.of unwrap-syntax "./boot/exception.scm" . 76883))
             (ret.iloc 0 . 2))
           (push)
           (extend . 1)
           (call (push.iloc.0 . 0) (apply.gloc.of identifier? "./boot/exception.scm" . 77871))
           (if.true
             (touch.gloc.of original-id)
             (call
               (touch.gloc.of syntax-object-expr)
               (push.iloc.0 . 0)
               (apply.gloc.of syntax-object-expr "./boot/exception.scm" . 77902))
             (push)
             (apply.gloc.of original-id "./boot/exception.scm" . 77889))
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (call
             (push.car.iloc (0 . 0) "./boot/exception.scm" . 78925)
             (apply.gloc.of identifier? "./boot/exception.scm" . 78912))
           (if.false.ret)
           (touch.gloc.of original-id)
           (call
             (touch.gloc.of syntax-object-expr)
             (push.car.iloc (0 . 0) "./boot/exception.scm" . 78970)
             (apply.gloc.of syntax-object-expr "./boot/exception.scm" . 78950))
           (push)
           (apply.gloc.of original-id "./boot/exception.scm" . 78937))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 76831))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 82971))
       (push)
       (push.subr.gloc.of list 3 "./boot/exception.scm" . 69635)
       (apply.gloc.of filter "./boot/exception.scm" . 69635))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 69635))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 69635))
 (set.gloc.of syntax-violation)
 (ret.const.unspec))
((close
   (2 1 . error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-error "./boot/exception.scm" . 90139))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 91172))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 92187))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 93211))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 90133)
       (apply.gloc.of filter "./boot/exception.scm" . 89101))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 88070))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 87045))
 (set.gloc.of error)
 (ret.const.unspec))
((close
   (2 1 . implementation-restriction-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (apply.gloc.of make-implementation-restriction-violation "./boot/exception.scm" . 100379))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 101412))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 102427))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 103474))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 100373)
       (apply.gloc.of filter "./boot/exception.scm" . 99341))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 98310))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 97285))
 (set.gloc.of implementation-restriction-violation)
 (ret.const.unspec))
((close
   (3 1 . undefined/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 110668))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 110619))
       (push)
       (call (apply.gloc.of make-undefined-violation "./boot/exception.scm" . 111643))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 112676))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 113691))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 110613)
       (apply.gloc.of filter "./boot/exception.scm" . 109581))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 108550))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 107525))
 (set.gloc.of undefined/syntax-violation)
 (ret.const.unspec))
((close
   (3 1 . assertion/syntax-violation)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (call
           (iloc.0 . 3)
           (if.not.pair?.ret.const . #f)
           (push.iloc.0 . 3)
           (ret.subr.gloc.of car "./boot/exception.scm" . 120908))
         (push)
         (apply.gloc.of make-syntax-violation "./boot/exception.scm" . 120859))
       (push)
       (call (apply.gloc.of make-assertion-violation "./boot/exception.scm" . 121883))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 122916))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 123931))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 120853)
       (apply.gloc.of filter "./boot/exception.scm" . 119821))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 118790))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 117765))
 (set.gloc.of assertion/syntax-violation)
 (ret.const.unspec))
((close
   (0 1 . scheme-error)
   (push.const . #t)
   (push.const . "~!")
   (subr.gloc.of format 2 "./boot/exception.scm" . 141317)
   (subr.gloc.of current-error-port 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . "~&~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 143367)
   (call
     (push.gloc.of format)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of apply "./boot/exception.scm" . 144391))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 145415)
   (subr.gloc.of display-backtrace 0 "./boot/exception.scm" . 146439)
   (push.iloc.0 . 0)
   (push.const . "~%[exit]~%")
   (subr.gloc.of format 2 "./boot/exception.scm" . 147463)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/exception.scm" . 148487))
 (set.gloc.of scheme-error)
 (ret.const.unspec))
((close
   (3 1 . raise-i/o-filename-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-i/o-filename-error "./boot/exception.scm" . 155675))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 156708))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 157723))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 158770))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 155669)
       (apply.gloc.of filter "./boot/exception.scm" . 154637))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 153606))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 152581))
 (set.gloc.of raise-i/o-filename-error)
 (ret.const.unspec))
((close
   (2 1 . raise-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call (apply.gloc.of make-i/o-error "./boot/exception.scm" . 165915))
       (push)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.iloc.0 . 0)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 166948))
       (push)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 167963))
       (push)
       (call
         (iloc.0 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 2)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 169010))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 165909)
       (apply.gloc.of filter "./boot/exception.scm" . 164877))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 163846))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 162821))
 (set.gloc.of raise-i/o-error)
 (ret.const.unspec))
((close
   (4 1 . raise-misc-i/o-error-with-port)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 4)
         (apply.gloc.of apply "./boot/exception.scm" . 177179))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 178212))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 179227))
       (push)
       (call
         (iloc.0 . 3)
         (if.false.ret)
         (push.iloc.0 . 3)
         (apply.gloc.of make-i/o-port-error "./boot/exception.scm" . 180261))
       (push)
       (call
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (push.subr.gloc.of cons* 2 "./boot/exception.scm" . 181301)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 181275))
       (push)
       (push.subr.gloc.of list 5 "./boot/exception.scm" . 177173)
       (apply.gloc.of filter "./boot/exception.scm" . 176141))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 175110))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 174085))
 (set.gloc.of raise-misc-i/o-error-with-port)
 (ret.const.unspec))
((close
   (3 1 . raise-misc-i/o-error)
   (call
     (push.gloc.of condition)
     (call
       (touch.gloc.of filter)
       (push.gloc.of values)
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 3)
         (apply.gloc.of apply "./boot/exception.scm" . 188443))
       (push)
       (call
         (iloc.0 . 1)
         (if.false.ret)
         (push.iloc.0 . 1)
         (apply.gloc.of make-who-condition "./boot/exception.scm" . 189476))
       (push)
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of make-message-condition "./boot/exception.scm" . 190491))
       (push)
       (call
         (iloc.0 . 3)
         (if.not.pair?.ret.const . #f)
         (push.iloc.0 . 3)
         (apply.gloc.of make-irritants-condition "./boot/exception.scm" . 192544))
       (push)
       (push.subr.gloc.of list 4 "./boot/exception.scm" . 188437)
       (apply.gloc.of filter "./boot/exception.scm" . 187405))
     (push)
     (apply.gloc.of apply "./boot/exception.scm" . 186374))
   (push)
   (apply.gloc.of raise "./boot/exception.scm" . 185349))
 (set.gloc.of raise-misc-i/o-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-read-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-read-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 196613))
 (set.gloc.of raise-i/o-read-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-write-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-write-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 200709))
 (set.gloc.of raise-i/o-write-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-protection-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-protection-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 204805))
 (set.gloc.of raise-i/o-file-protection-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-is-read-only-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-file-is-read-only-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 208901))
 (set.gloc.of raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-already-exists-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-already-exists-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 212997))
 (set.gloc.of raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-file-does-not-exist-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-file-does-not-exist-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 217093))
 (set.gloc.of raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-invalid-position-error)
   (touch.gloc.of raise-misc-i/o-error-with-port)
   (push.gloc.of make-i/o-invalid-position-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error-with-port "./boot/exception.scm" . 221189))
 (set.gloc.of raise-i/o-invalid-position-error)
 (ret.const.unspec))
((close
   (3 0 . raise-i/o-decoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-decoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 225285))
 (set.gloc.of raise-i/o-decoding-error)
 (ret.const.unspec))
((close
   (4 0 . raise-i/o-encoding-error)
   (touch.gloc.of raise-misc-i/o-error)
   (push.gloc.of make-i/o-encoding-error)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (apply.gloc.of raise-misc-i/o-error "./boot/exception.scm" . 229381))
 (set.gloc.of raise-i/o-encoding-error)
 (ret.const.unspec))

;
((subr.gloc.of make-weak-core-hashtable 0 "./boot/record.scm" . 5156)
 (set.gloc.of nongenerative-record-types)
 (ret.const.unspec))
((close
   (6 0 . make-rtd)
   (push.const . type:record-type-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 9221))
 (set.gloc.of make-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 13322)
   (const . type:record-type-descriptor)
   (ret.eq? "./boot/record.scm" . 13317))
 (set.gloc.of record-type-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rtd-name)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 15395))
 (set.gloc.of rtd-name)
 (ret.const.unspec))
((close
   (1 0 . rtd-parent)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 16419))
 (set.gloc.of rtd-parent)
 (ret.const.unspec))
((close
   (1 0 . rtd-uid)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 17443))
 (set.gloc.of rtd-uid)
 (ret.const.unspec))
((close
   (1 0 . rtd-sealed?)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 18467))
 (set.gloc.of rtd-sealed?)
 (ret.const.unspec))
((close
   (1 0 . rtd-opaque?)
   (push.iloc.0 . 0)
   (push.const . 5)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 19491))
 (set.gloc.of rtd-opaque?)
 (ret.const.unspec))
((close
   (1 0 . rtd-fields)
   (push.iloc.0 . 0)
   (push.const . 6)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 20515))
 (set.gloc.of rtd-fields)
 (ret.const.unspec))
((close
   (2 0 . rtd-ancestor?)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (if.eq?.ret.const . #t)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 27670))
     (push)
     (apply.iloc+ (1 . 0) "./boot/record.scm" . 27664))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "./boot/record.scm" . 24581))
 (set.gloc.of rtd-ancestor?)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of loop\x60;5)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 33812))
     (push)
     (push.iloc.0 . 1)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 34853))
     (push)
     (push.subr.gloc.of length 1 "./boot/record.scm" . 34845)
     (push.subr.gloc.of + 2 "./boot/record.scm" . 34836)
     (apply.gloc.of loop\x60;5 "./boot/record.scm" . 33806))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;5)
 (close
   (1 0 . rtd-inherited-field-count)
   (touch.gloc.of loop\x60;5)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 31765))
   (push)
   (push.const . 0)
   (apply.gloc.of loop\x60;5 "./boot/record.scm" . 31749))
 (set.gloc.of rtd-inherited-field-count)
 (ret.const.unspec))
((close
   (1 0 . rtd-total-field-count)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 40968))
   (push)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 41008))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 41000)
   (ret.subr.gloc.of + "./boot/record.scm" . 40965))
 (set.gloc.of rtd-total-field-count)
 (ret.const.unspec))
((close
   (1 0 . record-type-name)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 45065))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 46128))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 46089))
   (touch.gloc.of rtd-name)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-name "./boot/record.scm" . 47109))
 (set.gloc.of record-type-name)
 (ret.const.unspec))
((close
   (1 0 . record-type-parent)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 51209))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 52272))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 52233))
   (touch.gloc.of rtd-parent)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-parent "./boot/record.scm" . 53253))
 (set.gloc.of record-type-parent)
 (ret.const.unspec))
((close
   (1 0 . record-type-uid)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 57353))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 58416))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 58377))
   (touch.gloc.of rtd-uid)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-uid "./boot/record.scm" . 59397))
 (set.gloc.of record-type-uid)
 (ret.const.unspec))
((close
   (1 0 . record-type-generative?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 63497))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 64560))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 64521))
   (call
     (touch.gloc.of rtd-uid)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-uid "./boot/record.scm" . 65546))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 65541))
 (set.gloc.of record-type-generative?)
 (ret.const.unspec))
((close
   (1 0 . record-type-sealed?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 69641))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 70704))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 70665))
   (touch.gloc.of rtd-sealed?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-sealed? "./boot/record.scm" . 71685))
 (set.gloc.of record-type-sealed?)
 (ret.const.unspec))
((close
   (1 0 . record-type-opaque?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 75785))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 76848))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 76809))
   (touch.gloc.of rtd-opaque?)
   (push.iloc.0 . 0)
   (apply.gloc.of rtd-opaque? "./boot/record.scm" . 77829))
 (set.gloc.of record-type-opaque?)
 (ret.const.unspec))
((close
   (1 0 . record-type-field-names)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 81929))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 82992))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 82953))
   (call
     (push.gloc.of cdr)
     (call
       (touch.gloc.of rtd-fields)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-fields "./boot/record.scm" . 83996))
     (push)
     (apply.gloc.of map "./boot/record.scm" . 83987))
   (push)
   (ret.subr.gloc.of list->vector "./boot/record.scm" . 83973))
 (set.gloc.of record-type-field-names)
 (ret.const.unspec))
((close
   (2 0 . record-field-mutable?)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 88073))
   (if.false.call
     (push.const . record-type-name)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 89136))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 89197)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 89097))
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 90132))
   (push)
   (push.iloc.0 . 1)
   (push.subr.gloc.of list-ref 2 "./boot/record.scm" . 90122)
   (ret.subr.gloc.of car "./boot/record.scm" . 90117))
 (set.gloc.of record-field-mutable?)
 (ret.const.unspec))
((close
   (6 0 . make-record-type-descriptor)
   (push.iloc.0 . 0)
   (subr.gloc.of symbol? 1 "./boot/record.scm" . 94217)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "symbol")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 96286))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 97310)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 95241))
   (push.iloc.0 . 5)
   (subr.gloc.of vector? 1 "./boot/record.scm" . 98313)
   (if.false.call
     (push.const . make-record-type-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "vector")
       (push.iloc.0 . 5)
       (push.const . 6)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 100382))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.subr.gloc.of list 6 "./boot/record.scm" . 101406)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 99337))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 103438))
     (if.false.call
       (push.const . make-record-type-descriptor)
       (call
         (touch.gloc.of wrong-type-argument-message)
         (push.const . "record-type descriptor or #f")
         (push.iloc.0 . 1)
         (push.const . 2)
         (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 105507))
       (push)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.iloc.0 . 3)
       (push.iloc.0 . 4)
       (push.iloc.0 . 5)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 106531)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 104462))
     (if.false.ret)
     (call
       (touch.gloc.of rtd-sealed?)
       (push.iloc.0 . 1)
       (apply.gloc.of rtd-sealed? "./boot/record.scm" . 107535))
     (if.false.ret)
     (push.const . make-record-type-descriptor)
     (push.const . "attempt to extend a sealed record-type")
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 108559))
   (call
     (iloc.0 . 4)
     (if.true.ret)
     (iloc.0 . 1)
     (if.false.ret)
     (touch.gloc.of rtd-opaque?)
     (push.iloc.0 . 1)
     (apply.gloc.of rtd-opaque? "./boot/record.scm" . 111645))
   (push)
   (call
     (push.close
       (1 0)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (0 . 0) "./boot/record.scm" . 113690)
         (ret.null? "./boot/record.scm" . 113690))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . mutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #t)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) "./boot/record.scm" . 113690)
         (const . immutable)
         (ret.eq? "./boot/record.scm" . 113690))
       (if.true
         (push.const . #f)
         (cadr.iloc (1 . 0) "./boot/record.scm" . 113690)
         (ret.cons "./boot/record.scm" . 113690))
       (push.const . make-record-type-descriptor)
       (push.const . "malformed field specifiers")
       (push.iloc 2 . 5)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 113690))
     (push.iloc.0 . 5)
     (push.subr.gloc.of vector->list 1 "./boot/record.scm" . 120856)
     (apply.gloc.of map "./boot/record.scm" . 109573))
   (push)
   (extend . 2)
   (call
     (touch.gloc.of make-rtd)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of make-rtd "./boot/record.scm" . 121874))
   (push)
   (extend . 1)
   (iloc 2 . 2)
   (if.true
     (push.gloc.of nongenerative-record-types)
     (push.iloc 2 . 2)
     (push.const . #f)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/record.scm" . 123920)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 125988))
         (push)
         (call
           (touch.gloc.of rtd-uid)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-uid "./boot/record.scm" . 126002))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 125982)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127012))
         (push)
         (call
           (touch.gloc.of rtd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-parent "./boot/record.scm" . 127029))
         (push)
         (subr.gloc.of eqv? 2 "./boot/record.scm" . 127006)
         (if.false.ret)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.1 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128038))
         (push)
         (call
           (touch.gloc.of rtd-fields)
           (push.iloc.0 . 0)
           (apply.gloc.of rtd-fields "./boot/record.scm" . 128055))
         (push)
         (ret.subr.gloc.of equal? "./boot/record.scm" . 128030))
       (if.true (ret.iloc 0 . 0))
       (push.const . make-record-type-descriptor)
       (push.const . "mismatched subsequent call for nongenerative record-type")
       (push.iloc 3 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (push.iloc 3 . 3)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of list 6 "./boot/record.scm" . 132142)
       (apply.gloc.of assertion-violation "./boot/record.scm" . 130073))
     (push.gloc.of nongenerative-record-types)
     (push.iloc 3 . 2)
     (push.iloc.1 . 0)
     (subr.gloc.of core-hashtable-set! 3 "./boot/record.scm" . 134167)
     (ret.iloc 1 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of make-record-type-descriptor)
 (ret.const.unspec))
((close
   (4 0 . make-rcd)
   (push.const . type:record-constructor-descriptor)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 138245))
 (set.gloc.of make-rcd)
 (ret.const.unspec))
((close
   (1 0 . record-constructor-descriptor?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 142346)
   (const . type:record-constructor-descriptor)
   (ret.eq? "./boot/record.scm" . 142341))
 (set.gloc.of record-constructor-descriptor?)
 (ret.const.unspec))
((close
   (1 0 . rcd-rtd)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 144428))
 (set.gloc.of rcd-rtd)
 (ret.const.unspec))
((close
   (1 0 . rcd-protocol)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 145452))
 (set.gloc.of rcd-protocol)
 (ret.const.unspec))
((close
   (1 0 . rcd-custom-protocol?)
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 146476))
 (set.gloc.of rcd-custom-protocol?)
 (ret.const.unspec))
((close
   (1 0 . rcd-parent)
   (push.iloc.0 . 0)
   (push.const . 4)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 147500))
 (set.gloc.of rcd-parent)
 (ret.const.unspec))
((close
   (1 0)
   (ret.close
     (0 1)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of apply "./boot/record.scm" . 160783)))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0 . default-protocol)
   (call
     (touch.gloc.of rtd-parent)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-parent "./boot/record.scm" . 151571))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 153637))
     (push)
     (extend . 1)
     (ret.close
       (1 0)
       (ret.close
         (0 1)
         (push.close
           (0 0)
           (touch.gloc.of split-at)
           (push.iloc.1 . 0)
           (push.iloc 3 . 0)
           (apply.gloc.of split-at "./boot/record.scm" . 156743))
         (push.close
           (2 0)
           (call
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (apply.gloc.of apply "./boot/record.scm" . 157722))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of apply "./boot/record.scm" . 157715))
         (apply.gloc.of \x2E;call-with-values "./boot/record.scm" . 155663))))
   (ret.gloc.of \x2E;fn2.1\x60;2))
 (set.gloc.of default-protocol)
 (ret.const.unspec))
((close
   (3 0 . make-record-constructor-descriptor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 164873))
   (if.false.call
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (push.const . 1)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 166942))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 167966)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 165897))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of record-constructor-descriptor?)
       (push.iloc.0 . 1)
       (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 169998))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor or #f")
       (push.iloc.0 . 1)
       (push.const . 2)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 172067))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 173091)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 171022))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (push.iloc.0 . 2)
     (subr.gloc.of procedure? 1 "./boot/record.scm" . 175118)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "procedure or #f")
       (push.iloc.0 . 2)
       (push.const . 3)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 177187))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.subr.gloc.of list 3 "./boot/record.scm" . 178211)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 176142))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 180238))
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 181262))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 186378))
     (if.false.ret)
     (call
       (touch.gloc.of rcd-rtd)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-rtd "./boot/record.scm" . 187411))
     (push)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 187428))
     (if.eq?.ret.const . #t)
     (push.const . make-record-constructor-descriptor)
     (push.const . "mismatch between rtd and parent constructor descriptor")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 188430))
   (call
     (iloc.0 . 2)
     (if.false.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 193546))
     (if.false.ret)
     (iloc.0 . 1)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const . "expected #f for protocol since no parent constructor descriptor is provided")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 195598))
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (call
       (touch.gloc.of rcd-custom-protocol?)
       (push.iloc.0 . 1)
       (apply.gloc.of rcd-custom-protocol? "./boot/record.scm" . 200714))
     (if.false.ret)
     (iloc.0 . 2)
     (if.true.ret)
     (push.const . make-record-constructor-descriptor)
     (push.const
       .
       "expected procedure for protocol since parent constructor descriptor have custom one")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 202766))
   (touch.gloc.of make-rcd)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 2)
     (if.true.ret)
     (touch.gloc.of default-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of default-protocol "./boot/record.scm" . 208930))
   (push)
   (call (iloc.0 . 2) (if.false.ret) (ret.const . #t))
   (push)
   (call
     (iloc.0 . 1)
     (if.true.ret)
     (call
       (touch.gloc.of rtd-parent)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-parent "./boot/record.scm" . 210974))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/record.scm" . 213027))
   (push)
   (apply.gloc.of make-rcd "./boot/record.scm" . 163843))
 (set.gloc.of make-record-constructor-descriptor)
 (ret.const.unspec))
((close
   (1 0 . record?)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 219171)
     (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 219146))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 220196)
     (apply.gloc.of record-type-opaque? "./boot/record.scm" . 220175))
   (push)
   (ret.subr.gloc.of not "./boot/record.scm" . 220170))
 (set.gloc.of record?)
 (ret.const.unspec))
((close
   (1 0 . record-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/record.scm" . 224265))
   (if.true
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 225289))
   (push.const . record-rtd)
   (call
     (touch.gloc.of wrong-type-argument-message)
     (push.const . "non-opaque record")
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 226346))
   (push)
   (apply.gloc.of assertion-violation "./boot/record.scm" . 226313))
 (set.gloc.of record-rtd)
 (ret.const.unspec))
((close
   (3 0 . make-nested-conser)
   (call
     (call
       (extend.enclose
         (1 0 . loop)
         (call
           (touch.gloc.of rcd-parent)
           (push.iloc.0 . 0)
           (apply.gloc.of rcd-parent "./boot/record.scm" . 232464))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (ret.close
             (0 1)
             (ret.close
               (0 1)
               (ret.close
                 (0 1)
                 (call
                   (call
                     (call (push.iloc 3 . 0) (apply.iloc (5 . 0) "./boot/record.scm" . 238634))
                     (push)
                     (push.iloc.0 . 0)
                     (push.iloc 2 . 0)
                     (push.subr.gloc.of append 2 "./boot/record.scm" . 239658)
                     (apply.gloc.of apply "./boot/record.scm" . 238627))
                   (push)
                   (call
                     (touch.gloc.of rcd-protocol)
                     (push.iloc 3 . 0)
                     (apply.gloc.of rcd-protocol "./boot/record.scm" . 237603))
                   (apply))
                 (push)
                 (push.iloc.1 . 0)
                 (apply.gloc.of apply "./boot/record.scm" . 237595)))))
         (ret.close
           (0 1)
           (ret.close
             (0 1)
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (push.subr.gloc.of append 2 "./boot/record.scm" . 244776)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of length 1 "./boot/record.scm" . 245789)
             (=.iloc (6 . 2) "./boot/record.scm" . 245786)
             (if.true
               (push.gloc.of tuple)
               (push.iloc 6 . 1)
               (push.iloc.0 . 0)
               (apply.gloc.of apply "./boot/record.scm" . 246810))
             (push.const . "record constructor")
             (push.const . "wrong number of arguments")
             (push.iloc.0 . 0)
             (apply.gloc.of assertion-violation "./boot/record.scm" . 247834))))
       (push.iloc.1 . 0)
       (apply.iloc (0 . 0) "./boot/record.scm" . 231431))
     (apply))
   (push)
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 230406))
   (apply))
 (set.gloc.of make-nested-conser)
 (ret.const.unspec))
((close
   (3 0 . make-simple-conser)
   (push.close
     (0 1)
     (push.iloc.0 . 0)
     (subr.gloc.of length 1 "./boot/record.scm" . 253967)
     (=.iloc (1 . 2) "./boot/record.scm" . 253964)
     (if.true
       (push.gloc.of tuple)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of apply "./boot/record.scm" . 254988))
     (push.const . "record constructor")
     (push.const . "wrong number of arguments")
     (push.iloc.0 . 0)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 256012))
   (call
     (touch.gloc.of rcd-protocol)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-protocol "./boot/record.scm" . 251910))
   (apply))
 (set.gloc.of make-simple-conser)
 (ret.const.unspec))
((close
   (2 0 . flat-field-offset)
   (call
     (touch.gloc.of rtd-inherited-field-count)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-inherited-field-count "./boot/record.scm" . 260104))
   (push)
   (push.iloc.0 . 1)
   (push.const . 1)
   (ret.subr.gloc.of + "./boot/record.scm" . 260101))
 (set.gloc.of flat-field-offset)
 (ret.const.unspec))
((close
   (2 0 . make-accessor)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 265239)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 265258))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 266273)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 266254))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 266292))
     (push.const . "record accessor")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 268398))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 268370)
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 268341))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 268302)))
 (set.gloc.of make-accessor)
 (ret.const.unspec))
((close
   (2 0 . make-mutator)
   (ret.close
     (2 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 273431)
     (if.eq?
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 273450))
     (call
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 274465)
       (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 274446))
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of tuple-set! "./boot/record.scm" . 274484))
     (push.const . "record mutator")
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record of type ~a")
       (call
         (touch.gloc.of rtd-name)
         (push.iloc.1 . 0)
         (apply.gloc.of rtd-name "./boot/record.scm" . 276589))
       (push)
       (push.subr.gloc.of format 2 "./boot/record.scm" . 276561)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of list 2 "./boot/record.scm" . 276605)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 276532))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 276494)))
 (set.gloc.of make-mutator)
 (ret.const.unspec))
((close
   (1 0 . make-predicate)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (subr.gloc.of tuple-ref 2 "./boot/record.scm" . 281620)
     (if.eq?.ret.const . #t)
     (touch.gloc.of rtd-ancestor?)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 282654)
     (apply.gloc.of rtd-ancestor? "./boot/record.scm" . 282635)))
 (set.gloc.of make-predicate)
 (ret.const.unspec))
((close
   (1 0 . record-constructor)
   (call
     (touch.gloc.of record-constructor-descriptor?)
     (push.iloc.0 . 0)
     (apply.gloc.of record-constructor-descriptor? "./boot/record.scm" . 286729))
   (if.false.call
     (push.const . record-constructor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-constructor-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 287794))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 287753))
   (call
     (touch.gloc.of rcd-rtd)
     (push.iloc.0 . 0)
     (apply.gloc.of rcd-rtd "./boot/record.scm" . 288784))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of rcd-parent)
     (push.iloc.1 . 0)
     (apply.gloc.of rcd-parent "./boot/record.scm" . 289803))
   (if.true
     (touch.gloc.of make-nested-conser)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (call
       (touch.gloc.of rtd-total-field-count)
       (push.iloc.0 . 0)
       (apply.gloc.of rtd-total-field-count "./boot/record.scm" . 290856))
     (push)
     (apply.gloc.of make-nested-conser "./boot/record.scm" . 290827))
   (touch.gloc.of make-simple-conser)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 291888))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 291880)
   (apply.gloc.of make-simple-conser "./boot/record.scm" . 291851))
 (set.gloc.of record-constructor)
 (ret.const.unspec))
((close
   (1 0 . record-predicate)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 295945))
   (if.false.call
     (push.const . record-predicate)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 297008))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 296969))
   (touch.gloc.of make-predicate)
   (push.iloc.0 . 0)
   (apply.gloc.of make-predicate "./boot/record.scm" . 297989))
 (set.gloc.of record-predicate)
 (ret.const.unspec))
((close
   (2 0 . record-accessor)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 302089))
   (if.false.call
     (push.const . record-accssor)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 303150))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 303209)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 303113))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 304153))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 304145)
   (subr.gloc.of < 3 "./boot/record.scm" . 304137)
   (if.false.call
     (push.const . record-accssor)
     (push.const . "field index out of range")
     (apply.gloc.of assertion-violation "./boot/record.scm" . 305161))
   (touch.gloc.of make-accessor)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 306200))
   (push)
   (apply.gloc.of make-accessor "./boot/record.scm" . 306181))
 (set.gloc.of record-accessor)
 (ret.const.unspec))
((close
   (2 0 . record-mutator)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-descriptor? "./boot/record.scm" . 310281))
   (if.false.call
     (push.const . record-mutator)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type-descriptor")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 311342))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 311401)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 311305))
   (push.const . -1)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of rtd-fields)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-fields "./boot/record.scm" . 312345))
   (push)
   (push.subr.gloc.of length 1 "./boot/record.scm" . 312337)
   (subr.gloc.of < 3 "./boot/record.scm" . 312329)
   (if.false.call
     (push.const . record-mutator)
     (push.const . "field index out of range")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 313417)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 313353))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of record-field-mutable? "./boot/record.scm" . 314377))
   (if.false.call
     (push.const . record-mutator)
     (push.const . "specified field is immutable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of list 2 "./boot/record.scm" . 315469)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 315401))
   (touch.gloc.of make-mutator)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of flat-field-offset)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of flat-field-offset "./boot/record.scm" . 316439))
   (push)
   (apply.gloc.of make-mutator "./boot/record.scm" . 316421))
 (set.gloc.of record-mutator)
 (ret.const.unspec))
((close
   (3 0 . make-record-type)
   (push.const . type:record-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (ret.subr.gloc.of tuple "./boot/record.scm" . 320517))
 (set.gloc.of make-record-type)
 (ret.const.unspec))
((close
   (1 0 . record-type?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/record.scm" . 324618)
   (const . type:record-type)
   (ret.eq? "./boot/record.scm" . 324613))
 (set.gloc.of record-type?)
 (ret.const.unspec))
((close
   (1 0 . record-type-rtd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 328713))
   (if.false.call
     (push.const . record-type-rtd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 329775))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 329737))
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 330757))
 (set.gloc.of record-type-rtd)
 (ret.const.unspec))
((close
   (1 0 . record-type-rcd)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type? "./boot/record.scm" . 334857))
   (if.false.call
     (push.const . record-type-rcd)
     (call
       (touch.gloc.of wrong-type-argument-message)
       (push.const . "record-type")
       (push.iloc.0 . 0)
       (apply.gloc.of wrong-type-argument-message "./boot/record.scm" . 335919))
     (push)
     (apply.gloc.of assertion-violation "./boot/record.scm" . 335881))
   (push.iloc.0 . 0)
   (push.const . 3)
   (ret.subr.gloc.of tuple-ref "./boot/record.scm" . 336901))
 (set.gloc.of record-type-rcd)
 (ret.const.unspec))

;
((call
   (call
     (push.const . &condition)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 6159))
   (push)
   (extend . 1)
   (push.const . &condition)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 7183))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 8197))
 (set.gloc.of &condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition-component)
   (push.iloc.0 . 0)
   (push.const . 1)
   (ret.subr.gloc.of tuple-ref "./boot/condition.scm" . 10292))
 (set.gloc.of compound-condition-component)
 (ret.const.unspec))
((close
   (0 1 . condition)
   (push.const . type:condition)
   (call
     (push.gloc.of append)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of condition? "./boot/condition.scm" . 17438))
         (if.false.call
           (push.const . condition)
           (push.const . "expected condition, but got ~r")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/condition.scm" . 18494)
           (push.iloc.1 . 0)
           (apply.gloc.of assertion-violation "./boot/condition.scm" . 18462))
         (push.iloc.0 . 0)
         (apply.gloc.of simple-conditions "./boot/condition.scm" . 19482))
       (push.iloc.0 . 0)
       (apply.gloc.of map "./boot/condition.scm" . 16403))
     (push)
     (apply.gloc.of apply "./boot/condition.scm" . 15372))
   (push)
   (ret.subr.gloc.of tuple "./boot/condition.scm" . 14341))
 (set.gloc.of condition)
 (ret.const.unspec))
((close
   (1 0 . compound-condition?)
   (push.iloc.0 . 0)
   (subr.gloc.of tuple? 1 "./boot/condition.scm" . 24586)
   (if.false.ret)
   (push.const . type:condition)
   (push.iloc.0 . 0)
   (push.const . 0)
   (subr.gloc.of tuple-ref 2 "./boot/condition.scm" . 25631)
   (ret.eq? "./boot/condition.scm" . 25610))
 (set.gloc.of compound-condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-condition?)
   (call (push.iloc.0 . 0) (apply.gloc.of record? "./boot/condition.scm" . 29706))
   (if.false.ret)
   (touch.gloc.of rtd-ancestor?)
   (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 30745))
   (push)
   (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 30774))
   (push)
   (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 30730))
 (set.gloc.of simple-condition?)
 (ret.const.unspec))
((close
   (1 0 . condition?)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 34825))
   (if.true.ret)
   (touch.gloc.of compound-condition?)
   (push.iloc.0 . 0)
   (apply.gloc.of compound-condition? "./boot/condition.scm" . 35849))
 (set.gloc.of condition?)
 (ret.const.unspec))
((close
   (1 0 . simple-conditions)
   (call
     (touch.gloc.of simple-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of simple-condition? "./boot/condition.scm" . 39948))
   (if.true (push.iloc.0 . 0) (ret.subr.gloc.of list "./boot/condition.scm" . 39970))
   (call
     (touch.gloc.of compound-condition?)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition? "./boot/condition.scm" . 40972))
   (if.true
     (touch.gloc.of compound-condition-component)
     (push.iloc.0 . 0)
     (apply.gloc.of compound-condition-component "./boot/condition.scm" . 40996))
   (push.const . simple-conditions)
   (push.const . "expected condition, but got ~r")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/condition.scm" . 43060)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 43020))
 (set.gloc.of simple-conditions)
 (ret.const.unspec))
((close
   (1 0 . condition-predicate)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 47128))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 47113))
   (if.false.call
     (push.const . condition-predicate)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 48179)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 48137))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 50190))
     (if.true
       (touch.gloc.of rtd-ancestor?)
       (push.iloc.1 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 51233))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 51214))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 52238))
     (if.false.ret)
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of rtd-ancestor?)
       (push.iloc 2 . 0)
       (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 53307))
       (push)
       (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 53288))
     (call
       (touch.gloc.of compound-condition-component)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition-component "./boot/condition.scm" . 54292))
     (push)
     (apply.gloc.of any1 "./boot/condition.scm" . 53262)))
 (set.gloc.of condition-predicate)
 (ret.const.unspec))
((close
   (2 0)
   (push.const . "condition accessor")
   (push.const . "expected condition of a subtype of ~s, but got ~r")
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of format 3 "./boot/condition.scm" . 62515)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (apply.gloc.of assertion-violation "./boot/condition.scm" . 62473))
 (set.gloc.of wrong-type\x60;2)
 (close
   (2 0 . condition-accessor)
   (call
     (touch.gloc.of rtd-ancestor?)
     (call (push.gloc.of &condition) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 64536))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 64521))
   (if.false.call
     (push.const . condition-accessor)
     (push.const . "expected record-type-descriptor of a subtype of &condition, but got ~r")
     (push.iloc.0 . 0)
     (push.subr.gloc.of format 2 "./boot/condition.scm" . 65586)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of assertion-violation "./boot/condition.scm" . 65545))
   (ret.close
     (1 0)
     (call
       (touch.gloc.of simple-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of simple-condition? "./boot/condition.scm" . 68622))
     (if.true
       (call
         (call
           (touch.gloc.of rtd-ancestor?)
           (push.iloc.1 . 0)
           (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 69669))
           (push)
           (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 69650))
         (if.true.ret)
         (touch.gloc.of wrong-type\x60;2)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 69687))
       (push.iloc.0 . 0)
       (apply.iloc (1 . 1) "./boot/condition.scm" . 70670))
     (call
       (touch.gloc.of compound-condition?)
       (push.iloc.0 . 0)
       (apply.gloc.of compound-condition? "./boot/condition.scm" . 71694))
     (if.true
       (call
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (call
             (touch.gloc.of rtd-ancestor?)
             (push.iloc 2 . 0)
             (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 72775))
             (push)
             (apply.gloc.of rtd-ancestor? "./boot/condition.scm" . 72756))
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call
           (touch.gloc.of compound-condition-component)
           (push.iloc.0 . 0)
           (apply.gloc.of compound-condition-component "./boot/condition.scm" . 73755))
         (push)
         (apply.gloc.of any1 "./boot/condition.scm" . 72725))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (apply.iloc (2 . 1) "./boot/condition.scm" . 72718))
       (touch.gloc.of wrong-type\x60;2)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 76821))
     (touch.gloc.of wrong-type\x60;2)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of wrong-type\x60;2 "./boot/condition.scm" . 78862)))
 (set.gloc.of condition-accessor)
 (ret.const.unspec))
((close
   (2 0 . loop)
   (call (push.iloc.0 . 0) (apply.gloc.of record-type-parent "./boot/condition.scm" . 87058))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (touch.gloc.of loop\x60;7)
     (push.iloc.0 . 0)
     (call (push.iloc.0 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 88111))
     (push)
     (iloc.1 . 1)
     (push.cons)
     (apply.gloc.of loop\x60;7 "./boot/condition.scm" . 88097))
   (push.cdr.iloc (1 . 1) "./boot/condition.scm" . 89120)
   (ret.subr.gloc.of reverse "./boot/condition.scm" . 89111))
 (set.gloc.of loop\x60;7)
 (close
   (1 0)
   (touch.gloc.of loop\x60;7)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;7 "./boot/condition.scm" . 86025))
 (set.gloc.of list-parents\x60;2)
 (close
   (2 0 . describe-condition)
   (call (push.iloc.0 . 1) (apply.gloc.of condition? "./boot/condition.scm" . 91148))
   (if.true
     (subr.gloc.of make-string-output-port 0)
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . "  #<condition~!")
     (subr.gloc.of format 2 "./boot/condition.scm" . 93198)
     (call
       (push.close
         (1 0)
         (call (push.iloc.0 . 0) (apply.gloc.of record-rtd "./boot/condition.scm" . 96295))
         (push)
         (extend . 1)
         (call
           (touch.gloc.of list-parents\x60;2)
           (push.iloc.0 . 0)
           (apply.gloc.of list-parents\x60;2 "./boot/condition.scm" . 98349))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of record-type-field-names "./boot/condition.scm" . 99386))
         (push)
         (push.subr.gloc.of vector-length 1 "./boot/condition.scm" . 99371)
         (extend . 2)
         (push.iloc 3 . 0)
         (push.const . "~%    ~a")
         (call (push.iloc.1 . 0) (apply.gloc.of record-type-name "./boot/condition.scm" . 97322))
         (push)
         (subr.gloc.of format 3 "./boot/condition.scm" . 100384)
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (push.iloc 3 . 0)
           (push.const . " ~r")
           (push.iloc.0 . 0)
           (ret.subr.gloc.of format "./boot/condition.scm" . 101429))
         (=n.iloc (0 . 1) 1 "./boot/condition.scm" . 102439)
         (if.true
           (push.iloc 3 . 0)
           (push.const . ": ~r")
           (call
             (push.iloc 2 . 0)
             (call
               (push.iloc.1 . 0)
               (push.const . 0)
               (apply.gloc.of record-accessor "./boot/condition.scm" . 103483))
             (apply))
           (push)
           (ret.subr.gloc.of format "./boot/condition.scm" . 103463))
         (>n.iloc (0 . 1) 1 "./boot/condition.scm" . 104487)
         (if.true
           (extend.enclose+
             (2 0 . loop)
             (iloc.0 . 1)
             (if.not.pair?.ret.const . #f)
             (push.iloc 5 . 0)
             (push.const . "~%     ~a: ~r")
             (push.car.iloc (0 . 1) "./boot/condition.scm" . 109646)
             (call
               (push.iloc 4 . 0)
               (call
                 (push.iloc 3 . 0)
                 (push.iloc.0 . 0)
                 (apply.gloc.of record-accessor "./boot/condition.scm" . 109657))
               (apply))
             (push)
             (subr.gloc.of format 4 "./boot/condition.scm" . 109618)
             (push.n+.iloc (0 . 0) 1 "./boot/condition.scm" . 110648)
             (push.cdr.iloc (0 . 1) "./boot/condition.scm" . 110656)
             (apply.iloc+ (1 . 0) "./boot/condition.scm" . 110642))
           (push.const . 0)
           (call
             (push.iloc 2 . 0)
             (apply.gloc.of record-type-field-names "./boot/condition.scm" . 105536))
           (push)
           (push.subr.gloc.of vector->list 1 "./boot/condition.scm" . 105522)
           (apply.iloc+ (0 . 0) "./boot/condition.scm" . 106537))
         (ret.const.unspec))
       (call (push.iloc.1 . 1) (apply.gloc.of simple-conditions "./boot/condition.scm" . 94233))
       (push)
       (apply.gloc.of for-each "./boot/condition.scm" . 92172))
     (push.iloc.0 . 0)
     (push.const . "~%   >")
     (subr.gloc.of format 2 "./boot/condition.scm" . 112654)
     (push.iloc.1 . 0)
     (push.const . "~a~!")
     (push.iloc.0 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/condition.scm" . 113698)
     (ret.subr.gloc.of format "./boot/condition.scm" . 113678))
   (push.iloc.0 . 0)
   (push.const . "~r~!")
   (push.iloc.0 . 1)
   (ret.subr.gloc.of format "./boot/condition.scm" . 115724))
 (set.gloc.of describe-condition)
 (ret.const.unspec))
((call
   (call
     (push.const . &message)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 118837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable message)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 118798))
   (push)
   (extend . 1)
   (push.const . &message)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 119864))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 119824))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 120839))
 (set.gloc.of &message)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 121908))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 121888))
 (set.gloc.of make-message-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 122929))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 122908))
 (set.gloc.of message-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123951))
   (push)
   (call
     (call (push.gloc.of &message) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 123995))
     (push)
     (push.const . 0)
     (apply.gloc.of record-accessor "./boot/condition.scm" . 123978))
   (push)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 123931))
 (set.gloc.of condition-message)
 (ret.const.unspec))
((call
   (call
     (push.const . &warning)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 127029))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 126990))
   (push)
   (extend . 1)
   (push.const . &warning)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 128056))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 128016))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 129031))
 (set.gloc.of &warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 130090))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 130070))
 (set.gloc.of make-warning)
 (ret.const.unspec))
((call
   (call (push.gloc.of &warning) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 131111))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 131090))
 (set.gloc.of warning?)
 (ret.const.unspec))
((call
   (call
     (push.const . &serious)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 134197))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 134158))
   (push)
   (extend . 1)
   (push.const . &serious)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 135224))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 135184))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 136199))
 (set.gloc.of &serious)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 137268))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 137248))
 (set.gloc.of make-serious-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 138289))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 138268))
 (set.gloc.of serious-condition?)
 (ret.const.unspec))
((call
   (call
     (push.const . &error)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 141363))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 141326))
   (push)
   (extend . 1)
   (push.const . &error)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 142392))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 142352))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 143367))
 (set.gloc.of &error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 144424))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 144404))
 (set.gloc.of make-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 145445))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 145424))
 (set.gloc.of error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &violation)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 148535))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 148494))
   (push)
   (extend . 1)
   (push.const . &violation)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &serious) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 149560))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 149520))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 150535))
 (set.gloc.of &violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 151596))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 151576))
 (set.gloc.of make-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &violation) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 152617))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 152596))
 (set.gloc.of violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &assertion)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 155703))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 155662))
   (push)
   (extend . 1)
   (push.const . &assertion)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 156728))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 156688))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 157703))
 (set.gloc.of &assertion)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 158774))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 158754))
 (set.gloc.of make-assertion-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &assertion) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 159795))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 159774))
 (set.gloc.of assertion-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &irritants)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 162871))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable irritants)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 162830))
   (push)
   (extend . 1)
   (push.const . &irritants)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 163896))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 163856))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 164871))
 (set.gloc.of &irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 165935))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 165918))
 (set.gloc.of &irritants-irritants)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 166966))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 166946))
 (set.gloc.of make-irritants-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 167987))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 167966))
 (set.gloc.of irritants-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &irritants) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 169009))
   (push)
   (push.gloc.of &irritants-irritants)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 168989))
 (set.gloc.of condition-irritants)
 (ret.const.unspec))
((call
   (call
     (push.const . &who)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 172081))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable who)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 172046))
   (push)
   (extend . 1)
   (push.const . &who)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &condition)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 173112))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 173072))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 174087))
 (set.gloc.of &who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 175139))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 175122))
 (set.gloc.of &who-who)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 176176))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 176156))
 (set.gloc.of make-who-condition)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 177197))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 177176))
 (set.gloc.of who-condition?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &who) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 178219))
   (push)
   (push.gloc.of &who-who)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 178199))
 (set.gloc.of condition-who)
 (ret.const.unspec))
((call
   (call
     (push.const . &non-continuable)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 181309))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 181262))
   (push)
   (extend . 1)
   (push.const . &non-continuable)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 182328))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 182288))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 183303))
 (set.gloc.of &non-continuable)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 184380))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 184360))
 (set.gloc.of make-non-continuable-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &non-continuable)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 185401))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 185380))
 (set.gloc.of non-continuable-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &implementation-restriction)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 188488))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 188430))
   (push)
   (extend . 1)
   (push.const . &implementation-restriction)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 189496))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 189456))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 190471))
 (set.gloc.of &implementation-restriction)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 192535))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 192515))
 (set.gloc.of make-implementation-restriction-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &implementation-restriction)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 194584))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 194563))
 (set.gloc.of implementation-restriction-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &lexical)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 197685))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 197646))
   (push)
   (extend . 1)
   (push.const . &lexical)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 198712))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 198672))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 199687))
 (set.gloc.of &lexical)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 200756))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 200736))
 (set.gloc.of make-lexical-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &lexical) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 201777))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 201756))
 (set.gloc.of lexical-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &syntax)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 204852))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable form) (immutable subform)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 204814))
   (push)
   (extend . 1)
   (push.const . &syntax)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 205880))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 205840))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 206855))
 (set.gloc.of &syntax)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 207911))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 207894))
 (set.gloc.of &syntax-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 208938))
   (push)
   (push.const . 1)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 208921))
 (set.gloc.of &syntax-subform)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 209971))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 209951))
 (set.gloc.of make-syntax-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 210992))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 210971))
 (set.gloc.of syntax-violation?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 212019))
   (push)
   (push.gloc.of &syntax-form)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 211999))
 (set.gloc.of syntax-violation-form)
 (ret.const.unspec))
((call
   (call (push.gloc.of &syntax) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 213046))
   (push)
   (push.gloc.of &syntax-subform)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 213026))
 (set.gloc.of syntax-violation-subform)
 (ret.const.unspec))
((call
   (call
     (push.const . &undefined)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 216119))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 216078))
   (push)
   (extend . 1)
   (push.const . &undefined)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &violation)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 217144))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 217104))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 218119))
 (set.gloc.of &undefined)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 219190))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 219170))
 (set.gloc.of make-undefined-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &undefined) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 220211))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 220190))
 (set.gloc.of undefined-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 223281))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 223246))
   (push)
   (extend . 1)
   (push.const . &i/o)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &error) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 224312))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 224272))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 225287))
 (set.gloc.of &i/o)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 226348))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 226328))
 (set.gloc.of make-i/o-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 227369))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 227348))
 (set.gloc.of i/o-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-read)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 230454))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 230414))
   (push)
   (extend . 1)
   (push.const . &i/o-read)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 231480))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 231440))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 232455))
 (set.gloc.of &i/o-read)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 233521))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 233501))
 (set.gloc.of make-i/o-read-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-read) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 234542))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 234521))
 (set.gloc.of i/o-read-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-write)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 237623))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 237582))
   (push)
   (extend . 1)
   (push.const . &i/o-write)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 238648))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 238608))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 239623))
 (set.gloc.of &i/o-write)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 240690))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 240670))
 (set.gloc.of make-i/o-write-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-write) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 241711))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 241690))
 (set.gloc.of i/o-write-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-invalid-position)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 244802))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable position)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 244750))
   (push)
   (extend . 1)
   (push.const . &i/o-invalid-position)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 245816))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 245776))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 246791))
 (set.gloc.of &i/o-invalid-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 248852))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 248835))
 (set.gloc.of &i/o-invalid-position-position)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 250903))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 250883))
 (set.gloc.of make-i/o-invalid-position-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 251962))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 251941))
 (set.gloc.of i/o-invalid-position-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-invalid-position)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 253975))
   (push)
   (push.gloc.of &i/o-invalid-position-position)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 253955))
 (set.gloc.of i/o-error-position)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-filename)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 257082))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable filename)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 257038))
   (push)
   (extend . 1)
   (push.const . &i/o-filename)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 258104))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 258064))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 259079))
 (set.gloc.of &i/o-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 260145))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 260128))
 (set.gloc.of &i/o-filename-filename)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 261173))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 261153))
 (set.gloc.of make-i/o-filename-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 262194))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 262173))
 (set.gloc.of i/o-filename-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-filename)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 263216))
   (push)
   (push.gloc.of &i/o-filename-filename)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 263196))
 (set.gloc.of i/o-error-filename)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-protection)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 266305))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 266254))
   (push)
   (extend . 1)
   (push.const . &i/o-file-protection)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 267320))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 267280))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 268295))
 (set.gloc.of &i/o-file-protection)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 270359))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 270339))
 (set.gloc.of make-i/o-file-protection-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-protection)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 271417))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 271396))
 (set.gloc.of i/o-file-protection-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-is-read-only)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 274499))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 274446))
   (push)
   (extend . 1)
   (push.const . &i/o-file-is-read-only)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-file-protection)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 275512))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 275472))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 276487))
 (set.gloc.of &i/o-file-is-read-only)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 277566))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 277546))
 (set.gloc.of make-i/o-file-is-read-only-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-is-read-only)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 278587))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 278566))
 (set.gloc.of i/o-file-is-read-only-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-already-exists)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 281669))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 281614))
   (push)
   (extend . 1)
   (push.const . &i/o-file-already-exists)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 282680))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 282640))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 283655))
 (set.gloc.of &i/o-file-already-exists)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 284736))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 284716))
 (set.gloc.of make-i/o-file-already-exists-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-already-exists)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 285757))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 285736))
 (set.gloc.of i/o-file-already-exists-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-file-does-not-exist)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 288837))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 288782))
   (push)
   (extend . 1)
   (push.const . &i/o-file-does-not-exist)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &i/o-filename)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 289848))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 289808))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 290823))
 (set.gloc.of &i/o-file-does-not-exist)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 291904))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 291884))
 (set.gloc.of make-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-file-does-not-exist)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 292925))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 292904))
 (set.gloc.of i/o-file-does-not-exist-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-port)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 295990))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable port)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 295950))
   (push)
   (extend . 1)
   (push.const . &i/o-port)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 297016))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 296976))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 297991))
 (set.gloc.of &i/o-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 299049))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 299032))
 (set.gloc.of &i/o-port-port)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 300081))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 300061))
 (set.gloc.of make-i/o-port-error)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 301102))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 301081))
 (set.gloc.of i/o-port-error?)
 (ret.const.unspec))
((call
   (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 302124))
   (push)
   (push.gloc.of &i/o-port-port)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 302104))
 (set.gloc.of i/o-error-port)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-decoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 305210))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 305166))
   (push)
   (extend . 1)
   (push.const . &i/o-decoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 306232))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 306192))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 307207))
 (set.gloc.of &i/o-decoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 308277))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 308257))
 (set.gloc.of make-i/o-decoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-decoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 309298))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 309277))
 (set.gloc.of i/o-decoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.const . &i/o-encoding)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 312378))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #((immutable char)))
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 312334))
   (push)
   (extend . 1)
   (push.const . &i/o-encoding)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call (push.gloc.of &i/o-port) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 313400))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 313360))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 314375))
 (set.gloc.of &i/o-encoding)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 315437))
   (push)
   (push.const . 0)
   (apply.gloc.of record-accessor "./boot/condition.scm" . 315420))
 (set.gloc.of &i/o-encoding-char)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 316469))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 316449))
 (set.gloc.of make-i/o-encoding-error)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 317490))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 317469))
 (set.gloc.of i/o-encoding-error?)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &i/o-encoding)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 318517))
   (push)
   (push.gloc.of &i/o-encoding-char)
   (apply.gloc.of condition-accessor "./boot/condition.scm" . 318497))
 (set.gloc.of i/o-encoding-error-char)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-infinities)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 321595))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 321550))
   (push)
   (extend . 1)
   (push.const . &no-infinities)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 322616))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 322576))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 323591))
 (set.gloc.of &no-infinities)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rcd "./boot/condition.scm" . 324666))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 324646))
 (set.gloc.of make-no-infinities-violation)
 (ret.const.unspec))
((call
   (call
     (push.gloc.of &no-infinities)
     (apply.gloc.of record-type-rtd "./boot/condition.scm" . 325687))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 325666))
 (set.gloc.of no-infinities-violation?)
 (ret.const.unspec))
((call
   (call
     (push.const . &no-nans)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rtd "./boot/condition.scm" . 328757))
     (push)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #())
     (apply.gloc.of make-record-type-descriptor "./boot/condition.scm" . 328718))
   (push)
   (extend . 1)
   (push.const . &no-nans)
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (call
       (push.gloc.of &implementation-restriction)
       (apply.gloc.of record-type-rcd "./boot/condition.scm" . 329784))
     (push)
     (push.const . #f)
     (apply.gloc.of make-record-constructor-descriptor "./boot/condition.scm" . 329744))
   (push)
   (apply.gloc.of make-record-type "./boot/condition.scm" . 330759))
 (set.gloc.of &no-nans)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rcd "./boot/condition.scm" . 331828))
   (push)
   (apply.gloc.of record-constructor "./boot/condition.scm" . 331808))
 (set.gloc.of make-no-nans-violation)
 (ret.const.unspec))
((call
   (call (push.gloc.of &no-nans) (apply.gloc.of record-type-rtd "./boot/condition.scm" . 332849))
   (push)
   (apply.gloc.of condition-predicate "./boot/condition.scm" . 332828))
 (set.gloc.of no-nans-violation?)
 (ret.const.unspec))

;
((call (push.const . 100) (apply.gloc.of make-parameter "./boot/pp.scm" . 62498))
 (set.gloc.of pretty-print-line-length)
 (ret.const.unspec))
((call (push.const . 0) (apply.gloc.of make-parameter "./boot/pp.scm" . 63525))
 (set.gloc.of pretty-print-initial-indent)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 64548))
 (set.gloc.of pretty-print-maximum-lines)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/pp.scm" . 65572))
 (set.gloc.of pretty-print-unwrap-syntax)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     library
     define
     define-syntax
     define-macro
     define-inline
     define-constant
     syntax-rules
     syntax-case
     with-syntax
     lambda
     let-syntax
     letrec-syntax
     let
     letrec
     let*
     letrec
     letrec*
     let-values
     let*-values
     destructuring-match
     parameterize)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 74763))
 (set.gloc.of indent-type1?\x60;4)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const if cond case and or set! import export cons map for-each exists for-all)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 82955))
 (set.gloc.of indent-type2?\x60;4)
 (close
   (1 0)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (extend.enclose
       (3 0 . loop)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of core-hashtable-ref 3 "./boot/pp.scm" . 197656)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (ret.subr.gloc.of memq "./boot/pp.scm" . 198680))
       (iloc.0 . 0)
       (if.pair?
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 200735)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (call
           (push.car.iloc (1 . 0) "./boot/pp.scm" . 202795)
           (push.iloc.0 . 0)
           (push.iloc.1 . 2)
           (apply.iloc (2 . 0) "./boot/pp.scm" . 202789))
         (if.true.ret)
         (push.cdr.iloc (1 . 0) "./boot/pp.scm" . 203819)
         (push.iloc.0 . 0)
         (push.iloc.1 . 2)
         (apply.iloc (2 . 0) "./boot/pp.scm" . 203813))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/pp.scm" . 204831)
       (if.true
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.const . #t)
         (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 205855)
         (push.iloc.0 . 0)
         (iloc.0 . 1)
         (push.cons)
         (extend . 1)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.iloc 2 . 2)
           (apply.iloc (3 . 0) "./boot/pp.scm" . 207923))
         (push.iloc.1 . 0)
         (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 207948)
         (apply.gloc.of any1 "./boot/pp.scm" . 207905))
       (push.iloc.0 . 0)
       (subr.gloc.of tuple? 1 "./boot/pp.scm" . 208927)
       (if.false.ret)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (subr.gloc.of core-hashtable-set! 3 "./boot/pp.scm" . 209951)
       (>n.iloc (0 . 2) 0 "./boot/pp.scm" . 210980)
       (if.false.ret)
       (push.iloc.0 . 0)
       (iloc.0 . 1)
       (push.cons)
       (push.n+.iloc (0 . 2) -1 "./boot/pp.scm" . 212048)
       (extend . 2)
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (apply.iloc (3 . 0) "./boot/pp.scm" . 213048))
       (push.iloc.1 . 0)
       (push.subr.gloc.of tuple->list 1 "./boot/pp.scm" . 213073)
       (apply.gloc.of any1 "./boot/pp.scm" . 213030))
     (push.iloc 2 . 0)
     (push.const)
     (subr.gloc.of record-print-nesting-limit 0)
     (push)
     (apply.iloc (0 . 0) "./boot/pp.scm" . 196626))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of infinite-print?\x60;4)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.subr.gloc.of symbol->string 1 "./boot/pp.scm" . 134170)
   (ret.subr.gloc.of string-length "./boot/pp.scm" . 134155))
 (set.gloc.of symbol->length\x60;4)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const do let-optionals)
   (ret.subr.gloc.of memq "./boot/pp.scm" . 87051))
 (set.gloc.of indent-type3?\x60;4)
 (close
   (2 0)
   (>=n.iloc (0 . 0) 0 "./boot/pp.scm" . 91152)
   (if.false.ret)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (car.iloc (0 . 1) "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of cdar 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (subr.gloc.of cddar 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 1)
     (subr.gloc.of cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 2 . 1)
     (subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (ret.pair? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 3 . 1)
     (subr.gloc.of cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (push)
   (extend . 1)
   (call
     (iloc 3 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of cdddar 1 "./boot/pp.scm" . 92180)
     (ret.null? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&BREAK)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true.ret.const . #t)
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&FLAT)
     (if.not.eq?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (const . #\;)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.n+.iloc (4 . 0) -1 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc 2 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (ret.subr.gloc.of string? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of - 2 "./boot/pp.scm" . 92180)
     (push.cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of car 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&GROUP)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caar 1 "./boot/pp.scm" . 92180)
     (push.const . \x2E;&FLAT)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of cdr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (subr.gloc.of cdr 1 "./boot/pp.scm" . 92180)
     (if.not.pair?.ret.const . #f)
     (push.iloc 4 . 1)
     (subr.gloc.of cdddar 1 "./boot/pp.scm" . 92180)
     (if.not.null?.ret.const . #f)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of car 1 "./boot/pp.scm" . 92180)
     (const . \x2E;&NEST)
     (ret.eq? "./boot/pp.scm" . 92180))
   (if.true
     (touch.gloc.of fits?\x60;4)
     (push.iloc 4 . 0)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caar 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of cadr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of + 2 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 92180)
     (push.iloc 4 . 1)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of cddr 1 "./boot/pp.scm" . 92180)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
     (cdr.iloc (4 . 1) "./boot/pp.scm" . 92180)
     (push.cons)
     (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
   (iloc.0 . 0)
   (if.false.ret)
   (push.iloc 4 . 1)
   (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 92180)
   (push.iloc 4 . 1)
   (push.subr.gloc.of caar 1 "./boot/pp.scm" . 92180)
   (extend . 2)
   (touch.gloc.of fits?\x60;4)
   (push.iloc 5 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc 5 . 1)
   (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
   (push.subr.gloc.of car 1 "./boot/pp.scm" . 92180)
   (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc 5 . 1)
   (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 92180)
   (push.subr.gloc.of cdr 1 "./boot/pp.scm" . 92180)
   (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 92180)
   (push.cdr.iloc (5 . 1) "./boot/pp.scm" . 92180)
   (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 92180)
   (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 92180))
 (set.gloc.of fits?\x60;4)
 (close
   (1 0)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (cddr.iloc (1 . 0) "./boot/pp.scm" . 149522)
       (ret.null? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (cddr.iloc (2 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "'")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . quasiquote)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . "`")
       (push.const . \x2E;&NEST)
       (push.const . 1)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . unquote-splicing)
       (ret.eq? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . ",@")
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse\x60;4)
         (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (const . let)
       (if.not.eq?.ret.const . #f)
       (cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (if.not.symbol?.ret.const . #f)
       (push.iloc 3 . 0)
       (subr.gloc.of cdddr 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of cdddr 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of caddr 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(let ~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . 4)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type1?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type1?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type2?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type2?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.cddr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.iloc.0 . 2)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (call
         (touch.gloc.of symbol->length\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of symbol->length\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . 2)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 149522)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (call
         (touch.gloc.of indent-type3?\x60;4)
         (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
         (apply.gloc.of indent-type3?\x60;4 "./boot/pp.scm" . 149522))
       (if.false.ret)
       (push.iloc 3 . 0)
       (subr.gloc.of cdddr 1 "./boot/pp.scm" . 149522)
       (ret.pair? "./boot/pp.scm" . 149522))
     (if.true
       (push.iloc 3 . 0)
       (push.subr.gloc.of cdddr 1 "./boot/pp.scm" . 149522)
       (push.iloc 3 . 0)
       (push.subr.gloc.of caddr 1 "./boot/pp.scm" . 149522)
       (push.cadr.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (extend . 3)
       (push.const . \x2E;&GROUP)
       (push.const . "(~a ")
       (push.car.iloc (4 . 0) "./boot/pp.scm" . 149522)
       (push.subr.gloc.of format 2 "./boot/pp.scm" . 149522)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 2)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const . #\;)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc.0 . 1)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;list 5 "./boot/pp.scm" . 149522)
       (push.const . #\;)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc.0 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.const ")")
       (push.subr.gloc.of \x2E;append 2 "./boot/pp.scm" . 149522)
       (push.subr.gloc.of \x2E;cons* 5 "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of \x2E;list "./boot/pp.scm" . 149522))
     (call
       (iloc 3 . 0)
       (if.not.pair?.ret.const . #f)
       (push.car.iloc (3 . 0) "./boot/pp.scm" . 149522)
       (ret.subr.gloc.of symbol? "./boot/pp.scm" . 149522))
     (if.true
       (push.const . \x2E;&GROUP)
       (push.const . "(")
       (push.const . \x2E;&NEST)
       (push.const . 2)
       (call
         (touch.gloc.of parse-list\x60;4)
         (push.iloc 3 . 0)
         (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 149522)
       (push.const ")")
       (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
     (push.const . \x2E;&GROUP)
     (push.const . "(")
     (push.const . \x2E;&NEST)
     (push.const . 1)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.iloc 3 . 0)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 149522))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 149522)
     (push.const ")")
     (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 149522))
   (push.iloc.0 . 0)
   (subr.gloc.of vector? 1 "./boot/pp.scm" . 184338)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of vector-length 1 "./boot/pp.scm" . 185369)
     (push.const . 0)
     (subr.gloc.of = 2 "./boot/pp.scm" . 185366)
     (if.true.ret.const . "#()")
     (push.const . \x2E;&GROUP)
     (push.const . "#(")
     (push.const . \x2E;&NEST)
     (push.const . 2)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.iloc.0 . 0)
       (push.subr.gloc.of vector->list 1 "./boot/pp.scm" . 187453)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 187441))
     (push)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 185362)
     (push.const ")")
     (ret.subr.gloc.of \x2E;cons* "./boot/pp.scm" . 185362))
   (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/pp.scm" . 188434))
   (if.true
     (push.const . "~u")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/pp.scm" . 189458))
   (push.const . "~s")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/pp.scm" . 191506))
 (set.gloc.of parse\x60;4)
 (close
   (1 0)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 139289)
   (if.null?
     (call
       (touch.gloc.of parse\x60;4)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 140319)
       (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 140312))
     (push)
     (ret.subr.gloc.of list "./boot/pp.scm" . 140306))
   (cdr.iloc (0 . 0) "./boot/pp.scm" . 141337)
   (if.pair?
     (call
       (touch.gloc.of parse\x60;4)
       (push.car.iloc (0 . 0) "./boot/pp.scm" . 142368)
       (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 142361))
     (push)
     (push.const . #\;)
     (call
       (touch.gloc.of parse-list\x60;4)
       (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 142395)
       (apply.gloc.of parse-list\x60;4 "./boot/pp.scm" . 142383))
     (push)
     (ret.subr.gloc.of cons* "./boot/pp.scm" . 142354))
   (call
     (touch.gloc.of parse\x60;4)
     (push.car.iloc (0 . 0) "./boot/pp.scm" . 144415)
     (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 144408))
   (push)
   (push.const . #\;)
   (push.const . ".")
   (push.const . #\;)
   (call
     (touch.gloc.of parse\x60;4)
     (push.cdr.iloc (0 . 0) "./boot/pp.scm" . 144445)
     (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 144438))
   (push)
   (ret.subr.gloc.of list "./boot/pp.scm" . 144402))
 (set.gloc.of parse-list\x60;4)
 (close
   (1 1 . pretty-print)
   (call
     (iloc.0 . 1)
     (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of car "./boot/pp.scm" . 69666))
     (ret.subr.gloc.of current-output-port "./boot/pp.scm" . 69677))
   (push)
   (call
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70686))
     (if.false.ret)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/pp.scm" . 70718))
     (push)
     (push.const . 1)
     (ret.subr.gloc.of - "./boot/pp.scm" . 70715))
   (push)
   (extend . 2)
   (extend.enclose
     (3 0)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.gloc.of string?)
     (extend . 1)
     (call
       (iloc.1 . 2)
       (if.not.pair?.ret.const . #f)
       (car.iloc (1 . 2) "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of cdar 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc.1 . 2)
       (subr.gloc.of cddar 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 2 . 2)
       (subr.gloc.of cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 3 . 2)
       (subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (ret.pair? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 4 . 2)
       (subr.gloc.of cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (push)
     (extend . 1)
     (call
       (iloc 3 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of cdddar 1 "./boot/pp.scm" . 104463)
       (ret.null? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&BREAK)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caar 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (call
         (push.iloc 8 . 1)
         (const . #f)
         (if.eq?.ret.const . #t)
         (push.iloc 8 . 1)
         (push.const . 0)
         (ret.subr.gloc.of > "./boot/pp.scm" . 104463))
       (if.true
         (call
           (iloc 8 . 1)
           (if.false.ret)
           (n+.iloc (8 . 1) -1 "./boot/pp.scm" . 104463)
           (set.iloc 8 . 1)
           (ret.const.unspec))
         (push.iloc 8 . 0)
         (push.const . #\linefeed)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
         (call
           (extend.enclose+
             (1 0 . loop)
             (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.iloc 10 . 0)
             (push.const . #\space)
             (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
             (if.false.ret)
             (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 104463)
             (apply.iloc+ (1 . 0) "./boot/pp.scm" . 104463))
           (push.iloc.1 . 1)
           (apply.iloc+ (0 . 0) "./boot/pp.scm" . 104463))
         (push.iloc 6 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
       (ret.const.unspec))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&FLAT)
       (if.not.eq?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (const . #\;)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (extend . 1)
       (push.iloc 8 . 0)
       (push.const . #\space)
       (subr.gloc.of put-char 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.n+.iloc (6 . 1) 1 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (apply.iloc (4 . 0) "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (extend . 2)
       (push.iloc 8 . 0)
       (push.iloc.0 . 1)
       (subr.gloc.of put-string 2 "./boot/pp.scm" . 104463)
       (push.iloc 6 . 0)
       (push.iloc 6 . 1)
       (push.iloc.0 . 1)
       (push.subr.gloc.of string-length 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc.0 . 0)
       (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of car 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&GROUP)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of cdr 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caar 1 "./boot/pp.scm" . 104463)
       (extend . 3)
       (push.iloc.0 . 2)
       (push.const . \x2E;&FLAT)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (iloc.0 . 0)
       (push.cons)
       (extend . 1)
       (call
         (touch.gloc.of fits?\x60;4)
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.subr.gloc.of - 2 "./boot/pp.scm" . 104463)
         (push.iloc.0 . 0)
         (apply.gloc.of fits?\x60;4 "./boot/pp.scm" . 104463))
       (if.true
         (push.iloc 7 . 0)
         (push.iloc 7 . 1)
         (push.iloc.0 . 0)
         (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
       (push.iloc 7 . 0)
       (push.iloc 7 . 1)
       (push.iloc.1 . 2)
       (push.const . \x2E;&BREAK)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (iloc.1 . 0)
       (push.cons)
       (apply.iloc (8 . 0) "./boot/pp.scm" . 104463))
     (call
       (iloc.1 . 0)
       (if.false.ret)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (subr.gloc.of cdr 1 "./boot/pp.scm" . 104463)
       (if.not.pair?.ret.const . #f)
       (push.iloc 5 . 2)
       (subr.gloc.of cdddar 1 "./boot/pp.scm" . 104463)
       (if.not.null?.ret.const . #f)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of car 1 "./boot/pp.scm" . 104463)
       (const . \x2E;&NEST)
       (ret.eq? "./boot/pp.scm" . 104463))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 5 . 1)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caar 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of cadr 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of + 2 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 104463)
       (push.iloc 5 . 2)
       (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of cddr 1 "./boot/pp.scm" . 104463)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
       (cdr.iloc (5 . 2) "./boot/pp.scm" . 104463)
       (push.cons)
       (apply.iloc (6 . 0) "./boot/pp.scm" . 104463))
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc 5 . 2)
     (push.subr.gloc.of cadar 1 "./boot/pp.scm" . 104463)
     (push.iloc 5 . 2)
     (push.subr.gloc.of caar 1 "./boot/pp.scm" . 104463)
     (extend . 2)
     (push.iloc 6 . 0)
     (push.iloc 6 . 1)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 6 . 2)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
     (push.subr.gloc.of car 1 "./boot/pp.scm" . 104463)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.iloc 6 . 2)
     (push.subr.gloc.of caddar 1 "./boot/pp.scm" . 104463)
     (push.subr.gloc.of cdr 1 "./boot/pp.scm" . 104463)
     (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 104463)
     (push.cdr.iloc (6 . 2) "./boot/pp.scm" . 104463)
     (push.subr.gloc.of \x2E;cons* 3 "./boot/pp.scm" . 104463)
     (apply.iloc (7 . 0) "./boot/pp.scm" . 104463))
   (call
     (call
       (touch.gloc.of infinite-print?\x60;4)
       (push.iloc 2 . 0)
       (apply.gloc.of infinite-print?\x60;4 "./boot/pp.scm" . 217099))
     (if.true
       (push.iloc.1 . 0)
       (push.const . "~w")
       (push.iloc 2 . 0)
       (ret.subr.gloc.of format "./boot/pp.scm" . 218123))
     (call (apply.gloc.of pretty-print-line-length "./boot/pp.scm" . 219160))
     (push)
     (extend . 1)
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of collect-notify 0 "./boot/pp.scm" . 221199)
       (set.iloc 1 . 0)
       (push.const . #f)
       (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (push.close
       (0 0)
       (push.iloc 2 . 0)
       (push.const . 0)
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 221218))
       (push)
       (push.const . \x2E;&FLAT)
       (call
         (touch.gloc.of parse\x60;4)
         (push.iloc 5 . 0)
         (apply.gloc.of parse\x60;4 "./boot/pp.scm" . 221256))
       (push)
       (push.subr.gloc.of \x2E;list 3 "./boot/pp.scm" . 221199)
       (push.subr.gloc.of \x2E;list 1 "./boot/pp.scm" . 221199)
       (apply.iloc (3 . 0) "./boot/pp.scm" . 221199))
     (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of collect-notify "./boot/pp.scm" . 221199))
     (apply.gloc.of \x2E;dynamic-wind "./boot/pp.scm" . 221199))
   (call
     (iloc.1 . 1)
     (if.false.ret)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of <= "./boot/pp.scm" . 222240))
   (if.true
     (push.iloc.1 . 0)
     (push.const . #\linefeed)
     (subr.gloc.of put-char 2 "./boot/pp.scm" . 223246)
     (call
       (extend.enclose+
         (1 0 . loop)
         (>n.iloc (0 . 0) 0 "./boot/pp.scm" . 224321)
         (if.false.ret)
         (push.iloc 3 . 0)
         (push.const . #\space)
         (subr.gloc.of put-char 2 "./boot/pp.scm" . 224329)
         (if.false.ret)
         (push.n+.iloc (0 . 0) -1 "./boot/pp.scm" . 224359)
         (apply.iloc+ (1 . 0) "./boot/pp.scm" . 224353))
       (call (apply.gloc.of pretty-print-initial-indent "./boot/pp.scm" . 224284))
       (push)
       (apply.iloc+ (0 . 0) "./boot/pp.scm" . 224270))
     (push.iloc.1 . 0)
     (push.const . "  ...")
     (ret.subr.gloc.of put-string "./boot/pp.scm" . 225294))
   (ret.const.unspec))
 (set.gloc.of pretty-print)
 (ret.const.unspec))

;
((const . ypsilon-0.9.6-080816)
 (set.gloc.of auto-compile-cache-validation-signature)
 (ret.const.unspec))
((close
   (1 0 . core-eval)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of backtrace 0 "./boot/eval.scm" . 10247)
     (set.iloc 1 . 0)
     (push.const . #f)
     (ret.subr.gloc.of backtrace "./boot/eval.scm" . 10247))
   (push.close
     (0 0)
     (touch.gloc.of interpret-coreform)
     (push.iloc 2 . 0)
     (apply.gloc.of interpret-coreform "./boot/eval.scm" . 10247))
   (push.close (0 0) (push.iloc.1 . 0) (ret.subr.gloc.of backtrace "./boot/eval.scm" . 10247))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 10247))
 (set.gloc.of core-eval)
 (ret.const.unspec))
((close
   (1 0 . compile)
   (push.const . #f)
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (call
       (touch.gloc.of current-closure-comments)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
     (set.iloc 1 . 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 1)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
   (push.close
     (0 0)
     (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 16409))
     (push)
     (apply.gloc.of compile-coreform "./boot/eval.scm" . 16391))
   (push.close
     (0 0)
     (touch.gloc.of current-closure-comments)
     (push.iloc.1 . 0)
     (apply.gloc.of current-closure-comments "./boot/eval.scm" . 16391))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 16391))
 (set.gloc.of compile)
 (ret.const.unspec))
((close
   (1 0 . interpret)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call
     (push.const . #f)
     (subr.gloc.of make-core-hashtable 0)
     (push)
     (extend . 2)
     (push.close
       (0 0)
       (call
         (touch.gloc.of current-closure-comments)
         (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
       (set.iloc 1 . 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 1)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
     (push.close
       (0 0)
       (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 23584))
       (push)
       (apply.gloc.of compile-coreform "./boot/eval.scm" . 23566))
     (push.close
       (0 0)
       (touch.gloc.of current-closure-comments)
       (push.iloc.1 . 0)
       (apply.gloc.of current-closure-comments "./boot/eval.scm" . 23566))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 23566))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 24583))
 (set.gloc.of interpret)
 (ret.const.unspec))
((close
   (1 0 . interpret-coreform)
   (touch.gloc.of run-vmi)
   (push.const 1 . 0)
   (call (push.iloc.0 . 0) (apply.gloc.of compile-coreform "./boot/eval.scm" . 28704))
   (push.cons)
   (apply.gloc.of run-vmi "./boot/eval.scm" . 29703))
 (set.gloc.of interpret-coreform)
 (ret.const.unspec))
((close
   (0 1 . environment)
   (call
     (touch.gloc.of parse-imports)
     (push.const . environment)
     (iloc.0 . 0)
     (push.cons)
     (push.iloc.0 . 0)
     (apply.gloc.of parse-imports "./boot/eval.scm" . 33797))
   (push.const . type:eval-environment)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of tuple "./boot/eval.scm" . 34821))
 (set.gloc.of environment)
 (ret.const.unspec))
((close
   (2 0 . eval)
   (call
     (touch.gloc.of environment?)
     (push.iloc.0 . 1)
     (apply.gloc.of environment? "./boot/eval.scm" . 38924))
   (if.true
     (push.const . #f)
     (extend . 1)
     (push.close
       (0 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 40974)
       (set.iloc 1 . 0)
       (push.iloc 2 . 1)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 40974))
     (push.close
       (0 0)
       (touch.gloc.of interpret)
       (push.iloc 2 . 0)
       (apply.gloc.of interpret "./boot/eval.scm" . 40974))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 40974))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 40974))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 43029)
   (push.const . type:eval-environment)
   (subr.gloc.of eq? 2 "./boot/eval.scm" . 43024)
   (if.false.call
     (push.const . eval)
     (push.const . "expected environment, but got ~r, as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of format 2 "./boot/eval.scm" . 44075)
     (apply.gloc.of assertion-violation "./boot/eval.scm" . 44048))
   (touch.gloc.of interpret)
   (push.const . begin)
   (push.const . library)
   (push.const \x2E;R6RS-EVAL)
   (push.const export)
   (push.const . import)
   (push.const
     rename
     (only (core primitives) set-top-level-value! string->symbol)
     (set-top-level-value! \x2E;SET-TOP-LEVEL-VALUE!)
     (string->symbol \x2E;STRING->SYMBOL))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of tuple-ref 2 "./boot/eval.scm" . 53286)
   (push.subr.gloc.of \x2E;cons* 3 "./boot/eval.scm" . 45068)
   (push.const . \x2E;SET-TOP-LEVEL-VALUE!)
   (push.const \x2E;STRING->SYMBOL ".R6RS-EVAL-RESULT")
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;list 3 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 5 "./boot/eval.scm" . 45068)
   (push.const . let)
   (push.const (result \x2E;R6RS-EVAL-RESULT))
   (push.const \x2E;set-top-level-value! '\x2E;R6RS-EVAL-RESULT \x2E;&UNDEF)
   (push.const . \x2E;unintern-scheme-library)
   (push.const . quote)
   (call
     (touch.gloc.of generate-library-id)
     (push.const \x2E;R6RS-EVAL)
     (apply.gloc.of generate-library-id "./boot/eval.scm" . 57400))
   (push)
   (push.subr.gloc.of \x2E;list 2 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 2 "./boot/eval.scm" . 45068)
   (push.const result)
   (push.subr.gloc.of \x2E;cons* 5 "./boot/eval.scm" . 45068)
   (push.subr.gloc.of \x2E;list 3 "./boot/eval.scm" . 45068)
   (apply.gloc.of interpret "./boot/eval.scm" . 45068))
 (set.gloc.of eval)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 60445))
 (set.gloc.of scheme-load-verbose)
 (ret.const.unspec))
((call (push.const) (apply.gloc.of make-parameter "./boot/eval.scm" . 61467))
 (set.gloc.of scheme-load-paths)
 (ret.const.unspec))
((close
   (1 0 . expand-path)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 65564)
     (push.const . 1)
     (subr.gloc.of > 2 "./boot/eval.scm" . 65561)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 65594)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 65588))
   (push)
   (extend . 1)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 66595)
     (push.const . #\~)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 66587))
   (if.true
     (push.const . "~a~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 67613))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 67648)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 67630)
     (ret.subr.gloc.of format "./boot/eval.scm" . 67598))
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 68643)
     (push.const . #\.)
     (ret.subr.gloc.of char=? "./boot/eval.scm" . 68635))
   (if.true
     (push.const . "~a~/")
     (subr.gloc.of current-directory 0)
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.iloc.1 . 0)
     (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 69699)
     (push.subr.gloc.of substring 3 "./boot/eval.scm" . 69681)
     (ret.subr.gloc.of format "./boot/eval.scm" . 69646))
   (push.iloc.1 . 0)
   (push.const . ".")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 70670)
   (if.true
     (push.const . "~/")
     (subr.gloc.of current-directory 0)
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 71694))
   (push.iloc.1 . 0)
   (push.const . "~")
   (subr.gloc.of string=? 2 "./boot/eval.scm" . 72718)
   (if.true
     (push.const . "~/")
     (call (apply.gloc.of home-directory "./boot/eval.scm" . 73755))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 73742))
   (push.const . "~/")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 75790))
 (set.gloc.of expand-path)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . load)
   (push.const . "~a~/~a not found")
   (push.const . #\")
   (push.iloc.0 . 0)
   (push.const . #\")
   (push.subr.gloc.of format 4 "./boot/eval.scm" . 82980)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 82953))
 (set.gloc.of path-not-found\x60;2)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 87054)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of confirm-path\x60;2)
 (close
   (1 0 . locate-load-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 89103)
   (push.const . 0)
   (subr.gloc.of = 2 "./boot/eval.scm" . 89100)
   (if.true
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 90124))
   (call
     (push.iloc.0 . 0)
     (push.const . ":")
     (subr.gloc.of string-contains 2 "./boot/eval.scm" . 91152)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 91185)
     (push.const #\/ #\\)
     (ret.subr.gloc.of memq "./boot/eval.scm" . 91179))
   (if.true
     (call
       (touch.gloc.of confirm-path\x60;2)
       (push.iloc.0 . 0)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 92176))
     (if.true.ret)
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 92196))
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of string-ref 2 "./boot/eval.scm" . 93202)
   (push.const #\. #\~)
   (subr.gloc.of memq 2 "./boot/eval.scm" . 93196)
   (if.true
     (call
       (touch.gloc.of confirm-path\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/eval.scm" . 94238))
       (push)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 94224))
     (if.true.ret)
     (touch.gloc.of path-not-found\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 94258))
   (call
     (touch.gloc.of any1)
     (push.close
       (1 0)
       (touch.gloc.of confirm-path\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (push.const . "/")
         (push.iloc.1 . 0)
         (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 95289)
         (apply.gloc.of expand-path "./boot/eval.scm" . 95276))
       (push)
       (apply.gloc.of confirm-path\x60;2 "./boot/eval.scm" . 95262))
     (push.const . ".")
     (call (apply.gloc.of scheme-load-paths "./boot/eval.scm" . 96284))
     (push.cons)
     (apply.gloc.of any1 "./boot/eval.scm" . 95244))
   (if.true.ret)
   (touch.gloc.of path-not-found\x60;2)
   (push.iloc.0 . 0)
   (apply.gloc.of path-not-found\x60;2 "./boot/eval.scm" . 98316))
 (set.gloc.of locate-load-file)
 (ret.const.unspec))
((close
   (1 0 . load-file-has-r6rs-comment?)
   (push.const . #f)
   (extend . 1)
   (push.close
     (0 0)
     (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 103431)
     (set.iloc 1 . 0)
     (push.const . #t)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 103431))
   (push.close
     (0 0)
     (call
       (touch.gloc.of open-script-input-port)
       (call
         (touch.gloc.of locate-load-file)
         (push.iloc 2 . 0)
         (apply.gloc.of locate-load-file "./boot/eval.scm" . 103467))
       (push)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 103443))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.const . load)
     (subr.gloc.of core-read 3 "./boot/eval.scm" . 104457)
     (push.iloc.0 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 105481)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (ret.subr.gloc.of not "./boot/eval.scm" . 106505))
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of extend-lexical-syntax "./boot/eval.scm" . 103431))
   (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 103431))
 (set.gloc.of load-file-has-r6rs-comment?)
 (ret.const.unspec))
((close
   (1 0 . load)
   (push.iloc.0 . 0)
   (subr.gloc.of list? 1 "./boot/eval.scm" . 110604)
   (if.true
     (call
       (touch.gloc.of auto-compile-cache-update)
       (apply.gloc.of auto-compile-cache-update "./boot/eval.scm" . 111628))
     (touch.gloc.of load-scheme-library)
     (push.iloc.0 . 0)
     (apply.gloc.of load-scheme-library "./boot/eval.scm" . 112652))
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 114716))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 115731))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 115753))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 116762))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 119834))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 120858)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 121882))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 123930))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 131093)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 131093))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (call
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 132149)
           (if.false.ret)
           (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 132161))
         (push)
         (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 132119)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 133155)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 134176)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 135200))
         (call
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 137248))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 138272))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 131093))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 131093)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 131093))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 127025))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 116750))
 (set.gloc.of load)
 (ret.const.unspec))
((close
   (1 0 . load-r6rs)
   (call
     (touch.gloc.of locate-load-file)
     (push.iloc.0 . 0)
     (apply.gloc.of locate-load-file "./boot/eval.scm" . 142357))
   (push)
   (extend . 1)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 143372))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 143394))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 144403))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (call (push.iloc.0 . 0) (apply.gloc.of serious-condition? "./boot/eval.scm" . 147475))
     (if.true
       (push.iloc.1 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 148499)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/eval.scm" . 149523))
     (push.iloc.0 . 0)
     (apply.gloc.of raise-continuable "./boot/eval.scm" . 151571))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-source-comments 0)
     (push)
     (subr.gloc.of current-environment 0)
     (push)
     (subr.gloc.of extend-lexical-syntax 0)
     (push)
     (subr.gloc.of backtrace 0)
     (push)
     (extend . 8)
     (push.close
       (0 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 0)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 1)
       (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 2)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 158734)
       (set.iloc 1 . 3)
       (push.iloc.1 . 4)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 5)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 6)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 7)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 158734))
     (push.close
       (0 0)
       (call
         (subr.gloc.of backtrace 0 "./boot/eval.scm" . 158764)
         (if.false.ret)
         (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 158776))
       (push)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc 5 . 0)
         (subr.gloc.of current-source-comments 0)
         (push)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 160796)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 161817)
         (if.true
           (push.iloc 6 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 162841)
           (call
             (touch.gloc.of expand-top-level-program)
             (push.iloc.1 . 0)
             (push.subr.gloc.of reverse 1 "./boot/eval.scm" . 163906)
             (push.const)
             (apply.gloc.of expand-top-level-program "./boot/eval.scm" . 163880))
           (push)
           (extend . 1)
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/eval.scm" . 164891))
           (touch.gloc.of interpret)
           (push.iloc.0 . 0)
           (apply.gloc.of interpret "./boot/eval.scm" . 165915))
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (push.cons)
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 167961))
       (push.const)
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 159758))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 1)
       (subr.gloc.of current-environment 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 2)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 158734)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of backtrace "./boot/eval.scm" . 158734))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 154666))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 144391))
 (set.gloc.of load-r6rs)
 (ret.const.unspec))
((close
   (1 0 . load-cache)
   (call
     (call (apply.gloc.of scheme-load-verbose "./boot/eval.scm" . 172042))
     (if.false.ret)
     (push.const . #t)
     (push.const . "~&;; loading ~s~%~!")
     (push.iloc.0 . 0)
     (ret.subr.gloc.of format "./boot/eval.scm" . 172064))
   (call
     (touch.gloc.of open-script-input-port)
     (push.iloc.0 . 0)
     (apply.gloc.of open-script-input-port "./boot/eval.scm" . 173073))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.1 . 0)
     (subr.gloc.of close-port 1 "./boot/eval.scm" . 176138)
     (push.iloc.0 . 0)
     (apply.gloc.of raise "./boot/eval.scm" . 177162))
   (push.close
     (0 0)
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of current-environment 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (subr.gloc.of backtrace 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 0)
       (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 1)
       (subr.gloc.of current-environment 0 "./boot/eval.scm" . 183308)
       (set.iloc 1 . 2)
       (push.const . #f)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 183308)
       (push.const . #f)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 3)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 183308))
     (push.close
       (0 0)
       (extend.enclose+
         (0 0 . loop)
         (push.iloc 5 . 0)
         (push.const . #f)
         (push.const . load)
         (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 184346)
         (extend . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 185367)
         (if.true (push.iloc 6 . 0) (ret.subr.gloc.of close-port "./boot/eval.scm" . 186391))
         (call
           (touch.gloc.of run-vmi)
           (push.const 1 . 0)
           (iloc.0 . 0)
           (push.cons)
           (apply.gloc.of run-vmi "./boot/eval.scm" . 188439))
         (apply.iloc+ (2 . 0) "./boot/eval.scm" . 189463))
       (apply.iloc+ (0 . 0) "./boot/eval.scm" . 183308))
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (subr.gloc.of backtrace 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 1)
       (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 183308)
       (push.iloc.1 . 2)
       (ret.subr.gloc.of current-environment "./boot/eval.scm" . 183308))
     (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 182308))
   (apply.gloc.of with-exception-handler "./boot/eval.scm" . 173061))
 (set.gloc.of load-cache)
 (ret.const.unspec))
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/eval.scm" . 191518))
 (set.gloc.of auto-compile-verbose)
 (ret.const.unspec))
((close
   (1 0)
   (iloc.0 . 0)
   (if.true
     (call
       (push.iloc.0 . 0)
       (subr.gloc.of string? 1 "./boot/eval.scm" . 198674)
       (if.false.ret)
       (push.const . "~//.")
       (push.iloc.0 . 0)
       (push.subr.gloc.of format 2 "./boot/eval.scm" . 198700)
       (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 198686))
     (if.true
       (push.const . "~/")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/eval.scm" . 198720))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const
       .
       "~&;; warning in auto-compile-cache: directory ~s not exist (temporary disable caching)~!~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/eval.scm" . 200717)
     (ret.const . #f))
   (ret.iloc 0 . 0))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.const . #f)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 196612))
 (set.gloc.of auto-compile-cache)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 208949)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 209976)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 210008)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 210005)
   (ret.subr.gloc.of = "./boot/eval.scm" . 209973))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 213057))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 213042)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 214070)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 215078)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 215104))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 216102)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 216132))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 217126))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 217149))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (0 0 . auto-compile-cache-clean)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 205836))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn2.1\x60;2)
     (call
       (touch.gloc.of filter)
       (push.gloc.of \x2E;fn1.1\x60;1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 210986)
       (apply.gloc.of filter "./boot/eval.scm" . 207906))
     (push)
     (apply.gloc.of for-each "./boot/eval.scm" . 207889))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-clean)
 (ret.const.unspec))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (subr.gloc.of string-contains 2 "./boot/eval.scm" . 238645)
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const . ".cache")
   (push.subr.gloc.of string-contains 2 "./boot/eval.scm" . 239672)
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-length 1 "./boot/eval.scm" . 239704)
   (push.const . 6)
   (push.subr.gloc.of - 2 "./boot/eval.scm" . 239701)
   (ret.subr.gloc.of = "./boot/eval.scm" . 239669))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (1 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 228407))
   (push)
   (push.const . "/")
   (push.iloc.0 . 0)
   (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 228392)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . ".time")
   (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 229420)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 230428)
     (if.false.ret)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 230454))
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 231452)
     (if.false.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of delete-file "./boot/eval.scm" . 231482))
   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 232476))
   (if.false.ret)
   (push.const . #t)
   (push.const . "~&;; clean ~s~%")
   (push.iloc.1 . 0)
   (ret.subr.gloc.of format "./boot/eval.scm" . 232499))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (call
     (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 225294))
     (if.false.ret)
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~&;; reset ~s~%")
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 226365))
     (push)
     (ret.subr.gloc.of format "./boot/eval.scm" . 226318))
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/eval.scm" . 224263))
 (set.gloc.of inconsistent-cache-state\x60;2)
 (close
   (0 0 . auto-compile-cache-update)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 235532))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of filter)
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 0)
       (push.subr.gloc.of directory-list 1 "./boot/eval.scm" . 240682)
       (apply.gloc.of filter "./boot/eval.scm" . 237602))
     (push)
     (extend . 1)
     (extend.enclose
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (call
           (iloc.0 . 1)
           (if.false.ret)
           (push.close
             (1 0)
             (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 245839))
             (push)
             (push.const . "/")
             (push.iloc.0 . 0)
             (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 245824)
             (extend . 1)
             (push.iloc.0 . 0)
             (push.const . ".time")
             (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 246852)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 247862)
             (if.true
               (call
                 (touch.gloc.of make-file-input-port)
                 (push.iloc.0 . 0)
                 (apply.gloc.of make-file-input-port "./boot/eval.scm" . 249914))
               (push)
               (push.close
                 (1 0)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 251987)
                 (extend . 1)
                 (push.iloc.1 . 0)
                 (subr.gloc.of close-port 1 "./boot/eval.scm" . 252990)
                 (iloc.0 . 0)
                 (>=.iloc (5 . 1) "./boot/eval.scm" . 254021)
                 (if.true
                   (push.iloc 2 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 255045)
                   (push.iloc 3 . 0)
                   (subr.gloc.of delete-file 1 "./boot/eval.scm" . 256069)
                   (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 257098))
                   (if.false.ret)
                   (push.const . #t)
                   (push.const . "~&;; clean ~s~%")
                   (push.iloc 3 . 0)
                   (ret.subr.gloc.of format "./boot/eval.scm" . 257121))
                 (ret.const.unspec))
               (apply.gloc.of call-with-port "./boot/eval.scm" . 248886))
             (touch.gloc.of inconsistent-cache-state\x60;2)
             (push.iloc 5 . 0)
             (apply.gloc.of inconsistent-cache-state\x60;2 "./boot/eval.scm" . 259126))
           (push.iloc 2 . 0)
           (apply.gloc.of for-each "./boot/eval.scm" . 243740))
         (ret.const.unspec))
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 263230))
       (push)
       (push.const . "/")
       (push.car.iloc (0 . 0) "./boot/eval.scm" . 263255)
       (push.subr.gloc.of string-append 3 "./boot/eval.scm" . 263215)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const . ".time")
       (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 264243)
       (extend . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 265253)
       (if.true
         (call
           (touch.gloc.of make-file-input-port)
           (push.iloc.0 . 0)
           (apply.gloc.of make-file-input-port "./boot/eval.scm" . 267305))
         (push)
         (push.close
           (1 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 269379)
           (extend . 1)
           (push.iloc.1 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 270404)
           (extend . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 271423)
           (extend . 1)
           (push.iloc 3 . 0)
           (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 272451)
           (extend . 1)
           (push.iloc 4 . 0)
           (subr.gloc.of close-port 1 "./boot/eval.scm" . 273453)
           (call
             (push.iloc 3 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 274494)
             (if.false.ret)
             (push.iloc 2 . 0)
             (subr.gloc.of number? 1 "./boot/eval.scm" . 274520)
             (if.false.ret)
             (push.iloc.1 . 0)
             (subr.gloc.of string? 1 "./boot/eval.scm" . 274547)
             (if.false.ret)
             (push.iloc.0 . 0)
             (gloc.of auto-compile-cache-validation-signature)
             (if.not.eq?.ret.const . #f)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of file-exists? "./boot/eval.scm" . 274631))
           (if.true
             (call
               (touch.gloc.of stat-mtime)
               (push.iloc.1 . 0)
               (apply.gloc.of stat-mtime "./boot/eval.scm" . 276535))
             (=.iloc (2 . 0) "./boot/eval.scm" . 276532)
             (if.true
               (push.cdr.iloc (7 . 0) "./boot/eval.scm" . 277562)
               (push.iloc 7 . 1)
               (apply.iloc (8 . 0) "./boot/eval.scm" . 277556))
             (push.cdr.iloc (7 . 0) "./boot/eval.scm" . 279610)
             (call
               (iloc 7 . 1)
               (if.true
                 (iloc 3 . 0)
                 (<.iloc (7 . 1) "./boot/eval.scm" . 281665)
                 (if.true (ret.iloc 3 . 0))
                 (ret.iloc 7 . 1))
               (ret.iloc 3 . 0))
             (push)
             (apply.iloc (8 . 0) "./boot/eval.scm" . 269355))
           (touch.gloc.of inconsistent-cache-state\x60;2)
           (push.iloc 9 . 0)
           (apply.gloc.of inconsistent-cache-state\x60;2 "./boot/eval.scm" . 275508))
         (apply.gloc.of call-with-port "./boot/eval.scm" . 263196))
       (push.iloc.1 . 0)
       (subr.gloc.of delete-file 1 "./boot/eval.scm" . 284709)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 285738))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; clean ~s~%")
         (push.iloc.1 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 285761))
       (push.cdr.iloc (2 . 0) "./boot/eval.scm" . 286763)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "./boot/eval.scm" . 286757))
     (push.iloc.1 . 0)
     (push.const . #f)
     (apply.iloc (0 . 0) "./boot/eval.scm" . 241683))
   (ret.const.unspec))
 (set.gloc.of auto-compile-cache-update)
 (ret.const.unspec))
((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 293918)
     (if.false.ret)
     (touch.gloc.of every1)
     (push.gloc.of string?)
     (push.iloc.0 . 0)
     (apply.gloc.of every1 "./boot/eval.scm" . 293932))
   (if.true (ret.iloc 0 . 0))
   (push.const . library-extensions)
   (push.const . "expected list of strings, but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/eval.scm" . 296002)
   (apply.gloc.of assertion-violation "./boot/eval.scm" . 295961))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (call
   (push.const . ".ypsilon.sls")
   (push.const . ".ypsilon.ss")
   (push.const . ".ypsilon.scm")
   (push.const . ".sls")
   (push.const . ".ss")
   (push.const . ".scm")
   (push.subr.gloc.of list 6 "./boot/eval.scm" . 291859)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of make-parameter "./boot/eval.scm" . 291843))
 (set.gloc.of library-extensions)
 (ret.const.unspec))
((close
   (2 0)
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 356368))
   (if.false.ret)
   (push.const . "~a/~a.cache")
   (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 357432))
   (push)
   (call
     (touch.gloc.of symbol-list->string)
     (push.iloc.0 . 0)
     (push.const . ".")
     (apply.gloc.of symbol-list->string "./boot/eval.scm" . 357453))
   (push)
   (push.subr.gloc.of format 3 "./boot/eval.scm" . 357410)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 358423)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . ".time")
     (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 359469)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 360478)
     (if.false.ret)
     (call
       (touch.gloc.of make-file-input-port)
       (push.iloc.0 . 0)
       (apply.gloc.of make-file-input-port "./boot/eval.scm" . 362530))
     (push)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 364580)
       (push.iloc.0 . 0)
       (subr.gloc.of get-datum 1 "./boot/eval.scm" . 365604)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of get-datum 1 "./boot/eval.scm" . 366655)
       (subr.gloc.of equal? 2 "./boot/eval.scm" . 366635)
       (if.true (ret.iloc 2 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of close-port 1 "./boot/eval.scm" . 368683)
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/eval.scm" . 369707))
       (ret.const . #f))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 360473))
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of locate-cache\x60;4)
 (close
   (4 0)
   (call
     (touch.gloc.of make-file-output-port)
     (push.iloc.0 . 1)
     (apply.gloc.of make-file-output-port "./boot/eval.scm" . 306191))
   (push)
   (push.close
     (1 0)
     (call
       (touch.gloc.of open-script-input-port)
       (push.iloc.1 . 0)
       (apply.gloc.of open-script-input-port "./boot/eval.scm" . 309269))
     (push)
     (push.close
       (1 0)
       (push.close
         (1 0)
         (push.iloc.1 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 313370)
         (push.iloc 2 . 0)
         (subr.gloc.of close-port 1 "./boot/eval.scm" . 314394)
         (call
           (iloc 3 . 1)
           (if.false.ret)
           (push.iloc 3 . 1)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 315427)
           (if.false.ret)
           (push.iloc 3 . 1)
           (ret.subr.gloc.of delete-file "./boot/eval.scm" . 315446))
         (push.iloc.0 . 0)
         (apply.gloc.of raise "./boot/eval.scm" . 316442))
       (push.close
         (0 0)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (push.const . #f)
         (subr.gloc.of current-source-comments 0)
         (push)
         (subr.gloc.of current-environment 0)
         (push)
         (subr.gloc.of extend-lexical-syntax 0)
         (push)
         (subr.gloc.of backtrace 0)
         (push)
         (extend . 8)
         (push.close
           (0 0)
           (subr.gloc.of current-source-comments 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 0)
           (subr.gloc.of current-environment 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 1)
           (subr.gloc.of extend-lexical-syntax 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 2)
           (subr.gloc.of backtrace 0 "./boot/eval.scm" . 323612)
           (set.iloc 1 . 3)
           (push.iloc.1 . 4)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 5)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 6)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 7)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 323612))
         (push.close
           (0 0)
           (extend.enclose+
             (0 0 . loop)
             (call
               (subr.gloc.of backtrace 0 "./boot/eval.scm" . 324668)
               (if.false.ret)
               (ret.subr.gloc.of make-core-hashtable "./boot/eval.scm" . 324680))
             (push)
             (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 324638)
             (push.iloc 5 . 0)
             (subr.gloc.of current-source-comments 0)
             (push)
             (push.const . load)
             (push.subr.gloc.of core-read 3 "./boot/eval.scm" . 325673)
             (extend . 1)
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/eval.scm" . 326695)
             (if.true
               (push.iloc 7 . 0)
               (push.const . "~%")
               (subr.gloc.of format 2 "./boot/eval.scm" . 327719)
               (push.iloc 6 . 0)
               (subr.gloc.of close-port 1 "./boot/eval.scm" . 328743)
               (push.iloc 7 . 0)
               (ret.subr.gloc.of close-port "./boot/eval.scm" . 329767))
             (call
               (push.const . #f)
               (subr.gloc.of make-core-hashtable 0)
               (push)
               (extend . 2)
               (push.close
                 (0 0)
                 (call
                   (touch.gloc.of current-closure-comments)
                   (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
                 (set.iloc 1 . 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 1)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
               (push.close
                 (0 0)
                 (call (push.iloc 2 . 0) (apply.gloc.of macro-expand "./boot/eval.scm" . 334914))
                 (push)
                 (apply.gloc.of compile-coreform "./boot/eval.scm" . 334896))
               (push.close
                 (0 0)
                 (touch.gloc.of current-closure-comments)
                 (push.iloc.1 . 0)
                 (apply.gloc.of current-closure-comments "./boot/eval.scm" . 334896))
               (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 334896))
             (push)
             (extend . 1)
             (push.iloc 8 . 0)
             (push.iloc.0 . 0)
             (subr.gloc.of put-fasl 2 "./boot/eval.scm" . 335913)
             (push.iloc 8 . 0)
             (push.const . "~%")
             (subr.gloc.of format 2 "./boot/eval.scm" . 336937)
             (call
               (touch.gloc.of run-vmi)
               (push.const 1 . 0)
               (iloc.0 . 0)
               (push.cons)
               (apply.gloc.of run-vmi "./boot/eval.scm" . 337961))
             (apply.iloc+ (3 . 0) "./boot/eval.scm" . 338985))
           (apply.iloc+ (0 . 0) "./boot/eval.scm" . 323612))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (subr.gloc.of current-source-comments 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 1)
           (subr.gloc.of current-environment 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 2)
           (subr.gloc.of extend-lexical-syntax 1 "./boot/eval.scm" . 323612)
           (push.iloc.1 . 3)
           (ret.subr.gloc.of backtrace "./boot/eval.scm" . 323612))
         (apply.gloc.of \x2E;dynamic-wind "./boot/eval.scm" . 319544))
       (apply.gloc.of with-exception-handler "./boot/eval.scm" . 310293))
     (apply.gloc.of call-with-port "./boot/eval.scm" . 307215))
   (apply.gloc.of call-with-port "./boot/eval.scm" . 304137))
 (set.gloc.of make-cache\x60;4)
 (close
   (1 1 . load-scheme-library)
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #t)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of car "./boot/eval.scm" . 301098))
   (push)
   (extend . 1)
   (extend.enclose
     (1 0)
     (call
       (touch.gloc.of symbol-list->string)
       (push.iloc.0 . 0)
       (push.const . "/")
       (apply.gloc.of symbol-list->string "./boot/eval.scm" . 343063))
     (push)
     (extend . 1)
     (call
       (touch.gloc.of any1)
       (push.close
         (1 0)
         (touch.gloc.of any1)
         (push.close
           (1 0)
           (push.const . "~a/~a~a")
           (push.iloc.1 . 0)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 4 "./boot/eval.scm" . 346163)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of file-exists? 1 "./boot/eval.scm" . 347176)
           (if.false.ret)
           (ret.iloc 0 . 0))
         (call (apply.gloc.of library-extensions "./boot/eval.scm" . 348191))
         (push)
         (apply.gloc.of any1 "./boot/eval.scm" . 345113))
       (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 349207))
       (push)
       (apply.gloc.of any1 "./boot/eval.scm" . 344081))
     (if.true.ret)
     (iloc 3 . 0)
     (if.false.ret)
     (push.const . load-scheme-library)
     (push.const . "~s not found in scheme-library-paths: ~s")
     (push.iloc.0 . 0)
     (call (apply.gloc.of scheme-library-paths "./boot/eval.scm" . 351338))
     (push)
     (push.subr.gloc.of format 3 "./boot/eval.scm" . 351282)
     (apply.gloc.of error "./boot/eval.scm" . 351254))
   (call
     (push.iloc 2 . 0)
     (subr.gloc.of list? 1 "./boot/eval.scm" . 373771)
     (if.true.ret)
     (push.const . "internal error in load-scheme-library: unrecognized argument: ~s")
     (push.iloc 2 . 0)
     (apply.gloc.of scheme-error "./boot/eval.scm" . 374795))
   (call (push.iloc 2 . 0) (apply.iloc (0 . 0) "./boot/eval.scm" . 376846))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 378903))
     (if.true
       (call
         (touch.gloc.of locate-cache\x60;4)
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of locate-cache\x60;4 "./boot/eval.scm" . 379945))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (touch.gloc.of load-cache)
         (push.iloc.0 . 0)
         (apply.gloc.of load-cache "./boot/eval.scm" . 381981))
       (push.const . "~a/~a.cache")
       (call (apply.gloc.of auto-compile-cache "./boot/eval.scm" . 383045))
       (push)
       (call
         (touch.gloc.of symbol-list->string)
         (push.iloc 4 . 0)
         (push.const . ".")
         (apply.gloc.of symbol-list->string "./boot/eval.scm" . 383066))
       (push)
       (push.subr.gloc.of format 3 "./boot/eval.scm" . 383023)
       (extend . 1)
       (call
         (call (apply.gloc.of auto-compile-verbose "./boot/eval.scm" . 384036))
         (if.false.ret)
         (push.const . #t)
         (push.const . "~&;; compile ~s~%~!")
         (push.iloc 2 . 0)
         (ret.subr.gloc.of format "./boot/eval.scm" . 384059))
       (call
         (touch.gloc.of make-cache\x60;4)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 2 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 385094))
         (push)
         (apply.gloc.of make-cache\x60;4 "./boot/eval.scm" . 385055))
       (call
         (touch.gloc.of make-file-output-port)
         (push.iloc.0 . 0)
         (push.const . ".time")
         (push.subr.gloc.of string-append 2 "./boot/eval.scm" . 386101)
         (apply.gloc.of make-file-output-port "./boot/eval.scm" . 388133))
       (push)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.const . "~s ~s ~s ~s")
         (subr.gloc.of microsecond 0)
         (push)
         (call
           (touch.gloc.of stat-mtime)
           (push.iloc 3 . 0)
           (apply.gloc.of stat-mtime "./boot/eval.scm" . 389217))
         (push)
         (push.iloc 3 . 0)
         (push.gloc.of auto-compile-cache-validation-signature)
         (ret.subr.gloc.of format "./boot/eval.scm" . 389174))
       (apply.gloc.of call-with-port "./boot/eval.scm" . 387105))
     (push.iloc.0 . 0)
     (apply.gloc.of load "./boot/eval.scm" . 390167))
   (ret.const.unspec))
 (set.gloc.of load-scheme-library)
 (ret.const.unspec))

;
((call (push.const . #f) (apply.gloc.of make-parameter "./boot/interaction.scm" . 5144))
 (set.gloc.of dump-condition)
 (ret.const.unspec))
((close
   (1 0 . add-load-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 9228)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 10256)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 11292))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 12323))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 12310)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13364))
       (push.cons)
       (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 13334))
     (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 14348))
   (push.const . add-load-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 16432)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 16396))
 (set.gloc.of add-load-path)
 (ret.const.unspec))
((close
   (1 0 . add-library-path)
   (push.iloc.0 . 0)
   (subr.gloc.of string? 1 "./boot/interaction.scm" . 20492)
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 21520)
       (if.true.ret)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 22556))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 23587))
       (push)
       (subr.gloc.of member 2 "./boot/interaction.scm" . 23574)
       (if.true.ret)
       (push.iloc.0 . 0)
       (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24631))
       (push.cons)
       (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 24598))
     (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 25612))
   (push.const . add-library-path)
   (push.const . "expected string but got ~s")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 27699)
   (apply.gloc.of assertion-violation "./boot/interaction.scm" . 27660))
 (set.gloc.of add-library-path)
 (ret.const.unspec))
((close
   (0 0 . home-directory)
   (push.const . "~/")
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 33831)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 33814)
     (if.true
       (call
         (push.const . "HOMEDRIVE")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 34857)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (call
         (push.const . "HOMEPATH")
         (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 35881)
         (if.true.ret)
         (ret.const . ""))
       (push)
       (ret.subr.gloc.of string-append "./boot/interaction.scm" . 34838))
     (push.const . "HOME")
     (ret.subr.gloc.of lookup-process-environment "./boot/interaction.scm" . 36886))
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 31761)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of file-exists? 1 "./boot/interaction.scm" . 37900)
   (if.false.ret)
   (ret.iloc 0 . 0))
 (set.gloc.of home-directory)
 (ret.const.unspec))
((close
   (1 1 . apply-scheme-proc-assistant)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (push.close
     (0 0)
     (iloc.1 . 0)
     (if.false.ret)
     (push.const . apply-scheme-proc-assistant)
     (push.const . "scheme continuation interleave with c/c++ continuation")
     (apply.gloc.of assertion-violation "./boot/interaction.scm" . 45076))
   (push.close
     (0 0)
     (push.close
       (1 0)
       (const . #t)
       (set.iloc 2 . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of raise "./boot/interaction.scm" . 50189))
     (push.close
       (0 0)
       (call
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of apply "./boot/interaction.scm" . 52248))
       (push)
       (extend . 1)
       (const . #t)
       (set.iloc 3 . 0)
       (ret.iloc 0 . 0))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 47114))
   (push.close
     (0 0)
     (iloc.1 . 1)
     (if.false.ret)
     (touch.gloc.of escape)
     (apply.gloc.of escape "./boot/interaction.scm" . 54293))
   (apply.gloc.of dynamic-wind "./boot/interaction.scm" . 43015))
 (set.gloc.of apply-scheme-proc-assistant)
 (ret.const.unspec))
((close
   (0 0 . nonblock-skip-whitespace)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of nonblock-byte-ready? 1 "./boot/interaction.scm" . 58378)
   (if.false.ret)
   (call
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of lookahead-char 1 "./boot/interaction.scm" . 59412)
     (extend . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 60438)
     (if.true.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of char-whitespace? "./boot/interaction.scm" . 61457))
   (if.false.ret)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of get-char 1 "./boot/interaction.scm" . 62474)
   (if.false.ret)
   (touch.gloc.of nonblock-skip-whitespace)
   (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 63498))
 (set.gloc.of nonblock-skip-whitespace)
 (ret.const.unspec))
((close
   (0 0 . read-eval-print-loop)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 67608)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 67655)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 67650)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 67645))
   (push)
   (extend . 1)
   (extend.enclose
     (0 0 . loop)
     (call
       (push.close
         (1 0)
         (push.close
           (1 0)
           (subr.gloc.of current-output-port 0)
           (push)
           (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 73743)
           (touch.gloc.of default-exception-handler)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 74767))
         (push.close
           (0 0)
           (call
             (touch.gloc.of nonblock-skip-whitespace)
             (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 76815))
           (call
             (subr.gloc.of current-environment 0)
             (push)
             (subr.gloc.of interaction-environment 0 "./boot/interaction.scm" . 77870)
             (if.eq?
               (push.const . #t)
               (push.const . "~&> ~!")
               (ret.subr.gloc.of format "./boot/interaction.scm" . 78867))
             (push.const . #t)
             (push.const . "~&~a: ~!")
             (subr.gloc.of current-environment 0)
             (push)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 79891))
           (call
             (touch.gloc.of current-macro-expression)
             (push.const . #f)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 80911))
           (subr.gloc.of make-core-hashtable 0)
           (push)
           (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 81935)
           (call
             (touch.gloc.of set-port-current-line!)
             (subr.gloc.of current-input-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-line! "./boot/interaction.scm" . 82959))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-output-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 83983))
           (call
             (touch.gloc.of set-port-current-column!)
             (subr.gloc.of current-error-port 0)
             (push)
             (push.const . 1)
             (apply.gloc.of set-port-current-column! "./boot/interaction.scm" . 85007))
           (subr.gloc.of current-input-port 0)
           (push)
           (subr.gloc.of current-source-comments 0)
           (push)
           (push.const . read)
           (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 86043)
           (extend . 1)
           (call
             (push.iloc.0 . 0)
             (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 87062)
             (if.false.ret)
             (push.const . 0)
             (ret.subr.gloc.of exit "./boot/interaction.scm" . 87081))
           (call
             (iloc 5 . 0)
             (if.false.ret)
             (push.const . #t)
             (push.const . "~%~!")
             (ret.subr.gloc.of format "./boot/interaction.scm" . 88094))
           (call
             (touch.gloc.of interpret)
             (push.iloc.0 . 0)
             (apply.gloc.of interpret "./boot/interaction.scm" . 89116))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (subr.gloc.of unspecified? 1 "./boot/interaction.scm" . 90138)
           (if.true.ret)
           (call (push.iloc.0 . 0) (apply.gloc.of pretty-print "./boot/interaction.scm" . 92186))
           (subr.gloc.of current-output-port 0)
           (push)
           (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 93210))
         (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 71692))
       (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 69641))
     (apply.iloc (1 . 0) "./boot/interaction.scm" . 94217))
   (apply.iloc (0 . 0) "./boot/interaction.scm" . 68615))
 (set.gloc.of read-eval-print-loop)
 (ret.const.unspec))
((close
   (0 0)
   (call
     (touch.gloc.of nonblock-skip-whitespace)
     (apply.gloc.of nonblock-skip-whitespace "./boot/interaction.scm" . 106509))
   (call
     (touch.gloc.of current-macro-expression)
     (push.const . #f)
     (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 107533))
   (subr.gloc.of make-core-hashtable 0)
   (push)
   (subr.gloc.of current-source-comments 1 "./boot/interaction.scm" . 108557)
   (subr.gloc.of current-input-port 0)
   (push)
   (subr.gloc.of current-source-comments 0)
   (push)
   (push.const . read)
   (push.subr.gloc.of core-read 3 "./boot/interaction.scm" . 109593)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of eof-object? 1 "./boot/interaction.scm" . 110614)
   (if.true (push.const . 0) (ret.subr.gloc.of exit "./boot/interaction.scm" . 110633))
   (call
     (touch.gloc.of interpret)
     (push.iloc.0 . 0)
     (apply.gloc.of interpret "./boot/interaction.scm" . 112662))
   (subr.gloc.of current-output-port 0)
   (push)
   (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 113686))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 103437)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of \x2E;fn4.1\x60;4)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 104461))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (0 0 . loop)
   (call
     (push.gloc.of \x2E;fn5.1\x60;5)
     (apply.gloc.of call-with-current-continuation "./boot/interaction.scm" . 98309))
   (touch.gloc.of loop\x60;4)
   (apply.gloc.of loop\x60;4 "./boot/interaction.scm" . 114695))
 (set.gloc.of loop\x60;4)
 (close
   (1 0)
   (push.gloc.of \x2E;fn3.1\x60;3)
   (push.gloc.of \x2E;fn1.1\x60;1)
   (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 100360))
 (set.gloc.of \x2E;fn5.1\x60;5)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 104501))
 (set.gloc.of \x2E;fn4.1\x60;4)
 (close
   (0 0 . quiet-read-eval-print-loop)
   (touch.gloc.of loop\x60;4)
   (apply.gloc.of loop\x60;4 "./boot/interaction.scm" . 98309))
 (set.gloc.of quiet-read-eval-print-loop)
 (ret.const.unspec))
((call
   (push.const
     (\x2E;LIST . \x2E;list)
     (\x2E;CONS . \x2E;cons)
     (\x2E;CONS* . \x2E;cons*)
     (\x2E;APPEND . \x2E;append)
     (\x2E;VECTOR . \x2E;vector)
     (\x2E;LIST->VECTOR . \x2E;list->vector)
     (\x2E;EQ? . \x2E;eq?)
     (\x2E;EQV? . \x2E;eqv?)
     (\x2E;MEMQ . \x2E;memq)
     (\x2E;MEMV . \x2E;memv)
     (\x2E;CALL-WITH-VALUES . \x2E;call-with-values)
     (\x2E;APPLY . \x2E;apply)
     (\x2E;CDR . \x2E;cdr)
     (\x2E;IDENTIFIER? . \x2E;identifier?)
     (\x2E;MAKE-VARIABLE-TRANSFORMER . \x2E;make-variable-transformer)
     (\x2E;ASSERTION-VIOLATION . \x2E;assertion-violation)
     (\x2E;UNSPECIFIED . \x2E;unspecified)
     (\x2E;QUOTE . quote)
     (\x2E;LET . let)
     (\x2E;LETREC* . letrec*)
     (\x2E;BEGIN . begin)
     (\x2E;LAMBDA . lambda)
     (\x2E;IF . if)
     (\x2E;SET! . set!)
     (\x2E;OR . or)
     (\x2E;COND . cond)
     (\x2E;ELSE . else)
     (\x2E;DEFINE-SYNTAX . define-syntax)
     (\x2E;SYNTAX . syntax)
     (\x2E;SYNTAX-CASE . syntax-case))
   (extend . 1)
   (ret.close
     (1 0 . unrename-private-primitives)
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "./boot/interaction.scm" . 151580)
           (apply.iloc (1 . 0) "./boot/interaction.scm" . 151574))
         (push)
         (call
           (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 151597)
           (apply.iloc (1 . 0) "./boot/interaction.scm" . 151591))
         (ret.cons "./boot/interaction.scm" . 151568))
       (iloc.0 . 0)
       (if.symbol?
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (push.subr.gloc.of assq 2 "./boot/interaction.scm" . 153623)
         (extend . 1)
         (iloc.0 . 0)
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of cdr "./boot/interaction.scm" . 153616))
         (ret.iloc 1 . 0))
       (push.iloc.0 . 0)
       (subr.gloc.of vector? 1 "./boot/interaction.scm" . 155664)
       (if.true
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.subr.gloc.of vector->list 1 "./boot/interaction.scm" . 156712)
           (apply.gloc.of map "./boot/interaction.scm" . 156702))
         (push)
         (ret.subr.gloc.of list->vector "./boot/interaction.scm" . 156688))
       (ret.iloc 0 . 0))
     (push.iloc.1 . 0)
     (apply.iloc (0 . 0) "./boot/interaction.scm" . 149511)))
 (set.gloc.of unrename-private-primitives)
 (ret.const.unspec))
((close
   (3 0 . display-warning)
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . "~a")
   (push.iloc.1 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 162823)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (subr.gloc.of backtrace-line-length 0)
   (push)
   (extend . 5)
   (push.close
     (0 0)
     (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 167945))
     (set.iloc 1 . 0)
     (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 167945))
     (set.iloc 1 . 1)
     (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 167945))
     (set.iloc 1 . 2)
     (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 167945))
     (set.iloc 1 . 3)
     (call
       (push.iloc.1 . 4)
       (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 167945))
     (call
       (push.const . 10)
       (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 167945))
     (call
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 167945))
     (push.const . 5)
     (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 167945))
   (push.close
     (0 0)
     (call
       (iloc 3 . 1)
       (if.true
         (push.iloc 2 . 0)
         (push.const . "~%  >  ")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 168976)
         (call
           (call
             (touch.gloc.of unrename-private-primitives)
             (push.iloc 3 . 1)
             (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 170014))
           (push)
           (push.iloc 2 . 0)
           (apply.gloc.of pretty-print "./boot/interaction.scm" . 170000))
         (iloc 3 . 1)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (push.const . "~%  ~n")
         (push.iloc 3 . 1)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 171042))
       (ret.const.unspec))
     (call
       (iloc 3 . 2)
       (if.true
         (push.iloc 2 . 0)
         (push.const . "~%  >  ")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 173072)
         (call
           (call
             (touch.gloc.of unrename-private-primitives)
             (push.iloc 3 . 2)
             (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 174110))
           (push)
           (push.iloc 2 . 0)
           (apply.gloc.of pretty-print "./boot/interaction.scm" . 174096))
         (iloc 3 . 2)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (push.const . "~%  ~n")
         (push.iloc 3 . 2)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 175141))
       (ret.const.unspec))
     (push.iloc 2 . 0)
     (push.const . "~%")
     (subr.gloc.of format 2 "./boot/interaction.scm" . 176137)
     (call
       (push.const . "EMACS")
       (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 177180)
       (if.true.ret)
       (subr.gloc.of current-input-port 0)
       (push)
       (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 177227)
       (push.const . char)
       (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 177222)
       (ret.subr.gloc.of not "./boot/interaction.scm" . 177217))
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc 2 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 179251)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 179215))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc 2 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 180277)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 180239))
   (push.close
     (0 0)
     (call
       (push.iloc.1 . 0)
       (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 167945))
     (call
       (push.iloc.1 . 1)
       (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 167945))
     (call
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 167945))
     (push.iloc.1 . 3)
     (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 167945))
   (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 163888))
 (set.gloc.of display-warning)
 (ret.const.unspec))
((close
   (1 0)
   (push.const . "~r")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 206920))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0 . default-exception-handler)
   (call
     (touch.gloc.of current-exception-handler)
     (push.const . #f)
     (apply.gloc.of current-exception-handler "./boot/interaction.scm" . 184325))
   (subr.gloc.of make-string-output-port 0)
   (push)
   (extend . 1)
   (call
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (subr.gloc.of backtrace-line-length 0)
     (push)
     (extend . 4)
     (push.close
       (0 0)
       (call (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 190473))
       (set.iloc 1 . 0)
       (call (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 190473))
       (set.iloc 1 . 1)
       (call (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 190473))
       (set.iloc 1 . 2)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 190473))
       (call
         (push.const . 10)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 190473))
       (push.const . #t)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 190473))
     (push.close
       (0 0)
       (extend.unbound . 4)
       (push.close
         (0 0)
         (push.iloc 4 . 0)
         (push.const . "error")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 192525)
         (call
           (call (push.iloc 5 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 193554))
           (if.false.ret)
           (push.iloc 4 . 0)
           (push.const . " in ~u")
           (call (push.iloc 5 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 194600))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 194578))
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of message-condition? "./boot/interaction.scm" . 195602))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . ": ~a")
         (call
           (push.iloc 5 . 0)
           (apply.gloc.of condition-message "./boot/interaction.scm" . 196646))
         (push)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 196626))
       (push.close
         (0 0)
         (call
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of irritants-condition? "./boot/interaction.scm" . 200729))
           (if.false.ret)
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 200769))
           (ret.pair? "./boot/interaction.scm" . 200762))
         (if.true
           (push.iloc 4 . 0)
           (push.const . "~%~%irritants:")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 201748)
           (push.close
             (1 0)
             (push.iloc 5 . 0)
             (push.const . "~% ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 203808)
             (push.iloc.0 . 0)
             (subr.gloc.of list? 1 "./boot/interaction.scm" . 204839)
             (if.true
               (push.iloc 5 . 0)
               (push.const . " (")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 205863)
               (extend.enclose+
                 (1 0 . loop)
                 (iloc.0 . 0)
                 (if.pair?
                   (push.iloc 7 . 0)
                   (push.const . "~a")
                   (push.car.iloc (0 . 0) "./boot/interaction.scm" . 208962)
                   (subr.gloc.of format 3 "./boot/interaction.scm" . 208944)
                   (cdr.iloc (0 . 0) "./boot/interaction.scm" . 209982)
                   (if.pair?
                     (push.iloc 7 . 0)
                     (push.const . " ")
                     (subr.gloc.of format 2 "./boot/interaction.scm" . 210999)
                     (push.cdr.iloc (0 . 0) "./boot/interaction.scm" . 212029)
                     (apply.iloc+ (1 . 0) "./boot/interaction.scm" . 212023))
                   (push.iloc 7 . 0)
                   (push.const . ")")
                   (ret.subr.gloc.of format "./boot/interaction.scm" . 214071))
                 (ret.const.unspec))
               (call
                 (push.gloc.of \x2E;fn2.1\x60;2)
                 (push.iloc.1 . 0)
                 (apply.gloc.of map "./boot/interaction.scm" . 206903))
               (push)
               (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 206887))
             (push.iloc 5 . 0)
             (push.const . " ~r")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 215084))
           (call
             (push.iloc 5 . 0)
             (apply.gloc.of condition-irritants "./boot/interaction.scm" . 216094))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 200717))
         (ret.const.unspec))
       (push.close
         (0 0)
         (call (apply.gloc.of expansion-backtrace "./boot/interaction.scm" . 220178))
         (if.false.ret)
         (call
           (touch.gloc.of current-macro-expression)
           (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 221202))
         (if.false.ret)
         (push.const . #f)
         (extend . 1)
         (push.close
           (0 0)
           (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223252))
           (set.iloc 1 . 0)
           (push.const . 7)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223252))
         (push.close
           (0 0)
           (push.iloc 6 . 0)
           (push.const . "~%~%expanding:~%  >  ")
           (subr.gloc.of format 2 "./boot/interaction.scm" . 223252)
           (call
             (call
               (touch.gloc.of unrename-private-primitives)
               (call
                 (touch.gloc.of current-macro-expression)
                 (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 224319))
               (push)
               (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 224290))
             (push)
             (push.iloc 6 . 0)
             (apply.gloc.of pretty-print "./boot/interaction.scm" . 224276))
           (push.iloc 6 . 0)
           (push.const . "~%  ~n")
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 225322))
           (push)
           (subr.gloc.of format 3 "./boot/interaction.scm" . 225300)
           (push.close
             (1 0)
             (push.iloc 7 . 0)
             (push.const . "~%  *  ")
             (subr.gloc.of format 2 "./boot/interaction.scm" . 227360)
             (call
               (call
                 (touch.gloc.of unrename-private-primitives)
                 (push.iloc.0 . 0)
                 (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 228398))
               (push)
               (push.iloc 7 . 0)
               (apply.gloc.of pretty-print "./boot/interaction.scm" . 228384))
             (push.iloc 7 . 0)
             (push.const . "~%  ~n")
             (push.iloc.0 . 0)
             (ret.subr.gloc.of format "./boot/interaction.scm" . 229408))
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 230430))
           (push)
           (apply.gloc.of for-each "./boot/interaction.scm" . 226324))
         (push.close
           (0 0)
           (push.iloc.1 . 0)
           (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 223252))
         (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 223252))
       (push.close
         (1 0)
         (call
           (touch.gloc.of dump-condition)
           (apply.gloc.of dump-condition "./boot/interaction.scm" . 234514))
         (if.false.ret)
         (push.iloc 4 . 0)
         (push.const . "~%~%")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 235538)
         (if.false.ret)
         (touch.gloc.of describe-condition)
         (push.iloc 4 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of describe-condition "./boot/interaction.scm" . 236562))
       (enclose . 4)
       (call (push.iloc 4 . 0) (apply.gloc.of syntax-violation? "./boot/interaction.scm" . 238608))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 239632))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 240663))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 243742))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 243742))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  >  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 243742)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 244780))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 244766))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 245808))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 243742))
             (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 243742))
           (ret.const.unspec))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 246807))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.const . #f)
             (extend . 1)
             (push.close
               (0 0)
               (call (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 249886))
               (set.iloc 1 . 0)
               (push.const . 5)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 249886))
             (push.close
               (0 0)
               (push.iloc 6 . 0)
               (push.const . "~%  @  ")
               (subr.gloc.of format 2 "./boot/interaction.scm" . 249886)
               (call
                 (call
                   (touch.gloc.of unrename-private-primitives)
                   (push.iloc 2 . 0)
                   (apply.gloc.of unrename-private-primitives "./boot/interaction.scm" . 250924))
                 (push)
                 (push.iloc 6 . 0)
                 (apply.gloc.of pretty-print "./boot/interaction.scm" . 250910))
               (iloc 2 . 0)
               (if.not.pair?.ret.const . #f)
               (push.iloc 6 . 0)
               (push.const . "~%  ~n")
               (push.iloc 2 . 0)
               (ret.subr.gloc.of format "./boot/interaction.scm" . 251952))
             (push.close
               (0 0)
               (push.iloc.1 . 0)
               (apply.gloc.of pretty-print-initial-indent "./boot/interaction.scm" . 249886))
             (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 249886))
           (ret.const.unspec))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 252944))
         (call
           (call
             (touch.gloc.of expansion-trace-stack)
             (apply.gloc.of expansion-trace-stack "./boot/interaction.scm" . 253984))
           (if.not.null?.ret.const . #f)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 255010))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-form "./boot/interaction.scm" . 255037))
           (if.eq?.ret.const . #t)
           (call
             (touch.gloc.of current-macro-expression)
             (apply.gloc.of current-macro-expression "./boot/interaction.scm" . 256034))
           (push)
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of syntax-violation-subform "./boot/interaction.scm" . 256061))
           (ret.eq? "./boot/interaction.scm" . 256029))
         (if.true.ret)
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 257044))
       (call
         (push.iloc 4 . 0)
         (apply.gloc.of undefined-violation? "./boot/interaction.scm" . 259088))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unbound variable")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 260112)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 261141))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " ~u")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 262184))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 262165))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 263189))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ", ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 264233))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 264213))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 265232))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 266256))
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 267280))
       (call (push.iloc 4 . 0) (apply.gloc.of error? "./boot/interaction.scm" . 269328))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 270352))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 271376))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 272400))
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 273424))
       (call (push.iloc 4 . 0) (apply.gloc.of violation? "./boot/interaction.scm" . 275472))
       (if.true
         (call (apply.iloc (0 . 0) "./boot/interaction.scm" . 276496))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 277520))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 278544))
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 279568))
       (call (push.iloc 4 . 0) (apply.gloc.of warning? "./boot/interaction.scm" . 281616))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "warning")
         (subr.gloc.of format 2 "./boot/interaction.scm" . 282640)
         (call
           (call (push.iloc 4 . 0) (apply.gloc.of who-condition? "./boot/interaction.scm" . 283669))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . " in ~u")
           (call (push.iloc 4 . 0) (apply.gloc.of condition-who "./boot/interaction.scm" . 284715))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 284693))
         (call
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of message-condition? "./boot/interaction.scm" . 285717))
           (if.false.ret)
           (push.iloc 3 . 0)
           (push.const . ": ~a")
           (call
             (push.iloc 4 . 0)
             (apply.gloc.of condition-message "./boot/interaction.scm" . 286761))
           (push)
           (ret.subr.gloc.of format "./boot/interaction.scm" . 286741))
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 287760))
         (call (push.iloc 4 . 0) (apply.iloc (0 . 3) "./boot/interaction.scm" . 288784))
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 289808))
       (call (push.iloc 4 . 0) (apply.gloc.of condition? "./boot/interaction.scm" . 291856))
       (if.true
         (push.iloc 3 . 0)
         (push.const . "error: unknown type of exception caught~%~%irritants:~%~a")
         (call
           (touch.gloc.of describe-condition)
           (push.const . #f)
           (push.iloc 4 . 0)
           (apply.gloc.of describe-condition "./boot/interaction.scm" . 292953))
         (push)
         (subr.gloc.of format 3 "./boot/interaction.scm" . 292880)
         (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 293904))
         (apply.iloc (0 . 2) "./boot/interaction.scm" . 294928))
       (push.iloc 3 . 0)
       (push.const . "error: unknown type of exception caught, ~a")
       (push.iloc 4 . 0)
       (subr.gloc.of format 3 "./boot/interaction.scm" . 298000)
       (call (apply.iloc (0 . 1) "./boot/interaction.scm" . 299024))
       (apply.iloc (0 . 2) "./boot/interaction.scm" . 300048))
     (push.close
       (0 0)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of pretty-print-line-length "./boot/interaction.scm" . 190473))
       (call
         (push.iloc.1 . 1)
         (apply.gloc.of pretty-print-maximum-lines "./boot/interaction.scm" . 190473))
       (push.iloc.1 . 2)
       (apply.gloc.of pretty-print-unwrap-syntax "./boot/interaction.scm" . 190473))
     (apply.gloc.of \x2E;dynamic-wind "./boot/interaction.scm" . 186416))
   (push.iloc.0 . 0)
   (push.const . "~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 302087)
   (call
     (push.const . "EMACS")
     (subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 303130)
     (if.true.ret)
     (subr.gloc.of current-input-port 0)
     (push)
     (push.subr.gloc.of port-device-subtype 1 "./boot/interaction.scm" . 303177)
     (push.const . char)
     (push.subr.gloc.of eq? 2 "./boot/interaction.scm" . 303172)
     (ret.subr.gloc.of not "./boot/interaction.scm" . 303167))
   (push)
   (extend . 1)
   (call (push.iloc 2 . 0) (apply.gloc.of serious-condition? "./boot/interaction.scm" . 304144))
   (if.true
     (push.iloc.1 . 0)
     (subr.gloc.of display-backtrace 1 "./boot/interaction.scm" . 305168)
     (call
       (iloc.0 . 0)
       (if.true
         (subr.gloc.of current-error-port 0)
         (push)
         (push.const . "~a~!")
         (push.iloc.1 . 0)
         (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 307256)
         (ret.subr.gloc.of format "./boot/interaction.scm" . 307220))
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~%~a~%~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 308284)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 308244))
     (push.const . 10000)
     (subr.gloc.of usleep 1 "./boot/interaction.scm" . 309264)
     (iloc 2 . 1)
     (if.false.ret)
     (apply.iloc (2 . 1) "./boot/interaction.scm" . 310302))
   (call
     (iloc.0 . 0)
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "~a~!")
       (push.iloc.1 . 0)
       (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 313400)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 313364))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "~%~a~!")
     (push.iloc.1 . 0)
     (push.subr.gloc.of extract-accumulated-string 1 "./boot/interaction.scm" . 314426)
     (ret.subr.gloc.of format "./boot/interaction.scm" . 314388))
   (push.const . 10000)
   (ret.subr.gloc.of usleep "./boot/interaction.scm" . 315408))
 (set.gloc.of default-exception-handler)
 (ret.const.unspec))
((close
   (1 0)
   (push.close
     (1 0)
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 397359))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 397340))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 398379))
       (push)
       (apply.gloc.of add-load-path "./boot/interaction.scm" . 398364))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '--loadpath=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 400412)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 401436))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 402481)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 402464)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 403488))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 404512))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 402451)
   (apply.gloc.of for-each "./boot/interaction.scm" . 395271))
 (set.gloc.of add-opt-loadpath\x60;2)
 (close (0 0) (push.const . #f) (ret.subr.gloc.of exit "./boot/interaction.scm" . 480317))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (0 0)
   (push.const . "YPSILON_SITELIB")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 355344)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn13.1\x60;13)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 363572)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 363555)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 364579))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 365603))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 363542)
     (apply.gloc.of for-each "./boot/interaction.scm" . 355337))
   (ret.const.unspec))
 (set.gloc.of init-env-sitelib\x60;2)
 (close
   (0 0)
   (push.const . "~a/sitelib")
   (subr.gloc.of system-share-path 0)
   (push)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 326677)
   (extend . 1)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (push.iloc.0 . 0)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 327696))
   (if.false.ret)
   (push.iloc.0 . 0)
   (apply.gloc.of add-library-path "./boot/interaction.scm" . 327721))
 (set.gloc.of init-sys-sitelib\x60;2)
 (close
   (1 0)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 359474))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 359455))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 360497))
     (push)
     (apply.gloc.of add-library-path "./boot/interaction.scm" . 360479))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_SITELIB': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 362527))
 (set.gloc.of \x2E;fn13.1\x60;13)
 (close
   (0 0)
   (push.const . "YPSILON_LOADPATH")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 369680)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.gloc.of \x2E;fn6.1\x60;6)
     (call
       (push.const . operating-system)
       (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 377908)
       (push.const . "windows")
       (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 377891)
       (if.true
         (touch.gloc.of string-split)
         (push.iloc.0 . 0)
         (push.const . #\;)
         (apply.gloc.of string-split "./boot/interaction.scm" . 378915))
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\:)
       (apply.gloc.of string-split "./boot/interaction.scm" . 379939))
     (push)
     (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 377878)
     (apply.gloc.of for-each "./boot/interaction.scm" . 369673))
   (ret.const.unspec))
 (set.gloc.of init-env-loadpath\x60;2)
 (close
   (0 0)
   (push.const . operating-system)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 331809)
   (push.const . "windows")
   (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 331792)
   (if.true
     (push.const . "TEMP")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 332823)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (touch.gloc.of directory-exists?\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 334883))
       (if.true
         (call
           (call
             (touch.gloc.of directory-exists?\x60;2)
             (push.const . "~//Ypsilon")
             (push.iloc.0 . 0)
             (push.subr.gloc.of format 2 "./boot/interaction.scm" . 335930)
             (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 335911))
           (if.true.ret)
           (push.const . "~//Ypsilon")
           (push.iloc.0 . 0)
           (push.subr.gloc.of format 2 "./boot/interaction.scm" . 336953)
           (ret.subr.gloc.of create-directory "./boot/interaction.scm" . 336935))
         (push.const . "~//Ypsilon")
         (push.iloc.0 . 0)
         (push.subr.gloc.of format 2 "./boot/interaction.scm" . 337975)
         (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 337955))
       (ret.const.unspec))
     (ret.const.unspec))
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 340032))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 340010)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 339991))
   (if.true
     (push.const . "~//.ypsilon")
     (call (apply.gloc.of home-directory "./boot/interaction.scm" . 341057))
     (push)
     (push.subr.gloc.of format 2 "./boot/interaction.scm" . 341035)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 341015))
   (ret.const.unspec))
 (set.gloc.of init-sys-acc\x60;2)
 (close
   (1 0)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 373810))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 373791))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 374830))
     (push)
     (apply.gloc.of add-load-path "./boot/interaction.scm" . 374815))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in environment variable 'YPSILON_LOADPATH': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 376863))
 (set.gloc.of \x2E;fn6.1\x60;6)
 (close
   (1 0)
   (call
     (touch.gloc.of directory-exists?\x60;2)
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 408611))
     (push)
     (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 408592))
   (if.true
     (call
       (touch.gloc.of expand-path)
       (push.iloc.0 . 0)
       (apply.gloc.of expand-path "./boot/interaction.scm" . 409636))
     (push)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 409616))
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '--acc=~a': directory ~s not exist~%")
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of format 4 "./boot/interaction.scm" . 411664)
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 412688))
 (set.gloc.of set-opt-acc\x60;2)
 (close
   (1 0)
   (subr.gloc.of current-error-port 0)
   (push)
   (push.const . "** ERROR in option '~a'~%")
   (push.iloc.0 . 0)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 416777)
   (call
     (touch.gloc.of show-usage\x60;2)
     (apply.gloc.of show-usage\x60;2 "./boot/interaction.scm" . 417801))
   (push.const . #f)
   (ret.subr.gloc.of exit "./boot/interaction.scm" . 418825))
 (set.gloc.of bad-option\x60;2)
 (close
   (0 0)
   (push.const . #t)
   (push.const
     .
     "Ypsilon 0.9.6-trunk/r~a Copyright (c) 2008 Y.Fujita, LittleWing Company Limited.~%")
   (push.const . ypsilon-revision)
   (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 445545)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 445449))
 (set.gloc.of show-banner\x60;2)
 (close
   (0 0)
   (call
     (touch.gloc.of show-banner\x60;2)
     (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 449545))
   (call
     (push.const . "YPSILON_ACC")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 450576)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_ACC=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 451618))
     (push.const . #t)
     (push.const . ";; YPSILON_ACC unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 452629))
   (call
     (push.const . "YPSILON_SITELIB")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 453648)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_SITELIB=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 454690))
     (push.const . #t)
     (push.const . ";; YPSILON_SITELIB unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 455701))
   (call
     (push.const . "YPSILON_LOADPATH")
     (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 456720)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.const . #t)
       (push.const . ";; YPSILON_LOADPATH=~a~%")
       (push.iloc.0 . 0)
       (ret.subr.gloc.of format "./boot/interaction.scm" . 457762))
     (push.const . #t)
     (push.const . ";; YPSILON_LOADPATH unspecified~%")
     (ret.subr.gloc.of format "./boot/interaction.scm" . 458773))
   (push.const . #t)
   (push.const . ";; (auto-compile-cache) => ~s~%")
   (call (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 459830))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 459785)
   (push.const . #t)
   (push.const . ";; (scheme-library-paths) => ~s~%")
   (call (apply.gloc.of scheme-library-paths "./boot/interaction.scm" . 460856))
   (push)
   (subr.gloc.of format 3 "./boot/interaction.scm" . 460809)
   (push.const . #t)
   (push.const . ";; (scheme-load-paths) => ~s~%")
   (call (apply.gloc.of scheme-load-paths "./boot/interaction.scm" . 461877))
   (push)
   (ret.subr.gloc.of format "./boot/interaction.scm" . 461833))
 (set.gloc.of show-info\x60;2)
 (close
   (0 0)
   (push.const . "YPSILON_ACC")
   (push.subr.gloc.of lookup-process-environment 1 "./boot/interaction.scm" . 345104)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 347183))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 347164))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 348208))
       (push)
       (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 348188))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in environment variable 'YPSILON_ACC': directory ~s not exist~%")
     (push.iloc.0 . 0)
     (subr.gloc.of format 3 "./boot/interaction.scm" . 350236)
     (push.const . #f)
     (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 351260))
   (ret.const.unspec))
 (set.gloc.of init-env-acc\x60;2)
 (close
   (0 0)
   (push.const . #t)
   (push.const . "usage: ypsilon [options] [--] [file] [arguments]~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 422921)
   (push.const . #t)
   (push.const . "options:~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 423945)
   (push.const . #t)
   (push.const . "  --mute (-m)            suppresses greeting~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 424969)
   (push.const . #t)
   (push.const . "  --quiet (-q)           suppresses greeting, repl prompt, and repl output~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 425993)
   (push.const . #t)
   (push.const . "  --verbose (-v)         prints load and compile activities~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 427017)
   (push.const . #t)
   (push.const . "  --warning (-w)         prints warnings~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 428041)
   (push.const . #t)
   (push.const . "  --interactive (-i)     enters repl after running the script file~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 429065)
   (push.const . #t)
   (push.const . "  --r6rs (-6)            conforms r6rs top-level program syntax~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 430089)
   (push.const . #t)
   (push.const . "  --compatible (-c)      extends lexical syntax for compatibility~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 431113)
   (push.const . #t)
   (push.const . "  --sitelib=path         adds sitelib path (YPSILON_SITELIB)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 432137)
   (push.const . #t)
   (push.const . "  --loadpath=path        adds load search path (YPSILON_LOADPATH)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 433161)
   (push.const . #t)
   (push.const . "  --acc=dir              sets a auto-compile-cache directory (YPSILON_ACC)~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 434185)
   (push.const . #t)
   (push.const . "  --heap-limit=mbytes    sets a total heap limit in MBytes~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 435209)
   (push.const . #t)
   (push.const . "  --dump-condition       default exception handler dumps condition~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 436233)
   (push.const . #t)
   (push.const . "  --disable-acc          disables auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 437257)
   (push.const . #t)
   (push.const . "  --clean-acc            cleans auto-compile-cache~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 438281)
   (push.const . #t)
   (push.const . "  --version              prints version and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 439305)
   (push.const . #t)
   (push.const . "  --help                 prints help and exit~%")
   (subr.gloc.of format 2 "./boot/interaction.scm" . 440329)
   (push.const . #t)
   (push.const . "  --                     indicates no more option to proceed~%")
   (ret.subr.gloc.of format "./boot/interaction.scm" . 441353))
 (set.gloc.of show-usage\x60;2)
 (close
   (1 0)
   (push.const . "~a/.")
   (push.iloc.0 . 0)
   (push.subr.gloc.of format 2 "./boot/interaction.scm" . 322583)
   (ret.subr.gloc.of file-exists? "./boot/interaction.scm" . 322569))
 (set.gloc.of directory-exists?\x60;2)
 (close
   (1 0)
   (push.close
     (1 0)
     (call
       (touch.gloc.of directory-exists?\x60;2)
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 385071))
       (push)
       (apply.gloc.of directory-exists?\x60;2 "./boot/interaction.scm" . 385052))
     (if.true
       (call
         (touch.gloc.of expand-path)
         (push.iloc.0 . 0)
         (apply.gloc.of expand-path "./boot/interaction.scm" . 386094))
       (push)
       (apply.gloc.of add-library-path "./boot/interaction.scm" . 386076))
     (subr.gloc.of current-error-port 0)
     (push)
     (push.const . "** ERROR in option '--sitelib=~a': directory ~s not exist~%")
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (subr.gloc.of format 4 "./boot/interaction.scm" . 388124)
     (push.const . #f)
     (ret.subr.gloc.of exit "./boot/interaction.scm" . 389148))
   (call
     (push.const . operating-system)
     (push.subr.gloc.of architecture-feature 1 "./boot/interaction.scm" . 390193)
     (push.const . "windows")
     (subr.gloc.of string-contains 2 "./boot/interaction.scm" . 390176)
     (if.true
       (touch.gloc.of string-split)
       (push.iloc.0 . 0)
       (push.const . #\;)
       (apply.gloc.of string-split "./boot/interaction.scm" . 391200))
     (touch.gloc.of string-split)
     (push.iloc.0 . 0)
     (push.const . #\:)
     (apply.gloc.of string-split "./boot/interaction.scm" . 392224))
   (push)
   (push.subr.gloc.of reverse 1 "./boot/interaction.scm" . 390163)
   (apply.gloc.of for-each "./boot/interaction.scm" . 382983))
 (set.gloc.of add-opt-sitelib\x60;2)
 (close
   (1 0)
   (subr.gloc.of current-output-port 0)
   (push)
   (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 479253)
   (touch.gloc.of default-exception-handler)
   (push.iloc.0 . 0)
   (push.gloc.of \x2E;fn3.1\x60;3)
   (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 480277))
 (set.gloc.of \x2E;fn14.1\x60;14)
 (close
   (0 0 . start-scheme-session)
   (extend.unbound . 9)
   (push.close
     (1 0)
     (subr.gloc.of command-line 0)
     (push)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 465952)
     (push.iloc.0 . 0)
     (push.subr.gloc.of length 1 "./boot/interaction.scm" . 465976)
     (push.subr.gloc.of - 2 "./boot/interaction.scm" . 465949)
     (subr.gloc.of command-line-shift 1 "./boot/interaction.scm" . 465929)
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 466965)
     (extend . 1)
     (iloc 2 . 4)
     (if.true
       (push.close
         (1 0)
         (subr.gloc.of current-output-port 0)
         (push)
         (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 471061)
         (touch.gloc.of default-exception-handler)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (apply.gloc.of default-exception-handler "./boot/interaction.scm" . 472085))
       (push.close
         (0 0)
         (call
           (touch.gloc.of auto-compile-cache-update)
           (apply.gloc.of auto-compile-cache-update "./boot/interaction.scm" . 474133))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 475157))
       (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 469010))
     (push.gloc.of \x2E;fn14.1\x60;14)
     (push.close
       (0 0)
       (call
         (touch.gloc.of auto-compile-cache-update)
         (apply.gloc.of auto-compile-cache-update "./boot/interaction.scm" . 482325))
       (call
         (call
           (iloc 3 . 7)
           (if.true.ret)
           (touch.gloc.of load-file-has-r6rs-comment?)
           (push.iloc.1 . 0)
           (apply.gloc.of load-file-has-r6rs-comment? "./boot/interaction.scm" . 483370))
         (if.true
           (touch.gloc.of load-r6rs)
           (push.iloc.1 . 0)
           (apply.gloc.of load-r6rs "./boot/interaction.scm" . 484377))
         (push.iloc.1 . 0)
         (apply.gloc.of load "./boot/interaction.scm" . 485401))
       (subr.gloc.of current-error-port 0)
       (push)
       (subr.gloc.of flush-output-port 1 "./boot/interaction.scm" . 486421)
       (subr.gloc.of current-output-port 0)
       (push)
       (ret.subr.gloc.of flush-output-port "./boot/interaction.scm" . 487445))
     (apply.gloc.of with-exception-handler "./boot/interaction.scm" . 477202))
   (push.close
     (0 0)
     (call
       (iloc.1 . 6)
       (if.true.ret)
       (iloc.1 . 2)
       (if.true
         (touch.gloc.of show-info\x60;2)
         (apply.gloc.of show-info\x60;2 "./boot/interaction.scm" . 492568))
       (touch.gloc.of show-banner\x60;2)
       (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 493589))
     (call
       (iloc.1 . 5)
       (if.true.ret)
       (touch.gloc.of interpret)
       (push.const import (core) (rnrs))
       (apply.gloc.of interpret "./boot/interaction.scm" . 494612))
     (iloc.1 . 3)
     (if.true
       (touch.gloc.of quiet-read-eval-print-loop)
       (apply.gloc.of quiet-read-eval-print-loop "./boot/interaction.scm" . 496653))
     (touch.gloc.of read-eval-print-loop)
     (apply.gloc.of read-eval-print-loop "./boot/interaction.scm" . 497677))
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (push.const . #f)
   (enclose . 8)
   (subr.gloc.of command-line 0 "./boot/interaction.scm" . 506914)
   (set.iloc 0 . 8)
   (call
     (touch.gloc.of init-sys-acc\x60;2)
     (apply.gloc.of init-sys-acc\x60;2 "./boot/interaction.scm" . 508933))
   (call
     (touch.gloc.of init-env-acc\x60;2)
     (apply.gloc.of init-env-acc\x60;2 "./boot/interaction.scm" . 509957))
   (call
     (touch.gloc.of init-sys-sitelib\x60;2)
     (apply.gloc.of init-sys-sitelib\x60;2 "./boot/interaction.scm" . 510981))
   (call
     (touch.gloc.of init-env-sitelib\x60;2)
     (apply.gloc.of init-env-sitelib\x60;2 "./boot/interaction.scm" . 512005))
   (call
     (touch.gloc.of init-env-loadpath\x60;2)
     (apply.gloc.of init-env-loadpath\x60;2 "./boot/interaction.scm" . 513029))
   (iloc.0 . 8)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (iloc 2 . 4)
       (if.true (apply.iloc (2 . 1) "./boot/interaction.scm" . 520217))
       (iloc 2 . 5)
       (if.true.ret)
       (apply.iloc (2 . 1) "./boot/interaction.scm" . 521252))
     (push.car.iloc (0 . 0) "./boot/interaction.scm" . 523296)
     (extend . 1)
     (extend.enclose
       (2 0)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of string-contains 2 "./boot/interaction.scm" . 527396)
       (extend . 1)
       (iloc.0 . 0)
       (if.false.ret)
       (=n.iloc (0 . 0) 0 "./boot/interaction.scm" . 529449)
       (if.false.ret)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 530468)
       (if.true.ret.const . "")
       (iloc.1 . 1)
       (if.false.ret)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 531526)
       (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 531510)
       (push.const . #\=)
       (subr.gloc.of char=? 2 "./boot/interaction.scm" . 531502)
       (if.false.ret)
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 532534)
       (push.const . 1)
       (push.subr.gloc.of + 2 "./boot/interaction.scm" . 532531)
       (push.iloc 3 . 0)
       (push.subr.gloc.of string-length 1 "./boot/interaction.scm" . 532558)
       (ret.subr.gloc.of substring "./boot/interaction.scm" . 532516))
     (call
       (push.const . "--heap-limit")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 535582))
     (if.true
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 535613)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 535607))
     (call
       (push.const . "--heap-limit")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 536606))
     (if.true
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 536637)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 536631))
     (call
       (push.const . "--no-letrec-check")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 537630))
     (if.true
       (subr.gloc.of current-error-port 0)
       (push)
       (push.const . "** WARNING: '--no-letrec-check' option is deprecated~%")
       (subr.gloc.of format 2 "./boot/interaction.scm" . 538654)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 539684)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 539678))
     (call
       (call
         (push.const . "--warning")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 540706))
       (if.true.ret)
       (push.const . "-w")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 540728))
     (if.true
       (push.const . #t)
       (subr.gloc.of warning-level 1 "./boot/interaction.scm" . 541726)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 542756)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 542750))
     (call
       (push.const . "--version")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 543774))
     (if.true
       (call
         (touch.gloc.of show-banner\x60;2)
         (apply.gloc.of show-banner\x60;2 "./boot/interaction.scm" . 544798))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 545822))
     (call
       (push.const . "--help")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 546846))
     (if.true
       (call
         (touch.gloc.of show-usage\x60;2)
         (apply.gloc.of show-usage\x60;2 "./boot/interaction.scm" . 547870))
       (ret.subr.gloc.of exit "./boot/interaction.scm" . 548894))
     (call
       (call
         (push.const . "--r6rs")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 549922))
       (if.true.ret)
       (push.const . "-6")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 549941))
     (if.true
       (push.const . #f)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 550942)
       (const . #t)
       (set.iloc 4 . 7)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 552996)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 552990))
     (call
       (call
         (push.const . "--compatible")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 554018))
       (if.true.ret)
       (push.const . "-c")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 554043))
     (if.true
       (push.const . #t)
       (subr.gloc.of extend-lexical-syntax 1 "./boot/interaction.scm" . 555038)
       (const . #f)
       (set.iloc 4 . 7)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 557092)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 557086))
     (call
       (call
         (push.const . "--verbose")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 558114))
       (if.true.ret)
       (push.const . "-v")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 558136))
     (if.true
       (call
         (push.const . #t)
         (apply.gloc.of scheme-load-verbose "./boot/interaction.scm" . 559134))
       (call
         (push.const . #t)
         (apply.gloc.of auto-compile-verbose "./boot/interaction.scm" . 560158))
       (const . #t)
       (set.iloc 4 . 2)
       (const . #f)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 563236)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 563230))
     (call
       (call
         (push.const . "--mute")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 564258))
       (if.true.ret)
       (push.const . "-m")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 564277))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 567332)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 567326))
     (call
       (call
         (push.const . "--quiet")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 568354))
       (if.true.ret)
       (push.const . "-q")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 568374))
     (if.true
       (const . #f)
       (set.iloc 4 . 2)
       (const . #t)
       (set.iloc 4 . 6)
       (const . #t)
       (set.iloc 4 . 3)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 572452)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 572446))
     (call
       (call
         (push.const . "--interactive")
         (push.const . #f)
         (apply.iloc (0 . 0) "./boot/interaction.scm" . 573474))
       (if.true.ret)
       (push.const . "-i")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 573500))
     (if.true
       (const . #t)
       (set.iloc 4 . 4)
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 575524)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 575518))
     (call
       (push.const . "--dump-condition")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 576542))
     (if.true
       (call
         (touch.gloc.of dump-condition)
         (push.const . #t)
         (apply.gloc.of dump-condition "./boot/interaction.scm" . 577566))
       (push.cdr.iloc (2 . 0) "./boot/interaction.scm" . 578596)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 578590))
     (call
       (push.const . "--acc")
       (push.const . #f)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 579614))
     (if.true
       (call
         (cdr.iloc (2 . 0) "./boot/interaction.scm" . 580649)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc.1 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 580660))
       (call
         (touch.gloc.of set-opt-acc\x60;2)
         (push.cadr.iloc (2 . 0) "./boot/interaction.scm" . 581675)
         (apply.gloc.of set-opt-acc\x60;2 "./boot/interaction.scm" . 581662))
       (push.cddr.iloc (2 . 0) "./boot/interaction.scm" . 582692)
       (apply.iloc+ (3 . 0) "./boot/interaction.scm" . 582686))
     (call
       (push.const . "--acc")
       (push.const . #t)
       (apply.iloc (0 . 0) "./boot/interaction.scm" . 583710))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 585770)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 2 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 586794))
       (call
         (touch.gloc.of set-opt-acc\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of set-opt-acc\x60;2 "./boot/interaction.scm" . 588842))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 589872)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 589866))
     (call
       (push.const . "--disable-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 590878))
     (if.true
       (call (push.const . #f) (apply.gloc.of auto-compile-cache "./boot/interaction.scm" . 591902))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 592932)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 592926))
     (call
       (push.const . "--clean-acc")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 593950))
     (if.true
       (call
         (touch.gloc.of auto-compile-cache-clean)
         (apply.gloc.of auto-compile-cache-clean "./boot/interaction.scm" . 594974))
       (push.cdr.iloc (3 . 0) "./boot/interaction.scm" . 596004)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 595998))
     (call
       (push.const . "--sitelib")
       (push.const . #f)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 597022))
     (if.true
       (call
         (cdr.iloc (3 . 0) "./boot/interaction.scm" . 598057)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 2 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 598068))
       (call
         (touch.gloc.of add-opt-sitelib\x60;2)
         (push.cadr.iloc (3 . 0) "./boot/interaction.scm" . 599087)
         (apply.gloc.of add-opt-sitelib\x60;2 "./boot/interaction.scm" . 599070))
       (push.cddr.iloc (3 . 0) "./boot/interaction.scm" . 600100)
       (apply.iloc+ (4 . 0) "./boot/interaction.scm" . 600094))
     (call
       (push.const . "--sitelib")
       (push.const . #t)
       (apply.iloc (1 . 0) "./boot/interaction.scm" . 601118))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 603178)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 3 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 604202))
       (call
         (touch.gloc.of add-opt-sitelib\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of add-opt-sitelib\x60;2 "./boot/interaction.scm" . 606250))
       (push.cdr.iloc (4 . 0) "./boot/interaction.scm" . 607280)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 607274))
     (call
       (push.const . "--loadpath")
       (push.const . #f)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 608286))
     (if.true
       (call
         (cdr.iloc (4 . 0) "./boot/interaction.scm" . 609321)
         (if.pair?.ret.const . #t)
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 3 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 609332))
       (call
         (touch.gloc.of add-opt-loadpath\x60;2)
         (push.cadr.iloc (4 . 0) "./boot/interaction.scm" . 610352)
         (apply.gloc.of add-opt-loadpath\x60;2 "./boot/interaction.scm" . 610334))
       (push.cddr.iloc (4 . 0) "./boot/interaction.scm" . 611364)
       (apply.iloc+ (5 . 0) "./boot/interaction.scm" . 611358))
     (call
       (push.const . "--loadpath")
       (push.const . #t)
       (apply.iloc (2 . 0) "./boot/interaction.scm" . 612382))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (push.const . "")
       (subr.gloc.of string=? 2 "./boot/interaction.scm" . 614442)
       (if.true
         (touch.gloc.of bad-option\x60;2)
         (push.iloc 4 . 0)
         (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 615466))
       (call
         (touch.gloc.of add-opt-loadpath\x60;2)
         (push.iloc.0 . 0)
         (apply.gloc.of add-opt-loadpath\x60;2 "./boot/interaction.scm" . 617514))
       (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 618544)
       (apply.iloc+ (6 . 0) "./boot/interaction.scm" . 618538))
     (call
       (push.const . "--")
       (push.const . #f)
       (apply.iloc (3 . 0) "./boot/interaction.scm" . 619550))
     (if.true
       (const . #t)
       (set.iloc 7 . 5)
       (call
         (push.cdr.iloc (5 . 0) "./boot/interaction.scm" . 621611)
         (apply.iloc (7 . 0) "./boot/interaction.scm" . 621598))
       (iloc 7 . 4)
       (if.false.ret)
       (apply.iloc (7 . 1) "./boot/interaction.scm" . 622639))
     (push.iloc 4 . 0)
     (push.const . 0)
     (push.subr.gloc.of string-ref 2 "./boot/interaction.scm" . 623654)
     (push.const . #\-)
     (subr.gloc.of char=? 2 "./boot/interaction.scm" . 623646)
     (if.true
       (touch.gloc.of bad-option\x60;2)
       (push.iloc 4 . 0)
       (apply.gloc.of bad-option\x60;2 "./boot/interaction.scm" . 624670))
     (const . #t)
     (set.iloc 7 . 5)
     (call (push.iloc 5 . 0) (apply.iloc (7 . 0) "./boot/interaction.scm" . 627742))
     (iloc 7 . 4)
     (if.false.ret)
     (apply.iloc (7 . 1) "./boot/interaction.scm" . 628783))
   (push.cdr.iloc (1 . 8) "./boot/interaction.scm" . 517148)
   (apply.iloc+ (0 . 0) "./boot/interaction.scm" . 517132))
 (set.gloc.of start-scheme-session)
 (ret.const.unspec))

;
((subr.gloc.of make-core-hashtable 0 "./boot/libraries.scm" . 5150)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))
((const begin quote define set! lambda let letrec* if or and)
 (set.gloc.of coreform-primitives)
 (ret.const.unspec))
((close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 63560))
   (ret.cons "./boot/libraries.scm" . 63552))
 (set.gloc.of \x2E;fn2.1\x60;2)
 (close
   (2 0)
   (subr.gloc.of current-macro-environment 0)
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 57372)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (subr.gloc.of current-macro-environment 0)
     (push)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 59425))
   (ret.const.unspec))
 (set.gloc.of \x2E;fn12.1\x60;12)
 (close
   (2 0)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 27665))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 28689))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 29718))
   (push)
   (extend . 3)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.1 . 1)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 30729)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 31753)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn8.1\x60;8)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 33837))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 34861)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 33829)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 32804))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 32777))
 (set.gloc.of setup-intrinsic-macros\x60;1)
 (close
   (2 0)
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 1)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 12295)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 13329))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 14353))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 15382))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn10.1\x60;10)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 16393))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 20489)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn7.1\x60;7)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 22573))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 23597)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 22565)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 21540))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 21513))
 (set.gloc.of setup-intrinsic-procs\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 22600))
   (ret.cons "./boot/libraries.scm" . 22592))
 (set.gloc.of \x2E;fn7.1\x60;7)
 (close
   (2 0)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 38929))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 39953))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 40982))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn3.1\x60;3)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 41993))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-variables! 3 "./boot/libraries.scm" . 46089)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn11.1\x60;11)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 48173))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 49197)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 48165)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 47140))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 47113))
 (set.gloc.of setup-core-primitive-procs\x60;1)
 (close
   (2 0)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 53265))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 54289))
   (push)
   (call
     (push.gloc.of core-primitive-name)
     (push.iloc.0 . 1)
     (apply.gloc.of map "./boot/libraries.scm" . 55318))
   (push)
   (extend . 3)
   (call
     (push.gloc.of \x2E;fn12.1\x60;12)
     (push.iloc.0 . 2)
     (push.iloc.1 . 1)
     (apply.gloc.of for-each "./boot/libraries.scm" . 56329))
   (subr.gloc.of system-environment 0)
   (push)
   (subr.gloc.of interaction-environment 0)
   (push)
   (push.iloc.0 . 2)
   (subr.gloc.of copy-environment-macros! 3 "./boot/libraries.scm" . 61449)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of unify-import-bindings)
     (call
       (push.gloc.of \x2E;fn2.1\x60;2)
       (push.iloc.0 . 2)
       (push.iloc.1 . 1)
       (apply.gloc.of map "./boot/libraries.scm" . 63533))
     (push)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.const)
     (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 64557)
     (push.subr.gloc.of append 2 "./boot/libraries.scm" . 63525)
     (apply.gloc.of unify-import-bindings "./boot/libraries.scm" . 62500))
   (push)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 62473))
 (set.gloc.of setup-core-primitive-macros\x60;1)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 33864))
   (ret.cons "./boot/libraries.scm" . 33856))
 (set.gloc.of \x2E;fn8.1\x60;8)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 43053)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 43029)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 44053))
 (set.gloc.of \x2E;fn3.1\x60;3)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of top-level-value 1 "./boot/libraries.scm" . 17453)
   (subr.gloc.of set-top-level-value! 2 "./boot/libraries.scm" . 17429)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 18453))
 (set.gloc.of \x2E;fn10.1\x60;10)
 (close
   (2 0)
   (push.iloc.0 . 1)
   (call
     (touch.gloc.of make-import)
     (push.iloc.0 . 0)
     (apply.gloc.of make-import "./boot/libraries.scm" . 48200))
   (ret.cons "./boot/libraries.scm" . 48192))
 (set.gloc.of \x2E;fn11.1\x60;11)
 (close
   (2 0)
   (call (apply.gloc.of scheme-library-exports "./boot/libraries.scm" . 68625))
   (push)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.0 . 0)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68655))
   (push)
   (extend . 2)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 69676)
   (push.iloc.0 . 0)
   (call
     (touch.gloc.of generate-library-id)
     (push.iloc.1 . 1)
     (apply.gloc.of generate-library-id "./boot/libraries.scm" . 68691))
   (push)
   (push.const)
   (push.subr.gloc.of core-hashtable-ref 3 "./boot/libraries.scm" . 70700)
   (push.subr.gloc.of append 2 "./boot/libraries.scm" . 69668)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 69641))
 (set.gloc.of compound-exports\x60;1)
 (call
   (touch.gloc.of setup-intrinsic-macros\x60;1)
   (push.const core intrinsics)
   (push.const
     library
     define
     define-syntax
     quote
     lambda
     if
     set!
     cond
     case
     and
     or
     let
     let*
     letrec
     letrec*
     let-values
     let*-values
     begin
     quasiquote
     unquote
     unquote-splicing
     let-syntax
     letrec-syntax
     syntax-rules
     identifier-syntax
     assert
     else
     =>
     ...
     _)
   (apply.gloc.of setup-intrinsic-macros\x60;1 "./boot/libraries.scm" . 72707))
 (call
   (touch.gloc.of setup-intrinsic-procs\x60;1)
   (push.const core intrinsics)
   (push.const
     eq?
     eqv?
     equal?
     procedure?
     number?
     complex?
     real?
     rational?
     integer?
     real-valued?
     rational-valued?
     integer-valued?
     exact?
     inexact?
     inexact
     exact
     =
     <
     >
     <=
     >=
     zero?
     positive?
     negative?
     odd?
     even?
     finite?
     infinite?
     nan?
     max
     min
     +
     *
     -
     /
     abs
     div-and-mod
     div
     mod
     div0-and-mod0
     div0
     mod0
     gcd
     lcm
     numerator
     denominator
     floor
     ceiling
     truncate
     round
     rationalize
     exp
     log
     sin
     cos
     tan
     asin
     acos
     atan
     sqrt
     exact-integer-sqrt
     expt
     make-rectangular
     make-polar
     real-part
     imag-part
     magnitude
     angle
     number->string
     string->number
     not
     boolean?
     boolean=?
     pair?
     cons
     car
     cdr
     caar
     cadr
     cdar
     cddr
     caaar
     caadr
     cadar
     caddr
     cdaar
     cdadr
     cddar
     cdddr
     caaaar
     caaadr
     caadar
     caaddr
     cadaar
     cadadr
     caddar
     cadddr
     cdaaar
     cdaadr
     cdadar
     cdaddr
     cddaar
     cddadr
     cdddar
     cddddr
     null?
     list?
     list
     length
     append
     reverse
     list-tail
     list-ref
     map
     for-each
     symbol?
     symbol=?
     symbol->string
     string->symbol
     char?
     char->integer
     integer->char
     char=?
     char<?
     char>?
     char<=?
     char>=?
     string?
     make-string
     string
     string-length
     string-ref
     string=?
     string<?
     string>?
     string<=?
     string>=?
     substring
     string-append
     string->list
     list->string
     string-copy
     string-for-each
     vector?
     make-vector
     vector
     vector-length
     vector-ref
     vector-set!
     vector->list
     list->vector
     vector-fill!
     vector-map
     vector-for-each
     error
     assertion-violation
     apply
     call-with-current-continuation
     call/cc
     values
     call-with-values
     dynamic-wind)
   (apply.gloc.of setup-intrinsic-procs\x60;1 "./boot/libraries.scm" . 84995))
 (call
   (touch.gloc.of setup-core-primitive-macros\x60;1)
   (push.const core primitives)
   (push.const do syntax-case syntax define-macro)
   (apply.gloc.of setup-core-primitive-macros\x60;1 "./boot/libraries.scm" . 131075))
 (call
   (touch.gloc.of setup-core-primitive-procs\x60;1)
   (push.const core primitives)
   (push.const
     environment
     eval
     flonum?
     real->flonum
     fl=?
     fl<?
     fl>?
     fl<=?
     fl>=?
     flinteger?
     flzero?
     flpositive?
     flnegative?
     flodd?
     fleven?
     flfinite?
     flinfinite?
     flnan?
     flmax
     flmin
     fl+
     fl*
     fl-
     fl/
     fldiv
     fldiv0
     flnumerator
     fldenominator
     flfloor
     flceiling
     fltruncate
     flround
     flexp
     flexpt
     fllog
     flsin
     flcos
     fltan
     flasin
     flacos
     flatan
     flabs
     flsqrt
     fixnum->flonum
     fixnum?
     fixnum-width
     least-fixnum
     greatest-fixnum
     fx=?
     fx<?
     fx>?
     fx<=?
     fx>=?
     fxzero?
     fxpositive?
     fxnegative?
     fxodd?
     fxeven?
     fxmax
     fxmin
     fx+
     fx*
     fx-
     fxdiv
     fxdiv0
     fxnot
     fxand
     fxior
     fxxor
     fxif
     fxbit-count
     fxlength
     fxfirst-bit-set
     fxbit-set?
     fxcopy-bit
     fxarithmetic-shift
     fxarithmetic-shift-left
     fxarithmetic-shift-right
     fxbit-field
     fxcopy-bit-field
     &no-infinities
     make-no-infinities-violation
     no-infinities-violation?
     &no-nans
     make-no-nans-violation
     no-nans-violation?
     bitwise-not
     bitwise-and
     bitwise-ior
     bitwise-xor
     bitwise-arithmetic-shift
     bitwise-first-bit-set
     bitwise-length
     bitwise-bit-count
     make-variable-transformer
     identifier?
     bound-identifier=?
     free-identifier=?
     datum->syntax
     syntax->datum
     generate-temporaries
     syntax-violation
     memq
     memv
     member
     assq
     assv
     assoc
     cons*
     list-head
     raise
     raise-continuable
     with-exception-handler
     record?
     record-rtd
     record-type-name
     record-type-parent
     record-type-uid
     record-type-generative?
     record-type-sealed?
     record-type-opaque?
     record-type-field-names
     record-field-mutable?
     make-record-type-descriptor
     record-type-descriptor?
     make-record-constructor-descriptor
     record-constructor
     record-predicate
     record-accessor
     record-mutator
     make-record-type
     record-type?
     record-type-rtd
     record-type-rcd
     condition
     simple-conditions
     condition?
     condition-predicate
     condition-accessor
     &condition
     &message
     make-message-condition
     message-condition?
     condition-message
     &warning
     make-warning
     warning?
     &serious
     make-serious-condition
     serious-condition?
     &error
     make-error
     error?
     &violation
     make-violation
     violation?
     &assertion
     make-assertion-violation
     assertion-violation?
     &irritants
     make-irritants-condition
     irritants-condition?
     condition-irritants
     &who
     make-who-condition
     who-condition?
     condition-who
     &non-continuable
     make-non-continuable-violation
     non-continuable-violation?
     &implementation-restriction
     make-implementation-restriction-violation
     implementation-restriction-violation?
     &lexical
     make-lexical-violation
     lexical-violation?
     &syntax
     make-syntax-violation
     syntax-violation?
     syntax-violation-form
     syntax-violation-subform
     &undefined
     make-undefined-violation
     undefined-violation?
     set-car!
     set-cdr!
     string-set!
     string-fill!
     quotient
     remainder
     modulo
     char-whitespace?
     display
     write
     newline
     read-char
     write-char
     call-with-port
     eof-object
     eof-object?
     standard-input-port
     standard-output-port
     standard-error-port
     current-input-port
     current-output-port
     current-error-port
     input-port?
     output-port?
     port?
     flush-output-port
     output-port-buffer-mode
     close-port
     native-transcoder-descriptor
     port-transcoder-descriptor
     extract-accumulated-bytevector
     extract-accumulated-string
     get-accumulated-string
     open-port
     nonblock-byte-ready?
     lookahead-char
     get-char
     port-has-port-position?
     port-position
     port-has-set-port-position!?
     set-port-position!
     port-eof?
     get-u8
     lookahead-u8
     get-bytevector-n
     get-bytevector-n!
     get-bytevector-all
     get-bytevector-some
     get-string-n
     get-string-n!
     get-string-all
     get-line
     get-datum
     put-u8
     put-bytevector
     put-char
     put-string
     put-datum
     &i/o
     make-i/o-error
     i/o-error?
     &i/o-read
     make-i/o-read-error
     i/o-read-error?
     &i/o-write
     make-i/o-write-error
     i/o-write-error?
     &i/o-invalid-position
     make-i/o-invalid-position-error
     i/o-invalid-position-error?
     i/o-error-position
     &i/o-filename
     make-i/o-filename-error
     i/o-filename-error?
     i/o-error-filename
     &i/o-file-protection
     make-i/o-file-protection-error
     i/o-file-protection-error?
     &i/o-file-is-read-only
     make-i/o-file-is-read-only-error
     i/o-file-is-read-only-error?
     &i/o-file-already-exists
     make-i/o-file-already-exists-error
     i/o-file-already-exists-error?
     &i/o-file-does-not-exist
     make-i/o-file-does-not-exist-error
     i/o-file-does-not-exist-error?
     &i/o-port
     make-i/o-port-error
     i/o-port-error?
     i/o-error-port
     &i/o-decoding
     make-i/o-decoding-error
     i/o-decoding-error?
     &i/o-encoding
     make-i/o-encoding-error
     i/o-encoding-error?
     i/o-encoding-error-char
     file-exists?
     delete-file
     string-hash
     symbol-hash
     equal-hash
     command-line
     exit
     native-endianness
     bytevector?
     make-bytevector
     bytevector-length
     bytevector=?
     bytevector-fill!
     bytevector-copy!
     bytevector-copy
     bytevector-u8-ref
     bytevector-s8-ref
     bytevector-u8-set!
     bytevector-s8-set!
     bytevector->u8-list
     u8-list->bytevector
     bytevector-u16-ref
     bytevector-s16-ref
     bytevector-u16-native-ref
     bytevector-s16-native-ref
     bytevector-u16-set!
     bytevector-s16-set!
     bytevector-u16-native-set!
     bytevector-s16-native-set!
     bytevector-u32-ref
     bytevector-s32-ref
     bytevector-u32-native-ref
     bytevector-s32-native-ref
     bytevector-u32-set!
     bytevector-s32-set!
     bytevector-u32-native-set!
     bytevector-s32-native-set!
     bytevector-u64-ref
     bytevector-s64-ref
     bytevector-u64-native-ref
     bytevector-s64-native-ref
     bytevector-u64-set!
     bytevector-s64-set!
     bytevector-u64-native-set!
     bytevector-s64-native-set!
     bytevector-ieee-single-ref
     bytevector-ieee-single-native-ref
     bytevector-ieee-single-set!
     bytevector-ieee-single-native-set!
     bytevector-ieee-double-ref
     bytevector-ieee-double-native-ref
     bytevector-ieee-double-set!
     bytevector-ieee-double-native-set!
     string->utf8
     utf8->string
     put-fasl
     put-byte
     make-string-output-port
     make-string-input-port
     make-transcoded-port
     make-temporary-file-port
     port-device-subtype
     core-eval
     command-line-shift
     unspecified
     unspecified?
     generate-temporary-symbol
     circular-list?
     circular-tree?
     list-transpose
     list-transpose+
     list-transpose*
     make-parameter
     gensym
     format
     pretty-print
     pretty-print-line-length
     pretty-print-initial-indent
     pretty-print-maximum-lines
     pretty-print-unwrap-syntax
     peek-char
     read
     write-with-shared-structure
     tuple
     tuple?
     make-tuple
     tuple-ref
     tuple-set!
     tuple-length
     tuple-index
     tuple->list
     make-weak-mapping
     weak-mapping?
     weak-mapping-key
     weak-mapping-value
     make-core-hashtable
     core-hashtable?
     make-weak-core-hashtable
     weak-core-hashtable?
     core-hashtable-contains?
     core-hashtable-ref
     core-hashtable-set!
     core-hashtable-delete!
     core-hashtable-clear!
     core-hashtable->alist
     core-hashtable-size
     core-hashtable-copy
     core-hashtable-mutable?
     core-hashtable-equivalence-function
     core-hashtable-hash-function
     usleep
     microsecond
     microsecond->utc
     scheme-error
     architecture-feature
     load-shared-object
     lookup-shared-object
     call-shared-object->void
     call-shared-object->int
     call-shared-object->intptr
     call-shared-object->double
     stdcall-shared-object->void
     stdcall-shared-object->int
     stdcall-shared-object->intptr
     stdcall-shared-object->double
     make-callback
     flonum->float
     string->cstring
     cstring->string
     collect
     collect-notify
     collect-stack-notify
     collect-trip-bytes
     display-heap-statistics
     display-object-statistics
     backtrace
     expansion-backtrace
     backtrace-line-length
     display-backtrace
     warning-level
     restricted-print-line-length
     record-print-nesting-limit
     extend-lexical-syntax
     macro-expand
     compile
     compile-coreform
     closure-code
     current-environment
     current-macro-environment
     current-variable-environment
     current-dynamic-environment
     system-environment
     interaction-environment
     make-environment
     copy-environment-variables!
     copy-environment-macros!
     top-level-bound?
     top-level-value
     set-top-level-value!
     core-read
     current-source-comments
     current-after-expansion-hook
     string-contains
     symbol-contains
     subr?
     make-bytevector-mapping
     scheme-library-exports
     scheme-library-paths
     scheme-load-paths
     scheme-load-verbose
     add-load-path
     add-library-path
     library-extensions
     auto-compile-verbose
     auto-compile-cache
     directory-list
     current-directory
     create-directory
     home-directory
     time-usage
     decode-flonum
     load
     system-share-path
     system
     process
     process-wait
     lookup-process-environment
     set-current-input-port!
     set-current-output-port!
     set-current-error-port!
     open-builtin-data-input-port
     current-library-infix
     current-library-suffix
     current-primitive-prefix
     current-rename-delimiter)
   (apply.gloc.of setup-core-primitive-procs\x60;1 "./boot/libraries.scm" . 137219))
 (touch.gloc.of compound-exports\x60;1)
 (push.const core primitives)
 (push.const core intrinsics)
 (apply.gloc.of compound-exports\x60;1 "./boot/libraries.scm" . 497667))
((gloc.of assertion-violation) (set.gloc.of \x2E;@assertion-violation) (ret.const.unspec))
((gloc.of undefined-violation) (set.gloc.of \x2E;@undefined-violation) (ret.const.unspec))
((gloc.of lexical-violation) (set.gloc.of \x2E;@lexical-violation) (ret.const.unspec))
((gloc.of error) (set.gloc.of \x2E;@error) (ret.const.unspec))
((gloc.of implementation-restriction-violation)
 (set.gloc.of \x2E;@implementation-restriction-violation)
 (ret.const.unspec))
((gloc.of raise-i/o-read-error) (set.gloc.of \x2E;@raise-i/o-read-error) (ret.const.unspec))
((gloc.of raise-i/o-write-error) (set.gloc.of \x2E;@raise-i/o-write-error) (ret.const.unspec))
((gloc.of raise-i/o-file-protection-error)
 (set.gloc.of \x2E;@raise-i/o-file-protection-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-is-read-only-error)
 (set.gloc.of \x2E;@raise-i/o-file-is-read-only-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-already-exists-error)
 (set.gloc.of \x2E;@raise-i/o-file-already-exists-error)
 (ret.const.unspec))
((gloc.of raise-i/o-file-does-not-exist-error)
 (set.gloc.of \x2E;@raise-i/o-file-does-not-exist-error)
 (ret.const.unspec))
((gloc.of raise-i/o-decoding-error) (set.gloc.of \x2E;@raise-i/o-decoding-error) (ret.const.unspec))
((gloc.of raise-i/o-encoding-error) (set.gloc.of \x2E;@raise-i/o-encoding-error) (ret.const.unspec))
((gloc.of raise-i/o-invalid-position-error)
 (set.gloc.of \x2E;@raise-i/o-invalid-position-error)
 (ret.const.unspec))
((gloc.of raise-i/o-filename-error) (set.gloc.of \x2E;@raise-i/o-filename-error) (ret.const.unspec))
((gloc.of raise-i/o-error) (set.gloc.of \x2E;@raise-i/o-error) (ret.const.unspec))
((gloc.of perform-dynamic-wind) (set.gloc.of \x2E;@perform-dynamic-wind) (ret.const.unspec))
((gloc.of start-scheme-session) (set.gloc.of \x2E;@start-scheme-session) (ret.const.unspec))
((gloc.of apply-scheme-proc-assistant)
 (set.gloc.of \x2E;@apply-scheme-proc-assistant)
 (ret.const.unspec))
((gloc.of pretty-print) (set.gloc.of \x2E;@pretty-print) (ret.const.unspec))
((push.const . \x2E;run-vmi)
 (push.gloc.of run-vmi)
 (ret.subr.gloc.of set-top-level-value! "./boot/libraries.scm" . 523265))
((close
   (1 0)
   (push.gloc.of immutable-primitives)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of core-hashtable-set! "./boot/libraries.scm" . 533529))
 (set.gloc.of \x2E;fn1.1\x60;1)
 (push.const
   \x2E;set-top-level-macro!
   \x2E;require-scheme-library
   \x2E;intern-scheme-library
   \x2E;unintern-scheme-library
   \x2E;patvars
   \x2E;syntax-dispatch
   \x2E;flatten-syntax
   \x2E;transformer-thunk
   \x2E;syntax/i0
   \x2E;syntax/i1
   \x2E;syntax/i2
   \x2E;syntax/i3
   \x2E;syntax/c0
   \x2E;syntax/c1
   \x2E;syntax/c2
   \x2E;syntax/c3
   \x2E;run-vmi)
 (extend . 1)
 (call
   (push.gloc.of \x2E;fn1.1\x60;1)
   (push.iloc.0 . 0)
   (apply.gloc.of for-each "./boot/libraries.scm" . 533507))
 (subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.iloc.0 . 0)
 (ret.subr.gloc.of copy-environment-variables! "./boot/libraries.scm" . 534531))
((subr.gloc.of system-environment 0)
 (push)
 (subr.gloc.of interaction-environment 0)
 (push)
 (push.const import)
 (ret.subr.gloc.of copy-environment-macros! "./boot/libraries.scm" . 537601))
((push.gloc.of immutable-primitives)
 (subr.gloc.of core-hashtable-copy 1 "./boot/libraries.scm" . 538652)
 (touch.gloc.of immutable-primitives)
 (set.gloc.of immutable-primitives)
 (ret.const.unspec))

;
